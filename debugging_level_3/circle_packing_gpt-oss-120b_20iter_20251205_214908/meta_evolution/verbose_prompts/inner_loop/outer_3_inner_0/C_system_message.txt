# Prompt Type: C
# Outer Iteration: 3
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are a meta‑prompt engineer. Write a system‑level instruction that will be given to the inner language model which generates the code to be placed inside the `# EVOLVE‑BLOCK‑START` / `# EVOLVE‑BLOCK‑END` region.

**Requirements for the inner model’s output**

- The model must output **only** the Python code that belongs between the `# EVOLVE‑BLOCK‑START` and `# EVOLVE‑BLOCK‑END` markers.  
- Do **not** include the marker lines themselves, any surrounding code, or any explanatory text.  
- Do **not** use markdown formatting or any non‑code characters outside the Python statements.  
- The outer script (including calls such as `run_packing()` and `visualize()`) will be merged automatically; those calls must **not** appear in the output.  
- Any functions that the produced code calls must be **defined** within this block; otherwise a `NameError` will occur.  
- You may add import statements if additional libraries are needed, but `numpy as np` and `scipy.optimize.linprog` are already available.

**Algorithmic guidance (do not mention specific function names)**

- Successful approaches have used a regular hexagonal (triangular) lattice to generate candidate center positions, then assigned each radius as the minimum of the distance to the square’s edges and half the distance to the nearest neighbor. This heuristic guarantees non‑overlap and containment while achieving a high total radius.
- Slightly offsetting the lattice start point (e.g., by half the lattice spacing) avoids placing points too close to the corners and improves the packing score.
- Choosing a lattice spacing that yields at least the required number of points, then trimming excess points that fall outside the unit square, works well for a fixed count of circles.
- After the initial placement, a simple local adjustment (e.g., a few iterations of small random jitter followed by recomputation of radii) can further increase the total radius without breaking constraints.

**What to avoid (failed patterns)**

- Fixed ring or concentric‑circle patterns that place many circles near the center; these lead to low total radius and poor scores.
- Relying solely on a linear‑programming formulation with a limited set of candidate centers; this often plateaus early and cannot reach the best scores.
- Generating centers with inconsistent array shapes or forgetting to convert lists to NumPy arrays before arithmetic operations; this causes shape errors.
- Allowing negative radii; always clip or bound radii at zero to maintain validity.

**Focus for the new code**

- Implement the hexagonal lattice generation with an adjustable spacing parameter, ensuring exactly the required number of circles are produced inside the unit square.
- Compute radii using the minimum‑of‑wall‑distance and half‑nearest‑neighbor‑distance rule, with a final clipping to non‑negative values.
- Optionally include a lightweight refinement step (e.g., small random perturbations with recomputed radii) to boost the total radius.
- Keep the implementation self‑contained: all helper utilities used must be defined within this block, and any additional imports must be declared at the top of the block.