# Prompt Type: C
# Outer Iteration: 2
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are to generate **only** the Python code that will be placed between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  

**Output Requirements**  
- Return exactly the code that belongs inside those markers.  
- Do **not** include the markers themselves, any surrounding code, or any explanatory text.  
- Do **not** use markdown formatting, extra comments, or characters outside the Python code.  

**Imports**  
- You may add additional import statements if needed (e.g., `from scipy.optimize import linprog`).  
- `numpy as np` and `scipy.optimize.linprog` are already available.  

**Algorithmic Guidance**  

1. **Placement Strategy**  
   - Begin with a dense triangular/hexagonal lattice of points that fits inside the unit square.  
   - Offset every other row horizontally by half the lattice spacing so the points form a staggered pattern.  
   - Optionally apply a small random jitter to each lattice point to break perfect symmetry and potentially increase packing density.  

2. **Radius Determination**  
   - For each point compute the distance to the four sides of the square; the maximum allowable radius with respect to the walls is the minimum of those distances.  
   - Compute the Euclidean distance from the point to every other point; the non‑overlap constraint requires the radius to be at most half of the smallest such distance.  
   - Set the radius for the point to the smaller of the wall‑distance bound and the half‑nearest‑neighbor distance, clipping to a non‑negative value.  

3. **Optional Fine‑Tuning**  
   - After the geometric radius assignment, you may formulate a small linear program that maximizes the sum of radii while keeping the same two types of constraints (wall distances and pairwise non‑overlap).  
   - Use the previously computed radii as an initial feasible solution to speed convergence.  

4. **Stochastic Improvement (Optional)**  
   - Perform a limited number of iterations where a random subset of points is perturbed slightly, recompute radii using the geometric rule, and keep the perturbation only if the total summed radius improves.  

**Failure Avoidance**  
- Ensure that the collection of point coordinates is a NumPy array of shape `(n, 2)` before any distance calculations; mismatched shapes cause runtime errors.  
- Do not rely on external functions that are not defined within this block. Every function you call must be defined here.  
- Avoid leaving any circles with zero or negative radius; always clip radii to be ≥ 0.  
- Do not use incomplete or partially‑constructed data structures that could break later visualization or evaluation steps.  

**General Requirements**  
- All helper functions you introduce must be fully defined inside the provided code block.  
- The outer program will automatically call the packing construction routine and then `run_packing()` / `visualize()`, which you must not modify or duplicate.  

Follow these instructions precisely to produce a self‑contained, valid Python implementation that improves the circle‑packing score.