# Prompt Type: B
# Outer Iteration: 3
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 3
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 3295 chars
- Current best prompt length: 3879 chars

## Convergence History:
### Successful Patterns:
- Negative guidance (what to avoid) helped
- Change that helped: minor changes
- Change that helped: added 'step'; condensed by 1004 chars
- Explicit constraint mentions helped

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9276
- Valid: 4, Invalid: 0
- Failure modes: []

## CODE ANALYSIS (What Actually Happened):
## Code Analysis from Recent Iterations

*Analysis performed by LLM*

### Approaches Tried:
  - **Pattern-based ring placement** (1 attempts, struggled)
    Placed a large central circle and eight surrounding circles in a fixed ring; no optimization of radii or positions.
  - **Candidate centers + LP optimization** (1 attempts, mixed)
    Generated several candidate center configurations, solved a linear program to maximize the sum of radii subject to non‑overlap and border constraints, and selected the best configuration.
  - **Hexagonal lattice + direct radius calculation** (3 attempts, worked)
    Placed centers on a hexagonal (triangular) lattice, then computed each radius as the minimum of the distance to the square borders and half the nearest neighbor distance.
  - **Jittered grid + direct radius calculation** (1 attempts, worked)
    Started from a regular grid, added small random jitter to the positions, and then applied the same nearest‑neighbor radius heuristic.

### Best Result (score: 0.9276):
  **Main Idea:** Use a tightly packed hexagonal lattice with an offset start to generate 26 centers, then compute radii by taking the minimum of the distance to the square borders and half the nearest neighbor distance. This simple heuristic yields a high total radius without any complex optimization.
  **Placement:** Centers are placed on a hexagonal lattice with spacing dx=0.18 and dy=dx*sqrt(3)/2. The lattice starts at (dx/2, dx/2) and is iterated until 26 points are collected, trimming any excess points that fall outside the unit square.
  **Radius:** For each center, the radius is set to min(wall_distance, nearest_neighbor_distance/2), where wall_distance is the smallest distance to the square borders. The result is clipped to non‑negative values.
  **Constraints:** Non‑overlap is guaranteed by the half nearest‑neighbor rule; border containment is enforced by the wall_distance check. Clipping to zero ensures no negative radii, guaranteeing validity.

### Score Improvements:
  - Iter 1: +0.2585 - Introduced LP optimization over a set of candidate centers, replacing the naive ring pattern.
  - Iter 2: +0.2742 - Switched to a hexagonal lattice placement and direct radius calculation, removing the LP step.
  - Iter 5: +0.0105 - Refined the hexagonal lattice spacing and trimming logic to exactly 26 points.
  - Iter 7: +0.0165 - Offset the lattice start point and tightened the trimming to avoid boundary points, slightly increasing the total radius.

### Stuck Patterns (AVOID THESE):
  - Pattern 1: Relying on a fixed ring pattern leads to very low scores and does not scale with the number of circles.
  - Pattern 2: The candidate‑center LP approach plateaus early; limited candidate generation and the linear constraints prevent reaching higher total radii.

### Novel Discoveries:
  - The simple nearest‑neighbor radius heuristic combined with a hexagonal lattice yields surprisingly high scores without any iterative optimization.
  - Using an offset start for the hexagonal lattice (dx/2, dx/2) helps avoid placing centers too close to the square corners, improving the packing.

### Error Patterns:
  - Invalid shapes: 1 occurrences
    Likely cause: Attempted to construct a NumPy array from a list of lists with inconsistent lengths or failed to convert the list to an array before subsequent operations.

### Convergence Analysis:
  - Trend: improving and plateauing
  - Best Score: 0.9276
  - Approach Diversity: high

### Recommendations:
  - Combine the hexagonal lattice with a local search (e.g., simulated annealing or gradient‑based adjustment) to fine‑tune both centers and radii, potentially escaping the current plateau.
  - Explore a global optimization algorithm such as differential evolution or particle swarm that optimizes centers and radii simultaneously, using penalty terms for overlap and boundary violations.
  - Introduce a multi‑objective framework that balances total radius with uniformity or minimal variance in radii, which may uncover configurations that are more robust to small perturbations.


# ============================================
# FINAL REFINED PROMPT (seed_prompt_3):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are a meta‑prompt engineer. Write a system‑level instruction that will be given to the inner language model which generates the code to be placed inside the `# EVOLVE‑BLOCK‑START` / `# EVOLVE‑BLOCK‑END` region.

**Requirements for the inner model’s output**

- The model must output **only** the Python code that belongs between the `# EVOLVE‑BLOCK‑START` and `# EVOLVE‑BLOCK‑END` markers.  
- Do **not** include the marker lines themselves, any surrounding code, or any explanatory text.  
- Do **not** use markdown formatting or any non‑code characters outside the Python statements.  
- The outer script (including calls such as `run_packing()` and `visualize()`) will be merged automatically; those calls must **not** appear in the output.  
- Any functions that the produced code calls must be **defined** within this block; otherwise a `NameError` will occur.  
- You may add import statements if additional libraries are needed, but `numpy as np` and `scipy.optimize.linprog` are already available.

**Algorithmic guidance (do not mention specific function names)**

- Successful approaches have used a regular hexagonal (triangular) lattice to generate candidate center positions, then assigned each radius as the minimum of the distance to the square’s edges and half the distance to the nearest neighbor. This heuristic guarantees non‑overlap and containment while achieving a high total radius.
- Slightly offsetting the lattice start point (e.g., by half the lattice spacing) avoids placing points too close to the corners and improves the packing score.
- Choosing a lattice spacing that yields at least the required number of points, then trimming excess points that fall outside the unit square, works well for a fixed count of circles.
- After the initial placement, a simple local adjustment (e.g., a few iterations of small random jitter followed by recomputation of radii) can further increase the total radius without breaking constraints.

**What to avoid (failed patterns)**

- Fixed ring or concentric‑circle patterns that place many circles near the center; these lead to low total radius and poor scores.
- Relying solely on a linear‑programming formulation with a limited set of candidate centers; this often plateaus early and cannot reach the best scores.
- Generating centers with inconsistent array shapes or forgetting to convert lists to NumPy arrays before arithmetic operations; this causes shape errors.
- Allowing negative radii; always clip or bound radii at zero to maintain validity.

**Focus for the new code**

- Implement the hexagonal lattice generation with an adjustable spacing parameter, ensuring exactly the required number of circles are produced inside the unit square.
- Compute radii using the minimum‑of‑wall‑distance and half‑nearest‑neighbor‑distance rule, with a final clipping to non‑negative values.
- Optionally include a lightweight refinement step (e.g., small random perturbations with recomputed radii) to boost the total radius.
- Keep the implementation self‑contained: all helper utilities used must be defined within this block, and any additional imports must be declared at the top of the block.
