## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are to generate **only** the Python code that will be placed between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.

**OUTPUT REQUIREMENTS**  
- Output **exactly** the code that belongs inside those markers.  
- Do **not** include the markers themselves, any surrounding code, or any explanatory text.  
- Do **not** use markdown formatting.  
- Every function you call must be defined within the provided code block; the block must be self‑contained.

**IMPORTS**  
- You may add additional import statements if needed (e.g., `from scipy.optimize import minimize`).  
- `numpy as np` and `scipy.optimize.linprog` are already available.

**ALGORITHMIC GUIDANCE**  

1. **Placement strategy**  
   - Start with a hexagonal (triangular) lattice that fits inside the unit square.  
   - Choose a spacing `dx` and compute the vertical spacing `dy = dx * sqrt(3) / 2`.  
   - Offset every other row by `dx/2` to create the staggered pattern.  
   - Trim the generated points so that exactly the required number of circles (26) remain, keeping only points that lie fully inside the unit square.

2. **Radius computation**  
   - For each center, compute the distance to the four walls of the unit square; the wall distance is the minimum of those four values.  
   - Compute the Euclidean distance to every other center, find the nearest neighbor distance, and take half of that value.  
   - The feasible radius for a center is the minimum of its wall distance and half‑nearest‑neighbor distance, clipped to be non‑negative.

3. **Optional local refinement**  
   - After the initial lattice placement, you may perform a lightweight local adjustment (e.g., a few iterations of gradient‑based or simple random jitter) that preserves feasibility: after each move recompute the radius using the rule above and accept the move only if the new radius is not smaller than the previous one for that circle and no overlap is introduced.

4. **Robustness checks**  
   - Ensure that the array of centers is a proper `np.ndarray` with shape `(n, 2)` before performing vectorized operations.  
   - Guard against shape mismatches that can arise from list‑to‑array conversion errors.  
   - Avoid heavy reliance on random generation combined with linear programming; the direct geometric method described above is sufficient and more reliable.

5. **Return format**  
   - The primary entry point must return two objects: an `(n, 2)` array of center coordinates and a length‑`n` array of radii, in that order.  

Follow these directions precisely while respecting the output format constraints.