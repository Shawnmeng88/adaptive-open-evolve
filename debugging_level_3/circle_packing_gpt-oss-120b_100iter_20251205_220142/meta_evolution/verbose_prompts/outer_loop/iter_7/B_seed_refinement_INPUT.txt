# Prompt Type: B
# Outer Iteration: 7
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 7
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 8457 chars
- Current best prompt length: 5266 chars

## Convergence History:
### Successful Patterns:
- Change that helped: expanded by 519 chars
- Change that helped: expanded by 881 chars
- Explicit constraint mentions helped
- Negative guidance (what to avoid) helped
- Change that helped: minor changes
- Change that helped: condensed by 311 chars
- Change that helped: added 'step'; condensed by 498 chars

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9983
- Valid: 7, Invalid: 3
- Failure modes: ['Validity failures: 3/10 (30.0%)']

## CODE ANALYSIS (What Actually Happened):
## Code Analysis from Recent Iterations

*Analysis performed by LLM*

### Approaches Tried:
  - **grid_based_placement** (1 attempts, struggled)
    Positions circles on a regular 5×5 grid with a dummy point; radii are computed directly from border and pairwise distances.
  - **hex_lattice_with_lp** (2 attempts, mixed)
    Generates a hexagonal lattice of candidate centers, solves a linear program to maximize the sum of radii while respecting border and non‑overlap constraints.
  - **radius_only_computation** (1 attempts, struggled)
    Computes feasible radii for a given set of centers using border distances and nearest‑center distances, but does not perform any placement optimization.
  - **candidate_pool_lp_slsqp_restarts** (3 attempts, mixed)
    Creates a dense pool of hexagonal candidates, solves an LP for all candidates, selects the 26 largest radii, and refines positions and radii with SLSQP, optionally repeating with random restarts.

### Best Result (score: 0.998):
  **Main Idea:** Use a dense hexagonal candidate grid to generate many potential circle centers, compute maximal radii for all candidates via a linear program, keep the 26 circles with the largest radii, then jointly refine positions and radii with a short SLSQP run and several random restarts to escape local optima.
  **Placement:** Centers are placed on a hexagonal lattice that fully covers the unit square; the lattice spacing is chosen to produce roughly 40–50 candidates.
  **Radius:** A linear program maximizes the sum of radii with constraints that each radius is bounded by the distance to the square borders and half the distance to every other candidate center.
  **Constraints:** The LP guarantees non‑overlap and border feasibility; the subsequent SLSQP optimization enforces the same constraints while allowing small adjustments to improve packing density.

### Score Improvements:
  - Iter 28: +0.996 - Introduced LP + SLSQP refinement on a hexagonal lattice, moving from a trivial grid to a sophisticated optimization pipeline.

### Stuck Patterns (AVOID THESE):
  - Pattern 1: Code fragments that reference undefined functions (e.g., generate_hex_centers) or incomplete variable names, leading to runtime errors and zero scores.
  - Pattern 2: Overly sparse candidate generation (e.g., a single 5×5 grid) that fails to produce any feasible packing beyond trivial solutions.

### Novel Discoveries:
  - Combining a linear program that yields a globally optimal radius set for a fixed grid with a local SLSQP refinement that can adjust both positions and radii simultaneously, thereby escaping the rigid grid structure.

### Error Patterns:
  - Invalid shapes: 1 occurrences
    Likely cause: Mismatched array dimensions during LP formulation or radius calculation.
  - NameError: generate_hex_centers: 2 occurrences
    Likely cause: Attempting to use a helper function that was never defined or imported.

### Convergence Analysis:
  - Trend: improving then plateauing
  - Best Score: 0.998
  - Iterations Since Improvement: 10
  - Approach Diversity: high

### Recommendations:
  - Expand the candidate pool by varying hexagonal spacings and adding random jitter, then apply the LP + SLSQP pipeline to each pool to increase the chance of discovering higher‑density packings.
  - Introduce a global stochastic search (e.g., simulated annealing or differential evolution) to perturb the initial candidate centers before the LP step, which may help escape local optima that the LP alone cannot overcome.
  - Refactor the code into modular functions with clear interfaces and add comprehensive unit tests for each component (candidate generation, LP formulation, SLSQP refinement) to prevent undefined‑function errors and shape mismatches.


# ============================================
# FINAL REFINED PROMPT (seed_prompt_7):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are to generate **only** the Python code that will replace the contents between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers. Do not include the marker lines themselves, any surrounding code, or any explanatory text outside of valid Python. The outer framework will insert `run_packing()` and `visualize()` automatically.

### Mandatory Output Rules
- Output **exactly** the code fragment to be placed inside the evolve block.  
- No markdown fences, comments that are not part of the code, or any other non‑code characters.  
- All functions that your code calls must be defined within this fragment. Missing definitions will cause a runtime error.

### Imports
- You may add additional import statements if needed (e.g., `from scipy.optimize import minimize`).  
- `numpy as np` and `scipy.optimize.linprog` are already available.

### Focus of the Implementation
- Design a pipeline that constructs a high‑quality packing of 26 equal‑radius circles inside the unit square.
- The algorithm should follow these proven steps, expressed in your own modular functions:

1. **Dense Hexagonal Candidate Generation**  
   - Create a hexagonal lattice that fully covers the unit square.  
   - Use a spacing that yields roughly 40‑60 candidate points.  
   - Optionally add a small random jitter to each candidate to break symmetry.

2. **Linear‑Programmed Radius Maximization**  
   - For the fixed candidate centers, formulate a linear program that maximizes the sum (or average) of radii.  
   - Constraints: each radius ≤ distance to the four square borders; for every pair of candidates, radius_i + radius_j ≤ Euclidean distance between their centers.  
   - Solve the LP to obtain a feasible radius for every candidate.

3. **Selection of Top Candidates**  
   - Sort candidates by the obtained radius and keep the 26 with the largest values.  
   - Preserve their centers and radii as the initial packing.

4. **Local Continuous Refinement**  
   - Use a gradient‑based optimizer (e.g., `scipy.optimize.minimize` with method `SLSQP`) to jointly adjust the selected centers and radii.  
   - Objective: maximize the minimum radius (or equivalently maximize the sum of radii).  
   - Keep the same non‑overlap and border constraints as in the LP, but now allow the centers to move slightly for a tighter configuration.  
   - Run the refinement for a modest number of iterations (e.g., 200‑300) to keep execution time reasonable.

5. **Multiple Random Restarts**  
   - Repeat steps 1‑4 a few times (e.g., 3‑5 restarts) with different jitter seeds or slightly varied lattice spacings.  
   - Keep the packing that yields the largest minimum radius across all attempts.

### What to Avoid (Common Failure Patterns)
- **Undefined helpers**: Do not reference functions that are not defined in this block. Every called routine must have its own definition here.  
- **Sparse candidate sets**: Grids with fewer than ~30 candidates typically cannot achieve high density; ensure the lattice is dense enough.  
- **Shape mismatches**: When building the LP matrices, verify that vector and matrix dimensions align; mismatched shapes cause immediate crashes.  
- **Missing constraints**: Forgetting either the border or the pairwise non‑overlap constraints leads to invalid packings and score penalties.  
- **Excessive runtime**: Extremely large candidate pools or overly long optimizer runs can exceed the time budget; keep the total number of candidates and optimizer iterations modest.

### Implementation Tips
- Structure the code with clear helper functions: one for lattice generation, one for LP formulation/solution, one for the SLSQP refinement, and a driver that orchestrates the restarts and selects the best result.  
- Return from the main construction routine a tuple or dictionary containing the final centers and radii in the format expected by the outer framework.  
- Include appropriate `if __name__ == "__main__":` guard only if you need to test locally; it will be ignored when the block is inserted.  

Follow these guidelines precisely to produce a self‑contained, robust solution that improves the packing density while satisfying all evaluation constraints.
