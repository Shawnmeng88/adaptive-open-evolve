# Prompt Type: C
# Outer Iteration: 2
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Guidance for Code Evolution**

You must output **only** the Python code that belongs between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers. Do **not** include the markers themselves, any surrounding text, or calls to `run_packing()` / `visualize()`. The surrounding framework will automatically add those parts.

**Mandatory Output Rules**
- The response must consist solely of valid Python code for the evolve block.
- No explanatory comments outside of normal code comments are allowed.
- Every function or class you reference must be fully defined within this block.
- Do not import modules that are already available unless you need additional functionality; you may add import statements if required.

**Algorithmic Guidance**

*What has worked well:*
- Start with a dense arrangement of points (e.g., hexagonal lattice, tightly packed random set) that fits inside the unit square.
- For each fixed center, compute the largest possible radius that satisfies:
  1. Distance to each side of the square.
  2. Half the Euclidean distance to the nearest neighboring center.
- This radius can be obtained analytically or by solving a small linear program that maximizes a single radius under linear constraints.
- After initial radii are assigned, optionally refine the positions of the centers using a local optimization step (gradient‑based or simple coordinate perturbations) while re‑computing maximal feasible radii after each move. This can escape local optima and improve overall packing density.
- If the required number of circles exceeds the number of points generated by the lattice, add “dummy” points that are placed far outside the feasible region; they will receive a radius of zero and thus do not affect validity.

*Techniques to try for improvement:*
1. **Hexagonal / staggered grids** – they provide tighter packing than square grids.
2. **Random dense seeding** followed by pruning – generate many points, keep the subset that yields the best minimal radius after radius computation.
3. **Iterative removal** – repeatedly drop the circle with the smallest feasible radius, recompute radii, and stop when the target count is reached.
4. **Local position adjustment** – perturb each center slightly (e.g., small random shifts) and accept the change only if the minimal radius across all circles does not decrease. Perform several passes to converge.
5. **Full evolutionary loop** – mutate both center coordinates and radii simultaneously, evaluate a fitness that penalizes overlaps and boundary violations, and keep the best individuals.

*What to avoid (common failure modes):*
- Leaving any radius undefined or zero for a non‑dummy circle; this makes the packing invalid.
- Omitting the definition of any helper function you call, which leads to `NameError`.
- Introducing syntax errors or incomplete code blocks; the program must run without interruption.
- Relying solely on a fixed grid without any refinement; this often caps the score at a plateau.
- Using constraints that are not linear when you intend to solve them with `linprog`; ensure all constraints passed to the linear program are linear expressions.

**Implementation Tips**
- Use `numpy` for vectorized distance calculations.
- Use `scipy.optimize.linprog` for any linear‑programming step; formulate each radius maximization as a separate LP with variables `[r]` and constraints `r <= distance_to_border` and `r <= distance_to_neighbor - other_radius`.
- Keep the code modular: separate point generation, radius computation, and optional refinement into distinct helper functions.
- Ensure the final returned data structure matches the expected format of the outer framework (e.g., a tuple or dict containing arrays of centers and radii).

Follow these instructions precisely to produce a valid, self‑contained code block that improves the circle‑packing solution.