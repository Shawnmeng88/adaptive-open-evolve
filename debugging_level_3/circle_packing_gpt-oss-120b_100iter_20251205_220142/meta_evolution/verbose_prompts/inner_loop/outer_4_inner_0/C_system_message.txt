# Prompt Type: C
# Outer Iteration: 4
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are to generate the complete replacement for the evolve block. **Output ONLY the Python code that belongs between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers** – do not include the markers themselves, any surrounding text, or calls such as `run_packing()` or `visualize()`. The surrounding framework will insert those automatically.

### Mandatory Output Rules
- Return **exactly** the code that will replace the contents of the evolve block.  
- No markdown fences, extra characters, or comments outside normal code comments.  
- Do not import modules that are already available unless you need additional functionality; you may add imports (e.g., `from scipy.optimize import minimize`) if required.  
- Every function, class, or helper that your code calls must be **defined within the output**; missing definitions will cause a runtime error.  

### Algorithmic Guidance (what to implement)

1. **Generate a dense candidate set of circle centers** covering the unit square using a hexagonal (triangular) lattice. Choose a lattice spacing that ensures at least 30‑35 candidate points so that after pruning you can keep exactly 26 circles.  
2. **Optionally add a small random jitter** to each candidate center (e.g., uniform noise with magnitude ≈ 0.01 × spacing) to break symmetry and help later non‑linear optimization escape local minima.  
3. **Formulate a linear program** that maximizes the sum of radii subject to:
   - Border constraints: for each circle `i`, `x_i - r_i ≥ 0`, `x_i + r_i ≤ 1`, `y_i - r_i ≥ 0`, `y_i + r_i ≤ 1`.
   - Pairwise non‑overlap constraints: for every pair `(i, j)`, `r_i + r_j ≤ distance(center_i, center_j)`.
   - Non‑negativity of radii.
   Solve the LP to obtain a feasible set of radii for **all** candidate centers.

4. **Select the 26 circles with the largest radii** from the LP solution. Keep their centers and the corresponding radii as the initial configuration for the next stage.

5. **Refine positions and radii jointly** using a nonlinear optimizer (e.g., `scipy.optimize.minimize` with method `'SLSQP'`). Define a variable vector that concatenates the `x`, `y`, and `r` values of the 26 circles.  
   - Objective: maximize the total sum of radii (or equivalently minimize the negative sum).  
   - Constraints: same border and pairwise non‑overlap inequalities as in the LP, now applied to the mutable positions as well as radii.  
   - Provide reasonable bounds: `0 ≤ r ≤ 0.5`, `0 ≤ x ≤ 1`, `0 ≤ y ≤ 1`.  
   - Use a tolerance that allows the optimizer to converge (e.g., `ftol=1e-9`).  

6. **After optimization, verify feasibility** by checking all constraints; if any violation exceeds a tiny epsilon (e.g., `1e-6`), optionally perform a short corrective projection step or re‑run the optimizer with tightened tolerances.

7. **Return the final list/array of circles** (centers and radii) in the format expected by the surrounding framework.

### Pitfalls to Avoid (what NOT to do)

- **Do not rely solely on a fixed regular grid** without any optimization; this yields very low scores because radii are limited by hard‑coded margins.  
- **Do not stop after the linear program**; using only the LP radii without adjusting positions leaves substantial slack and limits packing density.  
- **Do not omit the definition of any helper you call** (e.g., lattice generator, distance calculator, constraint builders). Every referenced name must be defined in the output.  
- **Do not create mismatched array shapes** when building the LP constraint matrices; ensure each inequality row aligns with a single variable or pair of variables.  
- **Do not forget to include border constraints** for both `x` and `y`; forgetting any side leads to circles extending outside the unit square and invalid solutions.  
- **Do not use overly large jitter** that pushes candidates outside the unit square before clipping; keep jitter small relative to the lattice spacing.  

### Imports

- `numpy as np` and `scipy.optimize.linprog` are already available.  
- You may add additional imports such as `from scipy.optimize import minimize` or `from itertools import combinations` if needed.

### Final Reminder

Your submitted code must be **self‑contained**: all functions used within the block must be defined there, and the block must respect the strict output format described above. Follow the algorithmic steps and avoid the listed pitfalls to produce a high‑quality circle‑packing solution.