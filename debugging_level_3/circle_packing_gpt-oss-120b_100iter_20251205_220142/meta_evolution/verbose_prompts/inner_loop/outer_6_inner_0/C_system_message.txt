# Prompt Type: C
# Outer Iteration: 6
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Evolve Block Generation**

You must output **only** the Python code that will replace the contents of the evolve block (the region between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`). Do **not** include the marker lines themselves, any surrounding code, or calls such as `run_packing()` or `visualize()`. The outer framework will insert those automatically.

### Mandatory Output Rules
- **Exact content**: the submitted text must be a valid Python module fragment that can be placed directly between the two markers.
- **No extra characters**: do not wrap the code in markdown fences, comments outside normal code, or any other non‑code text.
- **All dependencies**: any function, class, or variable you reference must be defined within this fragment (or imported here). Missing definitions will cause a `NameError`.
- **Imports**: you may add import statements if needed, but `numpy as np` and `scipy.optimize.linprog` are already available globally. Do not re‑import modules that are already present unless you need additional packages.

### Focus of the Implementation
- **Goal**: construct a high‑quality packing of exactly 26 circles inside the unit square, maximizing the total area (or equivalently the sum of radii) while respecting border and non‑overlap constraints.
- **Effective strategy (keep)**  
  1. **Generate a dense hexagonal lattice** of candidate centre points that covers the unit square. Optionally add a tiny random jitter to each point to break symmetry.  
  2. **Formulate a linear program** that assigns a radius to every candidate point. The LP should:  
     - Maximise the sum of all radii (or a weighted combination of sum and minimum radius).  
     - Enforce that each radius is non‑negative and does not exceed the distance to the square’s edges.  
     - Impose linearised non‑overlap constraints: for any pair of candidates, the sum of their radii must be ≤ the Euclidean distance between the centres.  
  3. **Select the 26 candidates with the largest radii** from the LP solution; discard the rest.  
  4. **Refine the chosen 26 circles** with a short, constrained local optimisation (e.g., `scipy.optimize.minimize` using the SLSQP method) that directly enforces the true (non‑linear) distance constraints and border limits.  
  5. **Perform multiple random restarts**: repeat steps 1‑4 with different lattice spacings and jitter seeds, keeping the best feasible packing found.  
  6. **Return** the final arrays of centre coordinates and radii in the format expected by the outer framework.

- **Helper utilities** you may include:  
  * Function to build the hexagonal lattice given a spacing parameter.  
  * Function to compute pairwise distances efficiently (e.g., using NumPy broadcasting).  
  * Wrapper that builds the LP matrices (`A_ub`, `b_ub`, `c`) from the candidate set.  
  * Small routine that runs the SLSQP refinement for a given initial configuration.  
  * Optional random‑restart driver that aggregates results and selects the best.

### Patterns that Must Be Avoided (failed approaches)
- **Plain regular grids** without any subsequent optimisation – they leave large unused space and often violate the radius constraints after clipping.
- **Missing definitions**: any helper you call must be defined in this fragment; otherwise the program crashes before evaluation.
- **Syntax errors** such as unmatched parentheses, stray commas, or incorrect indentation – these prevent the code from loading.
- **Overly aggressive radius clipping** before the LP step, which reduces the feasible region and leads to zero‑score solutions.
- **Skipping the non‑linear refinement**: relying solely on the LP solution can leave marginal overlaps because the LP uses linearised constraints.

### Additional Guidance
- Keep numerical tolerances reasonable (e.g., `1e-9`) when checking feasibility after refinement.
- Ensure the LP is built with a feasible initial bound (e.g., set every radius ≤ 0.5) to avoid infeasibility due to overly tight constraints.
- When performing random restarts, vary both the lattice spacing (e.g., between 0.07 and 0.15) and the jitter amplitude (e.g., up to 0.005) to explore diverse configurations.
- Return the final result as two NumPy arrays: `centers` of shape `(26, 2)` and `radii` of shape `(26,)`.

Follow the rules above precisely; the resulting code will be inserted into the evolve block and executed by the outer system. Good luck!