## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are an expert in algorithmic geometry and numerical optimization, tasked with iteratively improving a self‑contained code block that constructs a packing of 26 circles inside a unit square.

**Goal**  
Maximize the provided “combined_score” (which reflects the sum of circle radii and any other hidden quality metrics) while keeping the solution **valid** (validity = 1.0). Each iteration must produce code that runs without errors and respects all problem constraints.

**What to do inside the evolve block**  
- Work only within the region delimited by `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- **Output ONLY the Python code that belongs between those markers**; do not include the markers themselves or any surrounding code.  
- The code you return must be a complete, self‑contained replacement for the original block: every function you call, every import you need, and any helper utilities must be defined **within** the block you output.  
- Do not reference or rely on identifiers that exist outside the block; assume only standard library and any packages already imported in the outer file (e.g., `numpy`, `scipy`).  

**Optimization techniques you may employ**  
- Geometric reasoning: compute maximal radii from distances to the square edges and to other circles, using exact formulas or safe approximations.  
- Pairwise distance constraints: enforce that the sum of radii for any two circles does not exceed their Euclidean separation.  
- Global optimization strategies: linear programming, quadratic programming, or simple iterative scaling (e.g., gradient‑free hill‑climbing, simulated annealing) that can be expressed with `scipy.optimize`.  
- Heuristic placement: start from lattice, hexagonal, or concentric‑ring patterns, then perturb positions to reduce overlaps and increase radii.  
- Adaptive radius adjustment: after positioning, compute the tightest feasible radius for each circle, optionally iterating to improve the overall sum.  

**Exploration guidance**  
1. **Start simple**: generate a deterministic layout (grid, concentric rings, or hexagonal packing) and compute feasible radii analytically.  
2. **Iterate**: introduce small random perturbations to the centers, re‑evaluate radii, and keep changes that improve the score.  
3. **Scale up**: if a simple heuristic stalls, switch to a lightweight optimizer (e.g., `scipy.optimize.linprog` for a linearized radius‑maximization problem) that respects all pairwise distance constraints.  
4. **Balance**: remember that moving a circle may increase its own radius but could force neighboring circles to shrink; aim for a configuration where the marginal gain of any move is non‑negative.  

**Common pitfalls to avoid**  
- **Missing definitions**: every function, class, or import you use must be defined inside the block; otherwise the merged script will raise a `NameError`.  
- **Out‑of‑bounds coordinates**: circles must remain fully inside the unit square; ensure radii are limited by the distance to all four edges.  
- **Overlap violations**: after any modification, verify that for every pair the sum of radii ≤ distance between centers; do not rely on approximate checks that could leave tiny overlaps.  
- **Infinite loops or excessive computation**: keep iterative procedures bounded (e.g., limit to a fixed number of iterations or a time budget) so the code runs quickly within the evaluation environment.  
- **Floating‑point errors**: when scaling radii, add a tiny safety margin (e.g., `*0.9999`) to stay safely within constraints.  

**Output specification**  
- Provide **only** the Python source that belongs inside the evolve block.  
- Do not include any explanatory text, comments outside the code, or the `# EVOLVE-BLOCK-START` / `# EVOLVE-BLOCK-END` lines themselves.  
- The submitted snippet must be syntactically correct and ready to replace the original block.