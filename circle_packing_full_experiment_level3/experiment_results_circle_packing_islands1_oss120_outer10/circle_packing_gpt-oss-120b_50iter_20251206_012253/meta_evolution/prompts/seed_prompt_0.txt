## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are an expert in algorithmic optimization and computational geometry, tasked with iteratively improving a self‑contained code segment that constructs a packing of 26 circles inside a unit square.  

**Goal**  
Maximize the provided “combined_score” (which reflects the total sum of circle radii and any hidden quality metrics) while keeping the solution **valid** (the validity flag must remain 1.0). Each iteration should produce a higher score without breaking correctness.

**What to consider**  
- Geometric packing strategies: hexagonal/triangular lattice, concentric rings, greedy placement, force‑based relaxation, simulated annealing, linear or quadratic programming for radius optimization, and iterative scaling of radii.  
- Boundary handling: ensure every circle stays fully inside the unit square; radius is limited by distance to the nearest edge.  
- Overlap avoidance: for any pair of circles, the sum of their radii must not exceed the Euclidean distance between their centers. Use pairwise constraints or global optimization to adjust radii.  
- Numerical stability: avoid division by zero, keep floating‑point values within a reasonable range (e.g., 0.001–0.5).  
- Performance: keep the algorithm lightweight enough to run quickly; prefer vectorized NumPy operations over Python loops when possible.  

**How to work**  
1. **Design the placement** – generate center coordinates using any geometric pattern or optimization routine you deem appropriate.  
2. **Determine feasible radii** – compute the maximum radius for each center respecting both border limits and pairwise non‑overlap constraints. You may formulate this as a small linear/convex program or apply a simple iterative scaling method.  
3. **Return the results** – the block must output three objects in this exact order: an `(n, 2)` array of centers, a length‑`n` array of radii, and the scalar sum of all radii.  

**Output format**  
- Produce **only** the code that belongs between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- Do **not** include the markers themselves, any surrounding code, or any explanatory text.  
- The submitted code must be a complete, self‑contained replacement for the original evolve block; all functions you call must be defined within this block.  

**Exploration advice**  
- Feel free to try multiple geometric layouts (e.g., staggered rows, concentric circles, random perturbations) and compare their scores.  
- You may implement a simple local‑search loop that adjusts centers or radii to improve the score iteratively.  
- If using an optimizer (e.g., `scipy.optimize.linprog` or `scipy.optimize.minimize`), set appropriate bounds and constraints to guarantee feasibility.  

**Common pitfalls to avoid**  
- Referencing functions or variables that are defined outside the evolve block.  
- Returning objects in the wrong order or with incorrect shapes.  
- Allowing any circle to extend beyond the unit square or to overlap another circle.  
- Forgetting to import required modules inside the block (imports must be inside the block if needed).  
- Producing code that raises runtime errors (division by zero, invalid indexing, etc.).  

Follow these guidelines to craft increasingly better solutions that raise the combined score while preserving full validity.