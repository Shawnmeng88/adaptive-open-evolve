# Prompt Type: B
# Outer Iteration: 1
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 1
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 3644 chars
- Current best prompt length: 4135 chars

## Convergence History:
### Successful Patterns:
- Explicit constraint mentions helped
- Negative guidance (what to avoid) helped

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9488
- Valid: 5, Invalid: 1
- Failure modes: ['Validity failures: 1/6 (16.7%)']

## CODE ANALYSIS (What Actually Happened):
## Code Analysis from Recent Iterations

*Analysis performed by LLM*

### Approaches Tried:
  - **structured_ring_placement** (1 attempts, worked)
    Places a central circle and two concentric rings of fixed radii, then clips the centers to stay within the unit square.
  - **grid_plus_lp** (1 attempts, worked)
    Generates a 5×5 grid of centers plus one extra point, then solves a linear program that maximises the sum of radii subject to non‑overlap and border constraints.
  - **hexagonal_lattice_plus_lp** (1 attempts, struggled)
    Creates a hexagonal lattice of centers and attempts to compute optimal radii via LP, but fails due to mismatched array shapes.

### Best Result (score: 0.9488):
  **Main Idea:** Use a dense, evenly spaced grid of circle centres and solve a linear program to allocate the largest possible radii while respecting pairwise and border constraints.
  **Placement:** A 5×5 grid of points at coordinates (0.1,0.3,0.5,0.7,0.9) plus one additional centre at (0.5,0.2).
  **Radius:** Linear programming with variables r_i, constraints r_i + r_j ≤ distance(i,j) for all pairs, r_i ≤ distance to each square side, and r_i ≥ 0. The objective is to maximise Σ r_i.
  **Constraints:** Border distances are pre‑computed; pairwise distances form the inequality matrix. The LP solver enforces all constraints simultaneously, guaranteeing a valid packing.

### Score Improvements:
  - Iter 1: +0.5846 - Replaced the ring pattern with a dense grid and introduced a full LP formulation, dramatically increasing the sum of radii.

### Stuck Patterns (AVOID THESE):
  - Pattern 1: Incomplete or syntactically broken code (e.g., missing closing parenthesis) that prevents the function from executing.
  - Pattern 2: Mismatched array shapes when building the LP matrices, leading to runtime errors such as "Invalid shapes".

### Novel Discoveries:
  - Combining a structured grid of centres with a linear‑programming radius optimisation is an effective strategy for this problem.

### Error Patterns:
  - Invalid shapes: 1 occurrences
    Likely cause: Attempting to stack arrays of different lengths or constructing a constraint matrix with inconsistent dimensions.

### Convergence Analysis:
  - Trend: improving then declining
  - Best Score: 0.9488
  - Iterations Since Improvement: 1
  - Approach Diversity: high

### Recommendations:
  - Continue refining the grid‑plus‑LP approach: increase grid resolution or add a few random perturbations to the centres to escape local optima.
  - Develop a hybrid method that starts from the hexagonal lattice but applies a local search (e.g., simulated annealing) to adjust positions before solving the LP.
  - Experiment with quadratic programming to maximise the sum of squared radii or the total area, which may yield tighter packings while still respecting constraints.


# ============================================
# FINAL REFINED PROMPT (seed_prompt_1):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**IMPORTANT OUTPUT INSTRUCTION**  
- Your response must contain **only** the Python code that belongs between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- Do **not** include the markers themselves, and do **not** include any calls to `run_packing()` or `visualize()`.  
- The surrounding framework will automatically add those calls, so they must be omitted here.  
- Every function that your code references must be fully defined inside this block; missing definitions will cause a runtime error.  

**ALGORITHMIC GUIDELINES FOR MAXIMIZING THE PACKING SCORE**  

1. **Dense Grid + Global Linear Programming**  
   - Generate a regular grid of candidate circle centers inside the unit square (e.g., a 5 × 5 lattice at coordinates 0.1, 0.3, 0.5, 0.7, 0.9).  
   - Optionally add a few extra points (e.g., one near the bottom middle) to increase the number of circles to the required count.  
   - Formulate a linear program with one variable per circle representing its radius.  
   - Include constraints:  
     * For every pair of circles, `r_i + r_j ≤ distance(i, j)`.  
     * For each circle, `r_i ≤ distance from its center to each side of the unit square`.  
     * `r_i ≥ 0`.  
   - Maximize the sum of all radii (or the sum of radii weighted by any hidden metric).  
   - Solve with `scipy.optimize.linprog` using the “highs” method for speed and reliability.  

2. **Refinement via Perturbation**  
   - After obtaining an LP solution, slightly perturb the center coordinates (e.g., add a small random offset within ±0.02) and re‑solve the LP.  
   - Keep the best result across a modest number of random trials (3‑5). This helps escape grid‑induced bottlenecks without breaking feasibility.  

3. **Hybrid Hexagonal Lattice + Local Search (optional)**  
   - Create a hexagonal/triangular lattice of points that naturally yields high packing density.  
   - If the lattice does not provide enough points, drop a few points and replace them with random positions.  
   - Apply a simple local optimization: for each circle, adjust its center by a tiny step in the direction that would increase its feasible radius (computed from current neighbor distances and border distances).  
   - After a few iterations, run the same LP radius optimisation on the updated centers.  

4. **Numerical Stability & Shape Consistency**  
   - Ensure all constraint matrices have matching dimensions: the number of inequality rows must equal the total number of pairwise and border constraints, and each row must have the same length as the number of radius variables.  
   - Use vectorised NumPy operations to build the distance matrix and constraint vectors; avoid Python loops that may produce shape mismatches.  
   - Verify that the LP coefficient matrix (`A_ub`) is a 2‑D NumPy array and that the right‑hand side (`b_ub`) is a 1‑D array of matching length.  

**COMMON PITFALLS TO AVOID**  

- **Syntax errors** such as missing parentheses, commas, or mismatched brackets—these prevent the function from loading.  
- **Incorrect array shapes** when constructing `A_ub` or `b_ub`; mismatched dimensions raise runtime exceptions.  
- **Omitting required function definitions** (e.g., helpers for distance computation or perturbation). Every called routine must be present in the block.  
- **Using more circles than allowed** or placing centers outside the unit square; both invalidate the solution.  
- **Neglecting the border constraints**; without them circles may extend beyond the square, causing the validity flag to drop to 0.  

**IMPLEMENTATION NOTES**  

- You may import additional standard libraries (e.g., `itertools`, `random`) inside the block if needed.  
- `numpy as np` and `scipy.optimize.linprog` are already available; you do not need to re‑import them unless you prefer an explicit import for clarity.  
- Keep the overall structure simple and readable; complex heuristics are unnecessary if the grid + LP core works correctly.  

Follow these guidelines to produce a valid, high‑scoring circle‑packing implementation.
