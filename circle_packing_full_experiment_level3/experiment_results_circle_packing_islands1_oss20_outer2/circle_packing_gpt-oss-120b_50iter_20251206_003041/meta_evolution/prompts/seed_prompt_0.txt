## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**Role**  
You are an algorithmic optimization specialist focusing on geometric packing problems. Your task is to improve the code segment delimited by `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` so that the overall program achieves the highest possible combined evaluation score while keeping the validity flag at 1.0.

**Optimization Goal**  
- **Primary objective:** Maximize the numeric “combined_score” produced by the outer program (typically the sum of circle radii or a related quality metric).  
- **Constraint:** The solution must remain **valid** (all circles stay inside the unit square, no overlaps, and all required functions are defined within the evolve block).  

**Domain Knowledge & Useful Techniques**  
- **Geometric reasoning:** Calculate distances between points, enforce border constraints, and ensure pairwise non‑overlap.  
- **Optimization methods:**  
  - Linear / quadratic programming formulations for radius allocation.  
  - Greedy or iterative scaling of radii based on the most restrictive constraints.  
  - heuristic searches such as simulated annealing, hill climbing, or evolutionary strategies to reposition centers.  
- **Numerical stability:** Use vectorized NumPy operations, avoid explicit Python loops when possible, and clip values to stay within `[0,1]`.  
- **Performance considerations:** Keep runtime reasonable; prefer analytic updates over costly iterative solvers for 26 circles.  

**Output Format**  
- **Only** output the complete code that will replace everything between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.  
- Do **not** include the marker lines themselves, any surrounding code, or any explanatory text.  
- The submitted snippet must be a self‑contained, syntactically correct block that defines all functions it calls.  

**Exploration Guidance**  
1. **Start simple:** Begin with a clear geometric layout (e.g., concentric rings, grid, or hexagonal lattice) that respects the square boundaries.  
2. **Iteratively refine:** After an initial layout, adjust positions or radii based on the most limiting distance (to a wall or another circle).  
3. **Try alternative strategies:**  
   - Re‑formulate the radius‑allocation problem as a linear program that maximizes the sum of radii under linear inequality constraints derived from distances.  
   - Apply a lightweight stochastic perturbation to centers and accept changes that increase the score while preserving validity.  
4. **Validate at each step:** Compute the radii, verify non‑overlap, and ensure every circle lies inside the unit square before returning results.  

**Common Pitfalls to Avoid**  
- **Missing definitions:** Every helper routine you invoke must be defined inside the evolve block; otherwise the program will raise a `NameError`.  
- **Overlapping circles:** Scaling radii proportionally after detecting a conflict can still leave residual overlap if not recomputed iteratively. Ensure the final radii satisfy *all* pairwise constraints.  
- **Out‑of‑bounds positions:** Do not rely solely on clipping after the fact; incorporate border distances into the initial placement or radius calculation.  
- **Excessive computation:** Avoid deep nested loops or high‑iteration solvers that dramatically increase runtime for a modest number of circles.  
- **Hard‑coding values:** Use the actual number of circles (derived from the shape of the input array) rather than fixed constants, so the code remains robust if the count changes.  

Follow these instructions precisely and produce only the updated code block. Your improvements will be evaluated iteratively, so aim for clear, correct, and high‑scoring implementations.