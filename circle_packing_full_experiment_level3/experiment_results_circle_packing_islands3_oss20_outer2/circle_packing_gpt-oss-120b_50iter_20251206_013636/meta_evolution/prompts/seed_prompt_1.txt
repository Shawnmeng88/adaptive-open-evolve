## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**SYSTEM MESSAGE**

You are to generate **only** the Python code that will replace the section between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  

- **Do not** output the markers themselves.  
- **Do not** include any calls to `run_packing()` or `visualize()` – those are inserted automatically elsewhere.  
- The code you provide must be a self‑contained block: every function, class, or variable that your code references must be defined **within** this block (or be a standard library / pre‑imported module such as `numpy as np` and `scipy.optimize.linprog`).  
- You may add additional `import` statements if needed, but keep them concise.

### What has worked well in previous successful attempts
- **Explicit geometric constraints**: formulate non‑overlap and boundary conditions as linear or quadratic inequalities and enforce them directly in the optimization model.  
- **Greedy refinement**: start from a dense set of candidate points (e.g., a fine grid or hexagonal lattice) and iteratively select points that allow the largest feasible radius, updating the constraints after each selection.  
- **Linear‑programming relaxation**: treat the radii as variables and maximize their sum (or another aggregate metric) subject to linearized distance constraints; this gives a fast, globally‑aware baseline that can be tightened later.  
- **Local improvement**: after an initial feasible packing, apply small perturbations to centers and re‑optimize radii locally (e.g., using `scipy.optimize.minimize` with bounds) to squeeze extra radius out of tight spots.  
- **Symmetry exploitation**: for 26 circles in a unit square, arranging points in a near‑hexagonal lattice or using concentric rings often yields high total radii while keeping constraints simple.

### What to avoid (common failure modes)
- **Omitting constraint definitions**: any missing non‑overlap or boundary condition will produce invalid packings and cause a “validity failure”.  
- **Using only heuristic placement without verification**: purely visual or random placement without a subsequent feasibility check leads to overlaps or circles exiting the square.  
- **Calling undefined helpers**: every function you invoke must be defined in the block; otherwise a `NameError` will abort execution.  
- **Overly complex models**: excessively large nonlinear programs can exceed time limits or converge to infeasible solutions; prefer linear or convex formulations when possible.  
- **Hard‑coding coordinates**: static positions that do not adapt to the optimization constraints often cannot achieve the best score and may violate constraints for different numbers of circles.

### Your task
Implement an improved construction strategy that:

1. Generates an initial set of candidate positions using a dense, regular pattern (e.g., hexagonal lattice or fine grid) confined to the unit square.  
2. Formulates a linear program (or convex quadratic program) that maximizes the sum of radii (or another aggregate metric) while enforcing:
   - For every selected center, the radius must keep the circle fully inside the square.
   - For every pair of selected centers, the sum of their radii must not exceed the Euclidean distance between the centers.
3. Solves the program to obtain feasible radii for the chosen centers.  
4. Optionally refines the solution with a short local optimization that perturbs centers and re‑optimizes radii, always respecting the same constraints.  
5. Returns the final arrays (or lists) of center coordinates and corresponding radii.

All helper functions you need for generating candidates, building the constraint matrices, solving the optimization, and performing local refinement must be defined inside the block you output. Keep the code clear, efficient, and fully self‑contained.