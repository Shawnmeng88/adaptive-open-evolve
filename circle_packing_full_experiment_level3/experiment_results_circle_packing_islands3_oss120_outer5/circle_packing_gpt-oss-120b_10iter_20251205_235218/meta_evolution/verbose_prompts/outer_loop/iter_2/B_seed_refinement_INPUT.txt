# Prompt Type: B
# Outer Iteration: 2
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 2
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 5817 chars
- Current best prompt length: 4701 chars

## Convergence History:
### Successful Patterns:
- Change that helped: expanded by 139 chars
- Negative guidance (what to avoid) helped
- Explicit constraint mentions helped

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9000
- Valid: 3, Invalid: 0
- Failure modes: []

## CODE ANALYSIS (What Actually Happened):
## Code Analysis from Recent Iterations

*Analysis performed by LLM*

### Approaches Tried:
  - **manual_ring_pattern** (1 attempts, struggled)
    Hard‑coded placement of one large circle at the centre and eight smaller circles arranged in a simple ring.
  - **hexagonal_lattice_with_lp** (1 attempts, mixed)
    Initial placement on a hexagonal lattice followed by a linear‑programming step that maximises the sum of radii for the fixed centres.
  - **hill_climbing_with_lp** (1 attempts, mixed)
    Iterative centre perturbations (hill‑climbing) where each perturbation is accepted only if a subsequent LP still yields a feasible, higher‑radius solution.

### Best Result (score: 0.9):
  **Main Idea:** Start from a dense hexagonal lattice, then repeatedly adjust circle centres with a hill‑climbing loop while re‑optimising radii via linear programming at every step.
  **Placement:** Centres are initially placed on a regular hexagonal grid inside the unit square; during hill‑climbing each centre is perturbed by a small random vector and the move is accepted only if it improves the LP objective.
  **Radius:** For any fixed set of centres, a linear program maximises the sum of radii subject to non‑overlap constraints (distance between centres ≥ sum of radii) and boundary constraints (each radius ≤ distance to the square edges).
  **Constraints:** All feasibility constraints are encoded in the LP; the hill‑climbing loop only accepts centre moves that keep the LP feasible, ensuring validity at every iteration.

### Score Improvements:
  - Iter 1: +0.5238 - Introduced LP‑based radius optimisation on a hexagonal lattice.
  - Iter 3: +0.012 - Added a hill‑climbing loop that perturbs centres and re‑optimises radii.

### Stuck Patterns (AVOID THESE):
  - Early manual patterns quickly hit infeasible or low‑score configurations because they lack any optimisation of radii or centre positions.
  - After the LP step, further improvements plateaued because the centre positions were not being updated, leading to a local optimum that could not be escaped without a search over centres.

### Novel Discoveries:
  - Using linear programming to solve for the optimal radii given fixed centres is an elegant way to enforce all non‑overlap and boundary constraints simultaneously.
  - Combining a simple hill‑climbing perturbation of centres with LP re‑optimisation allows the algorithm to escape local optima that would trap a pure LP approach.

### Error Patterns:
  - SyntaxError_incomplete_code: 2 occurrences
    Likely cause: Code snippets were truncated during extraction, leaving unfinished statements and missing brackets.

### Convergence Analysis:
  - Trend: improving then plateauing
  - Best Score: 0.9
  - Approach Diversity: medium

### Recommendations:
  - Introduce a simulated‑annealing or random‑restart strategy for centre perturbations to explore a broader region of the search space and avoid premature convergence.
  - Replace the simple hill‑climbing with a gradient‑based or quasi‑Newton method that jointly optimises centres and radii, potentially accelerating convergence to higher scores.
  - Add a diversity‑maintaining mechanism (e.g., crowding or niching) so that multiple distinct packing configurations are explored in parallel, increasing the chance of discovering superior solutions.


# ============================================
# FINAL REFINED PROMPT (seed_prompt_2):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**SYSTEM MESSAGE – EVOLUTION BLOCK GUIDELINES**

**OUTPUT REQUIREMENTS (CRITICAL)**  
- **Only** output the Python code that belongs **between** the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- **Do NOT** include the markers themselves, nor any surrounding code such as `run_packing()` or `visualize()`.  
- The surrounding script will automatically insert your code in the correct place.  

**FUNCTION DEFINITION RULE**  
- Every function that your code calls **must be defined inside this block**.  
- Do not rely on helper functions that exist elsewhere unless they are already part of the immutable outer code.  

**ALGORITHMIC APPROACH THAT HAS PROVEN EFFECTIVE**  
1. **Initial Placement** – Generate a dense set of points using a regular hexagonal (triangular) lattice confined to the unit square. This provides a good starting configuration with many circles already close to the theoretical maximum density.  
2. **Radius Optimisation via Linear Programming** – For any fixed set of centres, formulate a linear program that maximises the sum (or another monotone aggregate) of the radii subject to:  
   - Non‑overlap constraints: `distance(i, j) ≥ r_i + r_j` for every pair of circles.  
   - Boundary constraints: `r_i ≤ min(x_i, 1‑x_i, y_i, 1‑y_i)`.  
   Solving this LP yields the optimal radii for the current centre layout and guarantees feasibility.  
3. **Iterative Centre Perturbation (Hill‑Climbing / Simulated‑Annealing)** – Repeatedly propose small random displacements for a randomly chosen centre. After each proposal, re‑solve the LP. Accept the move only if the LP remains feasible **and** the objective improves (or, for simulated‑annealing, if a temperature‑scaled probability condition is satisfied). This allows the configuration to escape local optima while always maintaining a valid packing.  
4. **Exploration Enhancements** – To avoid premature convergence:  
   - Occasionally perform a **random‑restart** by re‑initialising a subset of centres to new lattice positions.  
   - Optionally run multiple independent searches in parallel and keep the best result.  
   - A simple **annealing schedule** (gradually reducing the perturbation magnitude) can improve final quality.  

**WHAT TO AVOID (FAILED APPROACHES)**  
- Hard‑coding a small manual pattern (e.g., a single central circle with a fixed ring of others). This limits the search space and quickly leads to infeasible or low‑score packings.  
- Leaving code fragments incomplete (missing brackets, unfinished statements). Such syntax errors halt execution before any optimisation can occur.  
- Relying solely on the LP step without updating centre positions; this plateaus at a local optimum because the geometry cannot improve.  

**IMPLEMENTATION NOTES**  
- You may import additional standard libraries (e.g., `random`, `math`) inside the block if needed.  
- `numpy` (as `np`) and `scipy.optimize.linprog` are already available; you can use them directly.  
- Keep the overall structure simple: a function that builds the initial lattice, a helper that runs the LP, and a loop that performs the centre‑perturbation search. Ensure each helper is fully defined in this block.  

**REMINDER**  
All code you provide will replace the mutable portion of the script. Follow the output format strictly and define every referenced function within the block to guarantee a runnable solution.
