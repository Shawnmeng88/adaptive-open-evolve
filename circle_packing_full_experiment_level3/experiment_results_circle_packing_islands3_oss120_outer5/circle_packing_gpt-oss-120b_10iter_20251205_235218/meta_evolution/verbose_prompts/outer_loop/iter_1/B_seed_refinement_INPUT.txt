# Prompt Type: B
# Outer Iteration: 1
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 1
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 5033 chars
- Current best prompt length: 4562 chars

## Convergence History:
### Successful Patterns:
- Negative guidance (what to avoid) helped
- Explicit constraint mentions helped

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.8880
- Valid: 3, Invalid: 0
- Failure modes: []

## CODE ANALYSIS (What Actually Happened):
## Code Analysis from Recent Iterations

*Analysis performed by LLM*

### Approaches Tried:
  - **Structured ring placement** (1 attempts, struggled)
    Places a single large circle at the center and eight smaller circles in a symmetric ring around it, with radii chosen manually or via a simple heuristic.
  - **Hexagonal lattice + LP radius optimization** (1 attempts, worked)
    Starts from a hexagonal lattice of fixed centers, then solves a linear program to maximize the sum of radii while respecting non‑overlap and boundary constraints.
  - **Randomized initial centers + LP refinement** (1 attempts, mixed)
    Randomly samples circle centers (using a fixed RNG seed) and then applies the same LP radius‑optimization step to improve packing quality.

### Best Result (score: 0.888):
  **Main Idea:** The algorithm uses a dense hexagonal lattice as a scaffold, then refines the radii of each circle by solving a linear program that maximizes the total radius sum subject to non‑overlap and boundary constraints. This hybrid of geometric placement and LP optimization yields a high‑quality packing.
  **Placement:** Centers are placed on a regular hexagonal grid that fits inside the unit square, with slight perturbations to avoid perfect symmetry.
  **Radius:** For the fixed grid of centers, an LP is solved where the objective is to maximize the sum of radii, with constraints ensuring that the distance between any two centers exceeds the sum of their radii and that each circle stays within the unit square.
  **Constraints:** Non‑overlap constraints are encoded as linear inequalities in the LP, and boundary constraints are enforced by limiting each radius to be less than the minimum distance from its center to the square edges.

### Score Improvements:
  - Iter 1: +0.5238 - Switched from a naive ring pattern to a hexagonal lattice with LP‑based radius optimization, drastically increasing the total radius sum.

### Stuck Patterns (AVOID THESE):
  - Pattern 1: Early solutions that rely on highly symmetric, manually‑crafted arrangements (e.g., a single central circle with a ring) get stuck at low scores because they cannot exploit the full packing capacity of the square.
  - Pattern 2: Random initializations that are not coupled with a strong optimization step often end up with many overlapping circles or radii that are too small, leading to repeated failures to satisfy validity constraints.

### Novel Discoveries:
  - Using linear programming to optimize radii for a fixed set of centers is an elegant way to decouple placement from sizing, allowing the algorithm to focus on geometric feasibility while still maximizing the objective.

### Error Patterns:
  - SyntaxError: 2 occurrences
    Likely cause: Code snippets were truncated mid‑statement, causing incomplete function definitions and missing parentheses.
  - Incomplete function definition: 2 occurrences
    Likely cause: The source files were cut off before the full implementation of helper functions (e.g., the LP constraint matrix) was provided.

### Convergence Analysis:
  - Trend: improving
  - Best Score: 0.888
  - Approach Diversity: medium-high

### Recommendations:
  - Recommendation 1: Combine the hexagonal lattice with a simulated‑annealing or particle‑swarm step that perturbs center positions while re‑optimizing radii via LP, to escape local optima and explore more diverse packings.
  - Recommendation 2: Introduce a multi‑objective framework that balances total radius sum with the minimal radius, encouraging more uniform circle sizes and potentially improving overall feasibility.
  - Recommendation 3: Implement a hierarchical refinement: start with a coarse grid, solve the LP, then iteratively split the largest gaps by adding new centers and re‑optimizing, which can systematically increase packing density.


# ============================================
# FINAL REFINED PROMPT (seed_prompt_1):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**SYSTEM MESSAGE – EVOLUTION BLOCK GUIDELINES**

- **Output Requirement**  
  - Produce **only** the Python code that belongs between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
  - Do **not** include the markers themselves, and do **not** include any surrounding code such as `run_packing()` or `visualize()`.  
  - The surrounding script will automatically insert your code in the correct place.

- **Function Completeness**  
  - Every function that your code calls must be defined **within** the provided block.  
  - Do not rely on helper functions that are defined elsewhere unless they are already part of the immutable outer code.

- **Allowed Imports**  
  - You may add additional import statements (e.g., `from scipy.optimize import linprog`, `import random`) if needed.  
  - `numpy as np` and `scipy.optimize.linprog` are already available.

- **Focus of the Evolution**  
  - Concentrate on improving the routine that generates the circle‑packing configuration and any supporting utilities.  
  - You may introduce new helper routines, data structures, or optimization steps, but keep the overall interface compatible with the surrounding script.

- **Proven Successful Strategies** *(do not name specific functions)*  
  1. **Hexagonal lattice scaffold** – Place centers on a dense hexagonal grid that fits inside the unit square, optionally adding small random perturbations to break perfect symmetry.  
  2. **Linear‑programming radius optimization** – With centers fixed, formulate a linear program that maximizes the sum of radii while enforcing:  
     - each radius ≤ distance from its center to the nearest square edge, and  
     - for every pair of centers, radius_i + radius_j ≤ Euclidean distance between the two centers.  
     Solving this LP yields the largest feasible radii for the given layout.  
  3. **Iterative refinement** – After an initial LP solution, optionally adjust center positions slightly (e.g., via a few steps of simulated‑annealing or gradient‑free perturbations) and resolve the LP. Repeating this loop can escape local optima and increase the total radius sum.  
  4. **Hierarchical gap filling** – Identify the largest uncovered region after an LP pass, insert a new center there, and re‑optimize. Repeating a small number of times can boost density without over‑complicating the problem.

- **What to Avoid**  
  - **Purely symmetric manual patterns** (e.g., a single central circle with rings) – they quickly hit low density limits.  
  - **Random center placement without a subsequent optimization step** – leads to many overlaps or very small feasible radii.  
  - **Incomplete code fragments** – ensure all statements are closed, all functions are fully defined, and no syntax errors remain.  
  - **Over‑complicating the LP** – keep the constraint matrix linear; do not introduce non‑linear expressions inside the linear program.

- **Implementation Tips**  
  - Compute the distance from each center to the four square edges once, and use the minimum as the upper bound for its radius.  
  - Build the LP constraint matrix efficiently: for *n* circles you need `n` boundary constraints and `n*(n-1)/2` pairwise non‑overlap constraints.  
  - Use `linprog` with the `'highs'` method for speed and reliability.  
  - After solving, clip any negative radii to zero (they indicate infeasibility for that layout) and discard or re‑seed those circles.  
  - When performing perturbations, keep movements small enough to stay inside the unit square and to preserve feasibility of the next LP solve.

- **Goal**  
  - Maximize the combined quality metric (e.g., total sum of radii or packing density) while maintaining perfect validity (no overlaps, all circles fully inside the unit square).  

Follow these guidelines precisely, and ensure the submitted block is syntactically complete and self‑contained.
