# Prompt Type: C
# Outer Iteration: 0
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are an expert in algorithmic geometry and numerical optimization, tasked with evolving the code inside the designated **evolve block** to achieve the highest possible combined score while keeping the solution valid (validity = 1.0).

**Optimization goal**  
- Maximize the metric that aggregates the quality of the circle‑packing solution (e.g., sum of radii, packing density, or any provided combined_score).  
- Ensure every generated arrangement satisfies all geometric constraints (circles stay inside the unit square and do not overlap) so that the validity flag remains perfect.

**Relevant techniques and ideas**  
- Analytic placement patterns (hexagonal/triangular lattices, concentric rings, staggered grids) that are known to be dense in a square.  
- Iterative refinement: start from a simple pattern, then adjust positions and radii using local optimization (gradient‑free search, simulated annealing, particle swarm, simple hill‑climbing) within the block.  
- Constraint handling: compute the maximal admissible radius for each center by taking the minimum of distances to the square borders and half the pairwise distances to other centers; enforce these limits after any move.  
- Linear or quadratic programming formulations can be employed to maximize the sum of radii under linearized non‑overlap constraints.  
- Use vectorized NumPy operations for speed; avoid Python loops where possible.  
- Consider scaling or rotating the whole configuration to better fit the square.  
- Randomized restarts or multi‑stage strategies (coarse placement → fine‑tune) often improve the final score.

**Output format**  
- **Only** output the code that belongs between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- Do **not** include the marker lines themselves, any surrounding code, or any explanatory text.  
- The submitted snippet must be a self‑contained replacement for the original block; all functions, imports, and variables used inside must be defined within this snippet.  
- Do **not** reference or name any specific functions that already exist outside the block; describe actions abstractly (e.g., “define a helper that computes maximal radii”, “implement an optimizer that updates positions”).

**Guidance for exploration**  
1. Begin with a well‑structured geometric layout that is known to be dense.  
2. Add a deterministic or stochastic improvement loop that repeatedly adjusts centers and recomputes admissible radii, stopping after a fixed number of iterations or when improvement stalls.  
3. If using an optimizer, formulate the objective (maximize total radii) and constraints (non‑overlap, border limits) clearly; solve it with a suitable method from `scipy.optimize` or a custom routine.  
4. Experiment with different numbers of inner iterations, step sizes, or random seeds across successive generations to discover better configurations.  
5. Keep the code concise and computationally efficient to allow many iterations within the evaluation time limit.

**Common pitfalls to avoid**  
- Forgetting to enforce the border constraints after each position update, which leads to invalid solutions.  
- Allowing radii to become negative or zero; always clamp to a small positive lower bound.  
- Introducing external dependencies that are not pre‑installed; limit yourself to the standard library, NumPy, and SciPy.  
- Referencing or calling functions that are defined outside the evolve block; every used routine must be defined inside the block.  
- Outputting any text, comments outside the code block, or the marker lines themselves.  

Follow these instructions carefully to produce a valid, high‑scoring implementation that will be automatically inserted between the markers.