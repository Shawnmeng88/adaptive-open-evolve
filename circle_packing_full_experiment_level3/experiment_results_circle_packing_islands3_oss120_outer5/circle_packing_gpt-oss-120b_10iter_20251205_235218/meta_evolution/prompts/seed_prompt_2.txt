## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**SYSTEM MESSAGE – EVOLUTION BLOCK GUIDELINES**

**OUTPUT REQUIREMENTS (CRITICAL)**  
- **Only** output the Python code that belongs **between** the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- **Do NOT** include the markers themselves, nor any surrounding code such as `run_packing()` or `visualize()`.  
- The surrounding script will automatically insert your code in the correct place.  

**FUNCTION DEFINITION RULE**  
- Every function that your code calls **must be defined inside this block**.  
- Do not rely on helper functions that exist elsewhere unless they are already part of the immutable outer code.  

**ALGORITHMIC APPROACH THAT HAS PROVEN EFFECTIVE**  
1. **Initial Placement** – Generate a dense set of points using a regular hexagonal (triangular) lattice confined to the unit square. This provides a good starting configuration with many circles already close to the theoretical maximum density.  
2. **Radius Optimisation via Linear Programming** – For any fixed set of centres, formulate a linear program that maximises the sum (or another monotone aggregate) of the radii subject to:  
   - Non‑overlap constraints: `distance(i, j) ≥ r_i + r_j` for every pair of circles.  
   - Boundary constraints: `r_i ≤ min(x_i, 1‑x_i, y_i, 1‑y_i)`.  
   Solving this LP yields the optimal radii for the current centre layout and guarantees feasibility.  
3. **Iterative Centre Perturbation (Hill‑Climbing / Simulated‑Annealing)** – Repeatedly propose small random displacements for a randomly chosen centre. After each proposal, re‑solve the LP. Accept the move only if the LP remains feasible **and** the objective improves (or, for simulated‑annealing, if a temperature‑scaled probability condition is satisfied). This allows the configuration to escape local optima while always maintaining a valid packing.  
4. **Exploration Enhancements** – To avoid premature convergence:  
   - Occasionally perform a **random‑restart** by re‑initialising a subset of centres to new lattice positions.  
   - Optionally run multiple independent searches in parallel and keep the best result.  
   - A simple **annealing schedule** (gradually reducing the perturbation magnitude) can improve final quality.  

**WHAT TO AVOID (FAILED APPROACHES)**  
- Hard‑coding a small manual pattern (e.g., a single central circle with a fixed ring of others). This limits the search space and quickly leads to infeasible or low‑score packings.  
- Leaving code fragments incomplete (missing brackets, unfinished statements). Such syntax errors halt execution before any optimisation can occur.  
- Relying solely on the LP step without updating centre positions; this plateaus at a local optimum because the geometry cannot improve.  

**IMPLEMENTATION NOTES**  
- You may import additional standard libraries (e.g., `random`, `math`) inside the block if needed.  
- `numpy` (as `np`) and `scipy.optimize.linprog` are already available; you can use them directly.  
- Keep the overall structure simple: a function that builds the initial lattice, a helper that runs the LP, and a loop that performs the centre‑perturbation search. Ensure each helper is fully defined in this block.  

**REMINDER**  
All code you provide will replace the mutable portion of the script. Follow the output format strictly and define every referenced function within the block to guarantee a runnable solution.