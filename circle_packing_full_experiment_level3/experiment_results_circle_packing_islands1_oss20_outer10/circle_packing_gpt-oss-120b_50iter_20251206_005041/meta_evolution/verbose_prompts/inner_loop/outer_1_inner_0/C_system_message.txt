# Prompt Type: C
# Outer Iteration: 1
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**SYSTEM MESSAGE – CODE EVOLUTION GUIDELINES**

You are to generate **only** the Python source that will replace the code placed between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- Do **not** output the markers themselves.  
- Do **not** include calls to `run_packing()` or `visualize()` – those are added automatically outside the block.  
- The resulting snippet must be a **complete, self‑contained** replacement: every routine that your code calls must be defined inside this block.

**IMPORTS**  
You may add any `import` statements you need (e.g., `from scipy.optimize import linprog`).  
`numpy` as `np` and `scipy.optimize.linprog` are already available, but you may import them again if you wish.

**FOCUS OF IMPROVEMENT**  
Your task is to construct a packing of **26 circles** inside the unit square that maximizes the evaluation metric (combined_score) while keeping the packing valid (all circles stay inside the square and never overlap).

**What has worked well (keep these ideas):**  
1. **Grid‑plus‑center layout** – place 25 centers on a regular 5 × 5 grid covering roughly the interval [0.1, 0.9] on both axes, and add a 26th center at the square’s centre (0.5, 0.5).  
2. **Linear‑program optimisation of radii** – for a *fixed* set of centers, formulate a linear program that maximises the sum of radii subject to:  
   - `r_i ≤ distance from center i to each side of the unit square` (four constraints per circle).  
   - `r_i + r_j ≤ Euclidean distance between centers i and j` for every unordered pair (i, j).  
   Solve this with `scipy.optimize.linprog`. The LP yields the largest feasible radii for the chosen positions.  
3. **Brief stochastic refinement** – after the LP, perform a short random‑search loop:  
   - Randomly perturb a single center by a small amount (e.g., uniform in [‑δ, δ] with δ≈0.02).  
   - Re‑solve the LP for the new positions.  
   - Keep the new configuration only if it remains feasible **and** improves the objective (larger total radius).  
   A few iterations (10‑30) are enough to break symmetry and gain a modest score boost.

**What to avoid (failed approaches):**  
- **Ring‑based deterministic placements** that assign radii beforehand and then clip circles to the square; without a subsequent LP the circles are far from optimal and often overlap.  
- **Any method that modifies radii without re‑checking all pairwise and boundary constraints** – this leads to invalid packings and a score of 0.  
- **Leaving any called helper routine undefined** – the outer system will raise a `NameError`.

**Implementation hints:**  
- Keep the grid generation simple (e.g., `np.linspace(0.1, 0.9, 5)` for both x and y).  
- Assemble the LP matrices (`A_ub`, `b_ub`, `c`) programmatically; remember that the objective is to **maximise** the sum of radii, so set `c = -np.ones(n)` because `linprog` performs minimisation.  
- Use the `'highs'` method for speed and reliability.  
- After each LP solve, verify feasibility (`res.success` and all constraints satisfied within a small tolerance).  
- Encapsulate the LP solving and the random‑search steps into clearly defined helper routines inside the block; call them only from the main construction routine.  

**Reminder:** Every function you invoke must be defined in the code you output. Ensure the block compiles on its own and adheres to the output‑format rules above.