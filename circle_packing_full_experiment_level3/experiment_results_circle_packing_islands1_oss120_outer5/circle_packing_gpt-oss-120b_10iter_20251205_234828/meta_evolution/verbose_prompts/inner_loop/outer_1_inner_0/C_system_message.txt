# Prompt Type: C
# Outer Iteration: 1
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)**  
- **OUTPUT ONLY** the Python code that belongs between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.  
- **DO NOT** include the markers themselves, any surrounding code, or calls such as `run_packing()` or `visualize()`.  
- The harness will automatically merge your snippet with the preserved surrounding code.  

**IMPORTS**  
- You may add additional import statements inside the block if needed (e.g., `from scipy.optimize import minimize`).  
- `numpy as np` and `scipy.optimize.linprog` are already available.  

**FOCUS**  
- Improve the construction of a 26‑circle packing inside the unit square.  
- You may add new helper routines, but **every function that you call must be defined within the block**.  

**ALGORITHMIC GUIDELINES**  

1. **Base placement strategy** – Use a dense, quasi‑regular layout such as a hexagonal (triangular) lattice.  
   - Arrange points in several rows; alternate rows are offset by half the horizontal spacing to obtain the hexagonal pattern.  
   - Choose a modest margin from the square edges (e.g., 0.02 – 0.03) so that the linear‑programming stage has room to enlarge radii without forcing them to zero.  

2. **Radius optimisation** – After fixing the centers, formulate a linear program that maximises the sum of radii subject to:  
   - Non‑overlap: for every pair *i, j*, `dist(i,j) ≥ r_i + r_j`.  
   - Boundary constraints: each radius must satisfy `r_i ≤ min(x_i, 1‑x_i, y_i, 1‑y_i)`.  
   - All radii are non‑negative.  

3. **Enhancement ideas** – To potentially exceed the current best score, consider one (or more) of the following after the LP step:  
   - **Small random perturbations** of the lattice points (e.g., add a uniform noise in `[-δ, δ]` with `δ≈0.01`) followed by a fresh LP solve; keep the best feasible outcome.  
   - **Local greedy refinement**: iterate over circles, temporarily increase a single radius while decreasing neighbours proportionally to maintain feasibility, accepting the change if the total sum grows.  
   - **Hybrid edge circles**: replace a few interior lattice points near the corners with circles placed closer to the corners, then re‑optimise radii.  

4. **Avoid** –  
   - Relying exclusively on concentric‑ring layouts; they waste space near the square borders and have shown limited improvement.  
   - Using an overly large fixed margin; it unnecessarily caps the achievable radii and reduces the objective.  
   - Omitting the definition of any helper routine you invoke; missing definitions cause `NameError` and abort the evaluation.  

**VALIDITY CHECKS**  
- After computing radii, verify that every circle lies completely inside the unit square (`0 ≤ x_i‑r_i` and `x_i+r_i ≤ 1`, similarly for *y*).  
- Confirm that for all pairs the distance between centers is at least the sum of their radii (allow a tiny tolerance like `1e-9`).  
- If any check fails, fall back to the last feasible solution obtained from the linear program.  

**OUTPUT INSTRUCTION (REPEAT)**  
- Produce **only** the Python code that will sit between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- Do **not** include the markers, surrounding harness code, or any explanatory text.  
- Ensure every referenced function or class is defined within the submitted snippet.