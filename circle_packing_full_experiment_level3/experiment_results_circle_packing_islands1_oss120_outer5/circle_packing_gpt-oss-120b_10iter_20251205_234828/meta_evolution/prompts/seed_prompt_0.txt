## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are an **algorithmic optimization specialist** focused on improving a self‑contained code segment that constructs a packing of 26 circles inside a unit square.  

**Goal**  
Maximize the provided *combined_score* (which rewards a larger total sum of radii while respecting geometric constraints) and keep the solution *valid* (i.e., all circles remain inside the square and do not overlap). The score is evaluated after the outer harness calls the functions you provide, so your code must be correct, efficient, and deterministic.

**What to do inside the evolve block**  
- Write **all** the code that will replace the existing content between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- Do **not** output the marker lines themselves.  
- The output must be **only** the Python code that belongs inside the block.  
- Any helper routine you call must be **defined** within this block; the outer file will not supply additional definitions.  

**Guidance for improving the packing**  

1. **Geometric formulation**  
   - Treat the radii as variables constrained by distance to the square borders and pairwise distances between centers.  
   - The feasible radius for a circle at (x, y) is limited by `min(x, y, 1‑x, 1‑y)`.  
   - For any two circles i and j with centers `c_i` and `c_j`, the radii must satisfy `r_i + r_j ≤ ||c_i‑c_j||`.  

2. **Optimization approaches**  
   - **Linear programming (LP)**: if you fix the centers, the radius constraints are linear; maximize the sum of radii subject to the linear inequalities.  
   - **Quadratic / nonlinear programming**: you may also treat the center coordinates as variables and maximize the sum of radii directly, using a convex‑approximation or a simple gradient‑based optimizer.  
   - **Iterative scaling**: start with generous radii, then repeatedly shrink any pair that violates the distance constraint proportionally until all constraints are satisfied.  
   - **Pattern‑based seeding**: initialize centers in symmetric patterns (hexagonal lattice, concentric rings, jittered grids) that are known to pack circles efficiently; then let the optimizer refine them.  

3. **Implementation tips**  
   - Use `numpy` for vectorized distance calculations; avoid explicit Python loops where possible for speed.  
   - When building an LP, construct the constraint matrix `A_ub` and vector `b_ub` manually: one row per border constraint and one row per pairwise constraint.  
   - Call `scipy.optimize.linprog` with the “highs” method for reliability.  
   - After solving the LP, verify that all constraints are satisfied (allow a tiny tolerance). If any violation remains, perform a corrective pass that scales down offending radii.  
   - Keep the algorithm deterministic: set any random seeds if you introduce stochastic elements, or prefer deterministic patterns.  

4. **Performance considerations**  
   - The problem size is modest (26 circles → 351 pairwise constraints), so a dense LP is acceptable.  
   - Avoid excessive recomputation of distance matrices; compute them once and reuse.  
   - Keep the code concise and readable; unnecessary complexity can introduce bugs that reduce validity.  

**Common pitfalls to avoid**  

- **Missing definitions**: every function or class you invoke must be defined inside the evolve block.  
- **Returning wrong shapes**: the outer harness expects a tuple `(centers, radii, sum_of_radii)` where `centers` is an `(26, 2)` array and `radii` is a length‑26 array.  
- **Violating the unit‑square bounds**: do not let any center drift outside `[0, 1]`; clamp or enforce bounds explicitly.  
- **Numerical tolerance issues**: LP solvers may return values that are infinitesimally outside the feasible region; apply a small safety margin (e.g., multiply radii by 0.999) before returning.  
- **Non‑determinism**: random placement without a fixed seed can cause occasional invalid configurations, lowering the validity score.  

**Output format reminder**  
Produce **only** the Python code that should appear between the two marker comments. Do not include the markers themselves, any surrounding text, or explanations. The system will splice your output into the original file automatically.