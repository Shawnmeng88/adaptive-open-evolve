## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**SYSTEM MESSAGE – EVOLUTION BLOCK GUIDELINES**

You must output **only** the Python code that will be placed between the markers  

```
# EVOLVE-BLOCK-START
...
# EVOLVE-BLOCK-END
```  

- **Do NOT include** the marker lines themselves.  
- **Do NOT include** calls such as `run_packing()` or `visualize()` – those are added automatically.  
- The harness will merge your snippet with the surrounding program, so your output must be a self‑contained replacement for the evolve block.

### IMPORTS  
You may add import statements if needed (e.g., `from scipy.optimize import minimize`).  
`numpy as np` and `scipy.optimize.linprog` are already available.

### FOCUS  
Improve the construction of the packing (the part that determines circle positions and radii).  
You may add new helper functions, but every function you call must be **fully defined** inside this block.

### SUCCESSFUL STRATEGIES TO BUILD ON  
- **Compact deterministic layout**: generate 26 points using a hexagonal‑like lattice (five rows with counts 5‑5‑5‑5‑6) inside the unit square, leaving a small margin (e.g., 0.02).  
- **Optional offset inversion**: allow the horizontal offset of odd rows to be flipped, providing a subtle shift that can better utilize boundary space.  
- **Linear‑programming radius optimization**: with the centers fixed, formulate a linear program that maximizes the sum of radii subject to:  
  * each radius ≤ distance from its center to the nearest square edge,  
  * for every pair of circles, the sum of their radii ≤ Euclidean distance between the two centers.  
  This guarantees non‑overlap and boundary compliance, yielding a validity of 1.0.  
- **Small stochastic perturbations**: after the deterministic layout, optionally add a tiny random displacement (e.g., ≤ 0.005) to each center before solving the LP. This can help escape local optima and explore alternative packings.

### WHAT TO AVOID (CAUSES OF FAILURE)  
- **Syntax errors**: missing or extra parentheses, brackets, or colons will prevent execution.  
- **Incomplete definitions**: a function header without a body, or a referenced helper that is not defined in this block, will raise `NameError`.  
- **Stagnant layout**: repeatedly using the exact same deterministic arrangement without any variation limits improvement.  
- **Over‑reliance on a single approach**: mixing deterministic placement with a modest random component is encouraged; pure deterministic or purely random searches have plateaued in past attempts.  
- **Invalid radius constraints**: ensure the LP constraints correctly enforce both non‑overlap and boundary limits; otherwise circles may intersect or leave the square, causing a validity drop.

### REMINDER  
Every function you invoke (including any new helpers you create) must be **fully defined** within the code you provide. Missing definitions will cause the program to fail.

### OUTPUT FORMAT (CRITICAL)  
- Output **exactly** the code that belongs inside the evolve block.  
- No extra text, comments outside the code, or marker lines.  
- Do **not** include `run_packing()` or `visualize()` – they are preserved automatically.  

Follow these guidelines carefully to produce a valid, high‑performing packing implementation.