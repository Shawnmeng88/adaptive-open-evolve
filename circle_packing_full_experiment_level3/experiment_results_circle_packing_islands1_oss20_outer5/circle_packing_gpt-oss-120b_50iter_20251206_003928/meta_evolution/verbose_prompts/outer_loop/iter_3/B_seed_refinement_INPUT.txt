# Prompt Type: B
# Outer Iteration: 3
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 3
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 4834 chars
- Current best prompt length: 5199 chars

## Convergence History:
### Successful Patterns:
- Negative guidance (what to avoid) helped
- Explicit constraint mentions helped
- Change that helped: added 'step'; expanded by 648 chars

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9488
- Valid: 8, Invalid: 2
- Failure modes: ['Validity failures: 2/10 (20.0%)']

## CODE ANALYSIS (What Actually Happened):
## Code Analysis from Recent Iterations

*Analysis performed by LLM*

### Approaches Tried:
  - **hex_grid_with_LP_and_local_refinement** (3 attempts, mixed)
    Generate a hexagonal lattice of points, select 26 of them, solve a linear program to maximize the sum of radii under border and non‑overlap constraints, then perform a short stochastic local search to perturb the centers and re‑solve the LP.
  - **grid_plus_extra_point_with_LP** (1 attempts, worked)
    Place 25 points on a 5×5 uniform grid, add one extra point, compute radii by solving the same LP, yielding a valid packing.
  - **fallback_radius_computation_without_LP** (1 attempts, worked)
    Compute radii purely from border distances and half the nearest‑neighbour distance, without solving an LP.

### Best Result (score: 0.9488):
  **Main Idea:** A hybrid approach that first constructs a dense hexagonal lattice, then optimizes radii with a linear program, and finally refines the layout with a brief stochastic perturbation loop.
  **Placement:** The centers are taken from a hexagonal lattice with spacing chosen by a coarse grid search. The 26 points farthest from the square borders are selected to maximise initial spacing.
  **Radius:** An LP (scipy.optimize.linprog, method='highs') maximizes the sum of radii subject to r_i ≤ distance to the nearest wall and r_i + r_j ≤ distance between centres i and j. If the LP fails, the algorithm falls back to the simple border‑limit radii.
  **Constraints:** All constraints are encoded in the LP; the local search only accepts proposals that keep the centers inside the unit square and re‑solves the LP to ensure validity. The fallback border limits guarantee a valid solution even if the LP is infeasible.

### Score Improvements:
  - Iter 5: +0.9256 - Introduced a full LP for radius optimisation and switched from a naive grid to a hexagonal lattice.
  - Iter 10: +-0.0006 - Minor code cleanup; no real improvement.
  - Iter 14: +0.0238 - Added a local stochastic refinement loop after the LP, and broadened the spacing search.

### Stuck Patterns (AVOID THESE):
  - Repeated failures due to missing helper functions (e.g., compute_max_radii, hex_grid, optimal_radii) causing NameErrors.
  - Array shape mismatches when building the LP constraint matrix, leading to "setting an array element with a sequence" errors.
  - Incomplete local search loops that reference undefined variables (e.g., 'propo' instead of 'proposal').

### Novel Discoveries:
  - Using a two‑stage optimisation: first a coarse lattice search to pick a good initial layout, then a fine‑tuned LP to adjust radii, and finally a stochastic perturbation to escape local optima.
  - Employing a fallback border‑limit radius computation to guarantee validity when the LP is infeasible.

### Error Patterns:
  - name 'compute_max_radii' is not defined: 3 occurrences
    Likely cause: The function was defined in a different code block but not imported or defined in the current module.
  - name 'hex_grid' is not defined: 2 occurrences
    Likely cause: The hex_grid helper was omitted or incorrectly named in the current file.
  - name 'optimal_radii' is not defined: 3 occurrences
    Likely cause: The LP helper was defined elsewhere but not available in the execution context.
  - setting an array element with a sequence: 1 occurrences
    Likely cause: Attempting to assign a list/array to a NumPy scalar position without proper reshaping.
  - name 'generate_hex_lattice' is not defined: 1 occurrences
    Likely cause: The function name was misspelled or omitted.

### Convergence Analysis:
  - Trend: improving until iteration 14, then plateauing/declining.
  - Best Score: 0.9488
  - Iterations Since Improvement: 13
  - Approach Diversity: high – multiple distinct strategies (hex grid, uniform grid, fallback radius, local search) were attempted.

### Recommendations:
  - Ensure that all helper functions (hex_grid, optimal_radii, compute_max_radii) are defined in the same module or explicitly imported; this will eliminate the frequent NameError failures.
  - Wrap the LP call in a robust try/except block and use the border‑limit fallback only when the LP fails; also log the LP status to diagnose infeasibility causes.
  - Add a simulated‑annealing or evolutionary component that perturbs all centers simultaneously, not just one at a time, and re‑solves the LP after each perturbation to explore a broader search space.


# ============================================
# FINAL REFINED PROMPT (seed_prompt_3):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**SYSTEM MESSAGE – CODE EVOLUTION GUIDELINES**

You are to supply **only** the Python source that belongs between the markers  

```
# EVOLVE-BLOCK-START
…your code…
# EVOLVE-BLOCK-END
```  

Do **not** output the markers themselves, and do **not** include `run_packing()` or `visualize()` – those sections are preserved automatically.  

All functions that your new code calls must be fully defined **within** the block you output. If you introduce helper routines, include their definitions here.

---

### OUTPUT FORMAT (CRITICAL)

- Output **only** the code that goes between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.
- Do **not** include the marker lines themselves.
- Do **not** include `run_packing()` or `visualize()` – they are added automatically.
- The system will merge your output with the surrounding preserved code.

---

### IMPORTS

- You may add additional import statements if required (e.g., `from scipy.optimize import linprog`), but `numpy as np` and `scipy.optimize.linprog` are already available.

---

### FOCUS

Improve the routine that constructs the packing of **26 circles** inside the unit square and any helper utilities it uses. You may replace or augment the existing implementation, but the final block must be self‑contained and executable.

---

### SUCCESSFUL STRATEGIES (DESCRIBED GENERICALLY)

1. **Dense lattice generation** – Create a set of candidate center points using a hexagonal (triangular) lattice pattern that fits inside the unit square. Choose a lattice spacing that yields at least 26 points and leaves reasonable clearance from the borders.

2. **Selection of promising points** – From the generated lattice, pick the 26 points that are farthest from the square edges (or that maximize the minimum pairwise distance). This gives a good initial layout with built‑in spacing.

3. **Linear‑programming radius optimisation** – Formulate a linear program that maximizes the sum of radii subject to:
   - each radius ≤ distance from its center to the nearest wall,
   - for every pair of circles, radius_i + radius_j ≤ distance between the two centers.
   Solve the LP with `scipy.optimize.linprog` (method “highs”).  
   - If the LP solves to optimality, use the obtained radii.  
   - If the LP is infeasible or fails, fall back to a simple deterministic radius calculation (e.g., half the minimum of the wall distance and the nearest‑neighbour distance).

4. **Brief stochastic refinement** – Perform a short loop (e.g., 200–500 iterations) that randomly perturbs a randomly chosen center by a small amount, re‑evaluates the LP, and accepts the change only if the LP remains feasible and the total radius sum improves. This helps escape local optima without excessive computation.

5. **Robust fallback** – Always keep the deterministic radius calculation as a safety net so that a valid packing is returned even when the LP cannot be solved.

---

### WHAT TO AVOID (COMMON FAILURE MODES)

- **Missing helper definitions** – Do not reference any routine that is not defined in the same block (e.g., lattice generators, radius calculators, LP wrappers). Every called function must have its full definition present.
- **Array‑shape mismatches** – When building the LP constraint matrix, ensure each row is a 1‑D numeric array of the correct length. Assigning a list of arrays or mismatched dimensions will raise “setting an array element with a sequence” errors.
- **Undefined variables** – Double‑check variable names inside loops (e.g., use `proposal` consistently, not a misspelled version). Typos cause `NameError`.
- **Uncaught LP failures** – Wrap the `linprog` call in `try/except` and inspect the returned status. Do not assume success; otherwise the subsequent radius usage may be invalid.
- **Leaving centers outside the unit square** – Any perturbation must be clamped or rejected if it moves a center beyond `[0,1]` in either coordinate.

---

### REMINDERS

- **Self‑containment** – The block you return must be a complete, runnable module fragment. All symbols referenced inside must be defined here.
- **Safety first** – Prioritize producing a valid packing over marginal score improvements. The fallback radius method guarantees validity.
- **Efficiency** – Keep the lattice generation and LP size modest (26 variables, ≤ 351 pairwise constraints) so that the solver runs quickly within the evaluation budget.

Follow these guidelines to craft a robust, high‑scoring `construct_packing` implementation and any supporting helpers. Good luck!
