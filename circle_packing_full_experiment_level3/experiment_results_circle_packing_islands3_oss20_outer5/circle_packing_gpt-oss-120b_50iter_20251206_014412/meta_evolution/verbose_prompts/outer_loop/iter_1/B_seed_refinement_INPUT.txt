# Prompt Type: B
# Outer Iteration: 1
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 1
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 6582 chars
- Current best prompt length: 3986 chars

## Convergence History:
### Successful Patterns:
- Negative guidance (what to avoid) helped
- Explicit constraint mentions helped

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9357
- Valid: 10, Invalid: 1
- Failure modes: ['Validity failures: 1/11 (9.1%)']

## CODE ANALYSIS (What Actually Happened):
## Code Analysis from Recent Iterations

*Analysis performed by LLM*

### Approaches Tried:
  - **deterministic_ring_pattern** (1 attempts, worked)
    Initial attempt places one large circle at the center, then two concentric rings of fixed radius offsets. Radii are later computed by a helper (not fully implemented).
  - **lp_radius_optimization_with_multiple_layouts** (1 attempts, worked)
    Centers are generated by a deterministic lattice and random placements. For each layout, a linear program maximises the sum of radii subject to wall and pairwise non‑overlap constraints.
  - **local_search_on_centers_with_lp_radii** (1 attempts, mixed)
    After an initial layout, the algorithm perturbs each center slightly and keeps the change if the LP‑computed sum of radii improves. This hill‑climbing step refines the packing.
  - **broadcasting_error_in_pairwise_constraints** (1 attempts, struggled)
    An attempt to vectorise pairwise distance constraints failed because the distance array had mismatched shape with the coefficient matrix.

### Best Result (score: 0.9357):
  **Main Idea:** Combine deterministic or random center initialization with a linear‑programming radius optimiser, then apply a simple local‑search hill‑climb on the centers to further increase the total radius sum.
  **Placement:** Centers are first placed on a regular lattice or sampled randomly within the unit square. The local search then perturbs each center by a small random offset.
  **Radius:** For a fixed set of centers, an LP is solved where the objective is to maximise the sum of radii. Constraints include: each radius ≤ distance to each side of the square, and for every pair i<j, r_i + r_j ≤ distance between centers i and j.
  **Constraints:** All constraints are encoded as linear inequalities in the LP. The LP solver (scipy.optimize.linprog) ensures feasibility; infeasible or unbounded solutions are discarded.

### Score Improvements:
  - Iter 1: +0.5011 - Introduced LP radius optimisation and tried multiple layouts (lattice + random) instead of a single deterministic ring.
  - Iter 9: +0.0704 - Added a local‑search perturbation of centers that keeps only improvements, refining the packing.

### Stuck Patterns (AVOID THESE):
  - Pattern 1: Broadcasting shape mismatch when building pairwise constraints, causing the program to crash at iteration 10.
  - Pattern 2: Incomplete helper functions (e.g., compute_max_radii) lead to syntax or runtime errors in earlier iterations.

### Novel Discoveries:
  - Using a linear program to compute optimal radii for any fixed set of centers, which decouples center placement from radius sizing.
  - A simple hill‑climbing local search that perturbs centers and accepts only improvements, effectively navigating the non‑convex center‑placement space.

### Error Patterns:
  - broadcasting_shape_mismatch: 1 occurrences
    Likely cause: Attempting to stack a 1‑D distance array with a 2‑D coefficient matrix without aligning dimensions.
  - undefined_helper_function: 1 occurrences
    Likely cause: Reference to compute_max_radii in Sample 1 without providing its implementation.

### Convergence Analysis:
  - Trend: improving until iteration 9, then stagnating/declining due to a bug.
  - Best Score: 0.9357
  - Iterations Since Improvement: 1
  - Approach Diversity: medium – all successful attempts use LP radius optimisation; only the local‑search variant differs.

### Recommendations:
  - Fix the broadcasting error by constructing the pairwise constraint matrix using vectorised operations (e.g., np.add.outer or broadcasting with np.newaxis) so that each row corresponds to a unique (i,j) pair.
  - Introduce a simulated‑annealing or gradient‑based optimiser for the centers to escape local optima that the simple hill‑climb may miss, while still using the LP for radii.
  - Add explicit bounds on radii in the LP (e.g., r_i ≥ 0) and enforce a small epsilon margin to avoid degenerate solutions that could cause numerical instability.


# ============================================
# FINAL REFINED PROMPT (seed_prompt_1):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Instructions for the Code‑Generation Model**

You are to produce **only** the Python source code that will be placed between the markers `# EVOLVE‑BLOCK‑START` and `# EVOLVE‑BLOCK‑END`.  
- Do **not** output the markers themselves.  
- Do **not** include calls to `run_packing()` or `visualize()` – those are added automatically.  
- Every function or variable referenced in your code **must be defined** within this block.  

**Goal**  
Create a packing of 26 circles inside the unit square that maximizes the combined score (sum of radii, distribution quality, etc.) while remaining fully valid (no runtime errors, all geometric constraints satisfied).

**Algorithmic Guidance – What Works Well**

1. **Two‑stage design**  
   - **Stage 1: Center placement** – generate an initial set of circle centers using a deterministic lattice (e.g., a uniform grid or hexagonal pattern) *or* a uniform random sample that respects a minimal separation distance.  
   - **Stage 2: Radius optimisation** – for any fixed set of centers, solve a linear program that maximises the sum of radii subject to:
     * Non‑negativity of each radius.  
     * Each radius ≤ distance from its center to the four sides of the unit square.  
     * For every unordered pair (i, j): rᵢ + rⱼ ≤ Euclidean distance between the two centers.  
   - Use `scipy.optimize.linprog` (already imported) to obtain the optimal radii efficiently.

2. **Local‑search refinement of centers**  
   - After the initial placement, repeatedly perturb individual centers by a small random offset (e.g., Gaussian noise with decreasing standard deviation).  
   - Re‑solve the LP for the perturbed layout; **accept** the new layout only if the objective (total radius) improves.  
   - Perform a modest number of iterations (e.g., 200–500) or stop early when no improvement occurs. This hill‑climbing step reliably boosts the score.

3. **Vectorised, shape‑safe constraint construction**  
   - Build the pairwise distance matrix with `np.linalg.norm` on the difference of the coordinate arrays.  
   - Flatten the upper‑triangle (i < j) to obtain a 1‑D array of distances.  
   - Create the coefficient matrix for the LP by starting with an identity matrix for the wall constraints, then appending rows that have a `1` in the columns of the two circles involved in each pairwise constraint.  
   - This avoids broadcasting mismatches and ensures each constraint corresponds to a single row.

4. **Numerical robustness**  
   - Add a tiny epsilon (e.g., `1e-9`) to all right‑hand‑side values to keep the LP strictly feasible.  
   - Impose an upper bound on radii (e.g., `1.0`) to prevent unbounded solutions in pathological cases.

**Pitfalls to Avoid – What Has Failed Previously**

- **Broadcasting shape errors** when forming the pairwise constraint matrix; always verify that the coefficient matrix has shape `(num_constraints, num_circles)`.  
- **Missing helper definitions** – any function you call (e.g., for layout generation, LP setup, or local search) must be fully implemented in this block.  
- **Omitting non‑negativity bounds** for the radii, which can lead to infeasible or unbounded LPs.  
- **Using overly large perturbations** that push centers outside the unit square; always clip or reject such moves before solving the LP.  
- **Neglecting to enforce the wall constraints** for each circle, which can produce circles that extend beyond the square.

**Implementation Requirements**

- You may add `import` statements here (e.g., `import numpy as np`, `from scipy.optimize import linprog`) if needed, but remember that `numpy` and `linprog` are already available.  
- Organise the code into clear, self‑contained functions: one for generating an initial layout, one for constructing and solving the LP, and one for the local‑search loop.  
- The top‑level function that the outer harness will call is `construct_packing()`. It must return a tuple `(centers, radii)` where `centers` is an `np.ndarray` of shape `(26, 2)` and `radii` is a 1‑D `np.ndarray` of length 26.  

Follow these directions precisely to produce a valid, high‑scoring packing solution.
