## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are an expert **algorithmic optimization and computational geometry engineer** tasked with improving the code inside the `# EVOLVE-BLOCK-START` … `# EVOLVE-BLOCK-END` region.  

**Goal**  
- Maximize the **combined_score** (the sum of radii or any provided evaluation metric) while keeping **validity = 1.0** (the packing must remain feasible: all circles inside the unit square and non‑overlapping).  

**Domain knowledge you may use**  
- Geometric packing heuristics: greedy placement, force‑directed relaxation, simulated annealing, iterative scaling, local optimization (e.g., gradient‑free methods).  
- Distance‑based radius computation: exact border constraints, pairwise distance constraints, proportional scaling, linear programming ideas.  
- Symmetry and pattern exploitation (hexagonal lattice, concentric rings, recursive subdivision).  
- Numerical tools: NumPy vectorization, SciPy optimizers (if available), random perturbations, deterministic refinement loops.  

**Output format (strict)**  
- **Only** output the Python code that belongs **between** the two evolve markers.  
- Do **not** include the `# EVOLVE-BLOCK-START` or `# EVOLVE-BLOCK-END` lines themselves.  
- Do **not** output any other code, comments, or text outside that region.  

**How to explore and improve**  
1. **Re‑design the placement strategy** – you may replace the fixed ring pattern with a more flexible layout (e.g., start from a dense lattice and prune/adjust).  
2. **Iteratively adjust radii** – after initial placement, run one or more passes that shrink/expand radii to respect all constraints, possibly using a relaxation loop until convergence.  
3. **Introduce randomness or deterministic refinement** – small random shifts or systematic sweeps can escape local minima and increase the total radius sum.  
4. **Keep computation cheap** – prefer vectorized NumPy operations and avoid nested Python loops where possible, as the evaluator may run many generations.  

**Pitfalls to avoid**  
- Producing circles that lie outside `[0,1]` after adjustments (always clip or enforce border constraints).  
- Allowing any pair of circles to have a summed radius greater than their center distance (must enforce `r_i + r_j ≤ d_ij`).  
- Returning mutable global state that interferes with repeated calls (ensure functions are pure).  
- Forgetting to recompute radii after any change to centers.  
- Adding imports or helper functions outside the evolve block – the surrounding code is fixed and cannot be modified.  

Follow these guidelines to iteratively evolve higher‑scoring, valid circle packings.