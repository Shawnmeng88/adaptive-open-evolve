## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Instructions for Evolving the Packing Code**

---

### Core Objective
Design the `construct_packing()` function (and any helper functions defined inside the evolve block) to **maximise the combined score** (e.g., sum of radii) while guaranteeing **validity = 1.0** – no circles may overlap and every circle must lie completely inside the unit square [0, 1] × [0, 1].

---

### Mandatory Output‑Format Rules (do **not** break these)

1. **Only** output the Python code that belongs **between** the markers  
   `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
2. **Do not** include the markers themselves, any surrounding imports, or other functions such as `run_packing()` – those are preserved automatically.  
3. The output must be **pure code** (no explanatory text, markdown, or comments outside the evolve block).

Failure to obey any of the above will cause the program to be rejected.

---

### What to Keep (successful elements)

- Use **NumPy** for vectorised distance calculations.  
- Keep the existing function signatures (`construct_packing()`, any helper you add).  
- Return the same data structures expected by the surrounding code (e.g., a tuple of `centers` and `radii`).  
- Include clear, deterministic steps so the evaluator can reproduce results.

---

### What **NOT** to Do (avoid repeated failures)

- **Do not** write code that relies on random trial‑and‑error without a deterministic fallback; this caused high invalidity rates.  
- **Do not** leave any possibility of circles crossing the boundary or overlapping because of unchecked rounding errors.  
- **Do not** embed an infinite loop or a huge number of iterations – the evaluator times out quickly.  
- **Do not** use external heavy libraries (e.g., `scipy.optimize`) that are not already imported; they increase import‑time failures.  
- **Do not** produce the same static layout for every run without any optimisation – it leads to plateaued low scores.  

---

### Suggested Concrete Strategies (you may combine them)

1. **Hexagonal Grid Seed**  
   - Initialise circle centres on a hexagonal lattice scaled to fit the unit square.  
   - Compute the maximal uniform radius that respects the border and nearest‑neighbour distances.  

2. **Iterative Radius Inflation**  
   - Start with a small radius (e.g., `0.02`).  
   - Repeatedly increase all radii by a tiny factor (`*1.01`) and, after each step, project any violating circles back onto the feasible region:
     * If a circle exceeds a wall, clamp its centre and shrink its radius to the distance to that wall.
     * If two circles overlap, move them apart along the line of centres proportionally to their overlap and shrink the larger radius to just touch.

3. **Force‑Based Relaxation (lightweight)**  
   - Treat each overlapping pair as a repulsive spring with force `k*(d_min - d)` where `d_min = r_i + r_j`.  
   - Perform a fixed small number (e.g., 30) of gradient‑like updates on centres and radii, then re‑clamp to the square.  
   - This yields a modest improvement without heavy optimisation.

4. **Edge‑First Placement**  
   - Place a few circles tightly against the four corners and the mid‑points of each side (maximal corner radius = `0.5 * min(x, y)`).  
   - Fill the interior with the hexagonal grid, adjusting radii locally where the edge circles create extra space.

5. **Deterministic Jitter for Symmetry Breaking**  
   - After the primary layout, add a tiny deterministic offset (e.g., based on the index `i` and `np.sqrt(2)`) to each centre before the final inflation step.  
   - This prevents the algorithm from getting stuck in a perfectly symmetric but sub‑optimal configuration.

---

### Implementation Checklist

- [ ] Use only `numpy` (already imported) – no new imports.  
- [ ] Keep all loops bounded (max ≈ 200 iterations total).  
- [ ] After each major step, verify feasibility with a helper `is_valid(centers, radii)`; if invalid, rollback the last change.  
- [ ] Return `centers` as an `(n, 2)` NumPy array and `radii` as a length‑`n` NumPy vector.  
- [ ] Ensure the function works for the fixed `n = 26` (or whatever `n` the outer code supplies).  

---

### Final Reminder
Produce **only** the code block that will replace the contents between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`. No extra text, no markers, no comments outside the block. Follow the strategies above to create a deterministic, high‑score, fully valid packing. Good luck!