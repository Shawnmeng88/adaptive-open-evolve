## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Meta‑Prompt Engineer for Code Evolution**

You are a *meta‑prompt engineer* tasked with guiding the language model to improve the code inside the **EVOLVE block** of a circle‑packing program. Follow these strict directives:

---

### 1. Output Restrictions (must be obeyed *exactly*)
- **Only** output the Python code that belongs **between** the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.
- **Do not** include the markers themselves.
- **Do not** output any imports, helper utilities, or code that lives outside the EVOLVE block (e.g., `run_packing()`, visualisation, global constants). Those sections are preserved automatically by the evaluation harness.
- The output must be a **single, syntactically valid Python snippet** that can be spliced directly into the existing file.

---

### 2. Focus of the Evolution
- **Improve ONLY** the `construct_packing()` function and any auxiliary functions defined *inside* the EVOLVE block (e.g., `compute_max_radii`, `refine_layout`, etc.).
- Do **not** modify signatures of preserved functions, nor add new top‑level definitions outside the block.
- The goal is to **increase the combined score** (sum of radii) for packing **26 circles** in the unit square while keeping **validity = 1.0** (no overlaps, all circles fully inside the square).

---

### 3. What to Keep (successful ideas from the current best solution)
- Use **NumPy** for vectorised distance calculations (the import already exists in the surrounding file).
- Keep the overall structure: generate an initial layout → compute feasible radii → optionally refine.
- Preserve any existing docstrings that explain the purpose of the functions.

---

### 4. What **NOT** to Do (failed or undesirable approaches)
- **Do not** introduce random or stochastic placement strategies that rely on uncontrolled seeds; they produce nondeterministic scores and may violate validity.
- **Do not** add heavy iterative optimisation loops that dramatically increase runtime (the evaluator expects the program to finish quickly).
- **Do not** import new third‑party libraries that are not already available (e.g., `scipy.optimize`, `cvxpy`). Stick to the standard library and NumPy.
- **Do not** alter the global constants that define the unit square or the required number of circles.

---

### 5. Concrete Strategies to Try (you may implement any combination that respects the above constraints)

1. **Hexagonal (triangular) lattice seed**  
   - Place circles on a hexagonal grid that fits 26 points inside the unit square.  
   - Compute the minimal distance between any two centers; the initial radius is half of that distance, clipped by the distance to the square edges.

2. **Edge‑aware radius scaling**  
   - After the initial lattice, compute for each center the distance to the nearest square side.  
   - Set the radius to the minimum of half the nearest inter‑center distance **and** the side distance, guaranteeing feasibility.

3. **Local radius equalisation**  
   - Perform a single pass over the centers: for each circle, if its radius is limited by a neighbor rather than a wall, raise it to the neighbor’s limiting value while still respecting the wall constraint.  
   - This cheap “balancing” step can increase the total sum without expensive optimisation.

4. **Greedy insertion of the 26th circle**  
   - Generate a dense 5×5 grid (25 circles) with radius 0.1, then locate the largest empty region (using a simple grid search) and place the 26th circle there with the maximal feasible radius.  
   - This deterministic step adds a measurable boost to the score.

5. **Vectorised distance matrix**  
   - Use `np.linalg.norm` on the difference of coordinate arrays to obtain a full pairwise distance matrix in one line.  
   - Derive the per‑circle nearest‑neighbor distance efficiently.

---

### 6. Template Guidance (you may adapt)

```python
def construct_packing():
    """
    Build a deterministic, high‑density layout for 26 circles in the unit square.
    Returns:
        centers (np.ndarray): shape (26, 2) array of (x, y) positions.
        radii   (np.ndarray): shape (26,) array of feasible radii.
    """
    # 1️⃣  Hexagonal lattice seed (covers 25 points)
    # 2️⃣  Compute wall distances and inter‑center distances
    # 3️⃣  Derive initial radii as the min of those two constraints
    # 4️⃣  Insert the 26th circle in the largest gap
    # 5️⃣  Perform a single cheap balancing pass
    return centers, radii
```

Feel free to create additional helper functions **inside** the EVOLVE block (e.g., `_hex_grid`, `_max_gap_center`) as long as they are only referenced by `construct_packing()`.

---

### 7. Final Reminder
- **Only** output the code that belongs inside the EVOLVE block.  
- No markers, no extra text, no explanations.  
- The snippet must be ready for direct insertion.

Good luck – produce the most score‑efficient, valid packing you can under these constraints.