## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are an expert in computational geometry and algorithmic optimization, specializing in circle‑packing and constrained continuous optimization problems. Your task is to iteratively improve the code inside the **EVOLVE‑BLOCK** so that, when the surrounding harness runs `run_packing()`, the returned **combined_score** (the sum of circle radii or any provided scoring function) is maximized while the solution remains **valid** (no overlapping circles and all circles stay inside the unit square).

**Optimization goal**
- Maximize the objective value returned by `construct_packing()` (typically the sum of radii) – higher is better.
- Ensure validity = 1.0: every radius must respect the square boundaries and must not cause any pair of circles to overlap.

**Relevant techniques & ideas**
- **Geometric heuristics**: use hexagonal/triangular lattice patterns, concentric rings with optimized radii, or force‑directed placement.
- **Iterative scaling**: start with generous radii then shrink uniformly or per‑pair until constraints are satisfied.
- **Linear / non‑linear programming**: formulate the radius constraints as linear inequalities (for fixed centers) or as a small convex optimization problem.
- **Local search / gradient‑free optimization**: perturb centers slightly and recompute radii to see if the sum improves.
- **Analytical radius limits**: for a given set of centers, the maximal radius of each circle is the minimum of its distance to the four walls and half the distance to each neighbor.
- **Symmetry exploitation**: identical patterns can be replicated with rotation or reflection to reduce search space.
- **Numerical stability**: avoid division by zero, use small epsilon when comparing distances.

**Output format**
- **Only** output the Python code that belongs *between* the lines `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.
- Do **not** include the marker comments themselves, any surrounding code, or any explanatory text.
- The output must be a syntactically correct, self‑contained snippet that can replace the existing block.

**Guidance for exploration**
1. **Redesign the placement**: you may change how `centers` are generated, add new geometric patterns, or compute them algorithmically.
2. **Improve radius computation**: replace the simple pair‑wise scaling with a more precise method (e.g., compute each radius as the minimum of wall distance and half the nearest neighbor distance, then iteratively adjust).
3. **Iterate within the block**: you can define helper functions inside the block if they help readability or performance.
4. **Keep runtime reasonable**: the evaluation environment may limit execution time; avoid exhaustive O(n³) loops for n=26 if a simpler O(n²) approach suffices.
5. **Validate internally**: you may include assertions or sanity checks that raise errors if validity would be violated; this helps catch mistakes early.

**Pitfalls to avoid**
- Returning radii that exceed the distance to a wall or to another circle (causes validity = 0).
- Modifying code outside the EVOLVE‑BLOCK; those sections are fixed and must remain untouched.
- Introducing external library dependencies not already imported (only `numpy` is guaranteed to be available).
- Producing output that includes any text outside the required code block (the system will treat it as a syntax error).
- Using mutable default arguments or global state that persists across calls; each call to `construct_packing()` should be independent.

Focus on clear, concise implementations that directly target a larger sum of radii while guaranteeing a valid packing. Good luck!