## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Code‑Evolution Block**

You are to generate **only** the Python code that belongs between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  

- **Do NOT** output the markers themselves.  
- **Do NOT** include any imports, global constants, or functions that lie outside the evolve block (e.g., `run_packing`, `visualize`, etc.).  
- The surrounding harness will automatically merge your output with the preserved sections.

### Goal
Rewrite and improve the functions inside the evolve block, especially `construct_packing()` and any private helpers it uses, so that when `run_packing()` is executed:

1. The **validity** metric is exactly 1.0 (all circles fully inside the unit square and pairwise non‑overlapping).  
2. The **combined_score** (the scoring function used by the evaluator) is maximized while still achieving validity = 1.0.

### What to Keep (Successful Strategies)
- Use a deterministic base layout (e.g., a 5×5 grid) and then add the 26th circle via a systematic search.  
- Employ `scipy.optimize.linprog` (or a similar linear programming approach) to compute optimal radii for a given set of centers under the constraints:  
  * radius ≥ 0  
  * radius ≤ distance to each side of the unit square  
  * radius_i + radius_j ≤ distance between centers *i* and *j*  
- Return a tuple `(centers, radii)` where `centers` is an `np.ndarray` of shape (N,2) and `radii` is a 1‑D `np.ndarray` of length N.  
- Keep helper functions small, pure, and well‑documented (e.g., `_optimal_radii_lp`, `compute_max_radii`).  

### What to Avoid (Failed Approaches)
- Adding or removing imports inside the evolve block (imports belong in the preserved section).  
- Modifying `run_packing()`, `visualize()`, or any code outside the evolve block.  
- Introducing side‑effects such as printing, writing files, or using random seeds without deterministic fallback.  
- Using heuristic “step” parameters that are not grounded in the constraints; they reduce validity.  

### Suggested Improvement Strategies
1. **Refactor `construct_packing()`**  
   - Build the initial 5×5 grid with a small margin (e.g., `margin = 0.05`) to guarantee non‑overlap.  
   - Generate a **candidate pool** for the 26th circle by sampling a uniform grid over the unit square (e.g., 20×20 points) and discarding points that are too close to existing centers.  
   - For each candidate, call `_optimal_radii_lp` on the full set of 26 centers and record the total radius sum.  
   - Choose the candidate that yields the highest total radius while still satisfying all constraints (the LP will return infeasible if a candidate violates spacing).  

2. **Strengthen the LP Helper**  
   - In `_optimal_radii_lp`, explicitly add constraints for each side of the square (`x_i - r_i >= 0`, `1 - x_i - r_i >= 0`, same for `y`).  
   - Use `bounds=(0, None)` for each radius variable.  
   - Return `None` if `linprog` reports infeasibility; `construct_packing()` should skip that candidate.  

3. **Post‑process Radii**  
   - After selecting the best candidate, run a final LP with **tightened tolerances** (`options={'tol':1e-9}`) to obtain the most accurate radii.  
   - Clip any tiny negative values to zero before returning.  

4. **Documentation & Type Hints**  
   - Add concise docstrings to each helper explaining the mathematical constraints.  
   - Use type hints (`np.ndarray`) for clarity; this does not affect runtime.  

### Output Requirements
- Output **only** the code that belongs between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- Do **not** include the markers themselves or any external code.  

When your revised block is merged, the full program should achieve a validity score of 1.0 and a higher combined_score than the previous best solution.