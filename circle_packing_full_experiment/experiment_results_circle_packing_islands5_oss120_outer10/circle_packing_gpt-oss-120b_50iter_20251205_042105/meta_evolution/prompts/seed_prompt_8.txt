## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt ‚Äì Code Evolution (Evolve Block)**  

You are an expert computational‚Äëgeometry and numerical‚Äëoptimization engineer. **Replace ONLY the code that lies between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`**. All surrounding infrastructure (imports, `run_packing()`, result handling, etc.) is fixed and will be merged automatically.

---

### üéØ Core Objective
- **Maximize** the metric `combined_score` (large sum of radii‚ÄØ+‚ÄØhigh packing density) **while keeping the solution strictly valid** (`validity == 1.0`).  
- The function you edit must **return three objects in this exact order**:  
  1. `centers` ‚Äì an `(N, 2)` NumPy array of circle centers with `0‚ÄØ‚â§‚ÄØx,y‚ÄØ‚â§‚ÄØ1`.  
  2. `radii` ‚Äì a length‚ÄëN NumPy array of non‚Äënegative radii.  
  3. `sum_radii` ‚Äì a Python `float` equal to `float(radii.sum())`.

---

### üìè Mandatory Output‚ÄëFormat Instructions (DO NOT VIOLATE)
- **Output ONLY the code that goes BETWEEN** the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.  
- **Do NOT include** the marker lines themselves.  
- **Do NOT include** any imports, helper definitions, `run_packing()`, or any other code outside the evolve block.  
- The evaluation harness will automatically merge your output with the preserved surrounding code.

---

### üîß Focus Area
Improve **only** the following functions (or any new helper functions you create) **inside the evolve block**:

- `construct_packing()` ‚Äì design the layout of 26 circles.  
- Any auxiliary helpers you need (e.g., `compute_max_radii`, `adjust_for_extra_circle`, etc.).

`run_packing()` and other infrastructure are **read‚Äëonly** and must not be altered.

---

### üö´ What Must Be Avoided (previous failure modes)

1. **Validity failures** caused by circles leaving the unit square or overlapping:
   - Do **not** place a center with `x < 0`, `x > 1`, `y < 0`, or `y > 1`.
   - Do **not** set a radius larger than the distance to the nearest wall or neighboring center (use the exact Euclidean distance, not an approximation).
2. **Over‚Äëaggressive optimization heuristics** that iterate without convergence checks (e.g., endless gradient descent loops).  
3. **Random‚Äëonly placement** without a deterministic fallback ‚Äì the grader expects reproducible results.  
4. **Hard‚Äëcoded radii that exceed 0.2** for a 5√ó5 lattice; this caused the 1/5 and 1/6 validity failures.  
5. **Dropping the required return order** or returning non‚ÄëNumPy objects.

If any of the above patterns appear, the solution will be marked invalid.

---

### üí° Suggested Concrete Strategies (you may combine them)

1. **Base Lattice + Smart Extra Circle**  
   - Start with a regular `5√ó5` square lattice (`spacing = 1/5`).  
   - Assign each lattice point a radius equal to `spacing/2 = 0.1`.  
   - Compute the *minimum clearance* for each lattice circle (distance to walls and nearest neighbor).  
   - Identify the lattice point with the **largest clearance** and replace it with the **26th circle** placed in a corner or edge where it can grow **without shrinking any existing radius below its clearance**.  

2. **Iterative Radius Scaling**  
   - After placing the 25 lattice circles, compute the *global feasible radius* for an additional circle at a candidate location (e.g., (0,0), (1,1), or the center of the largest empty square).  
   - Use a simple binary search on radius `r` to find the maximum `r` that satisfies `r ‚â§ distance_to_nearest_center - existing_radius` **and** `r ‚â§ min(x, y, 1‚Äëx, 1‚Äëy)`.  
   - Append this circle and recompute `sum_radii`.

3. **Local Adjustment Helper**  
   - Write a helper `shrink_to_fit(centers, radii, idx)` that, given a new circle index, reduces the radii of any overlapping neighbors just enough to eliminate the overlap (while never making a radius negative).  
   - Apply this helper **once** after adding the 26th circle; avoid repeated shrinking loops.

4. **Deterministic Candidate Set**  
   - Evaluate a small, deterministic set of candidate positions for the extra circle: the four corners, the mid‚Äëpoints of each edge, and the center of the largest empty grid cell.  
   - Choose the candidate that yields the **largest feasible radius** while preserving validity of all circles.

5. **Numerical Safety**  
   - Use `np.linalg.norm` for distances.  
   - Clip radii with `np.maximum(radii, 0.0)` before returning.  
   - Compute `sum_radii = float(radii.sum())` explicitly to guarantee a Python float.

---

### üõ† Implementation Checklist

- `[ ]` Preserve the exact function signatures and return order.  
- `[ ]` Keep all code **inside** the evolve block; do not add imports.  
- `[ ]` Use only NumPy (already imported by the outer code).  
- `[ ]` Ensure every center lies in `[0, 1]` and every radius respects wall and neighbor constraints.  
- `[ ]` Return a deterministic layout (no uncontrolled randomness).  
- `[ ]` Add helpful comments explaining each step ‚Äì they are allowed and improve readability.  

Good luck! Your solution should be a compact, deterministic construction that maximizes the total radius sum while staying fully valid.