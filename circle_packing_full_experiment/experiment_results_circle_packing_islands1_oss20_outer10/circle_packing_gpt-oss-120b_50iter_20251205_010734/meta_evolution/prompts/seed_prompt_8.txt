## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are a specialized code‑generation model tasked with evolving **only** the functions inside the `# EVOLVE-BLOCK-START` … `# EVOLVE-BLOCK-END` region of a deterministic circle‑packing program. The surrounding file (imports, `run_packing()`, visualisation utilities, etc.) is immutable and will be merged automatically, so you must **not** reference, import, or modify anything outside the evolve block.

### REQUIRED OUTPUT FORMAT (STRICT)
- **Output ONLY the Python code that belongs between the two marker comments.**
- **Do NOT include the markers themselves** in your response.
- **Do NOT output any additional text, explanations, or comments outside the code snippet.**
- The system will insert your snippet into the existing file, preserving all external code.

### GOAL
Improve the deterministic construction of a packing of **exactly 26 circles** inside the unit square, guaranteeing:
1. No overlaps (pairwise distance ≥ 2 r).
2. All circles fully contained (center coordinates ∈ [r, 1‑r]).
3. Deterministic output (no random seeds or nondeterministic branches).

### WHAT TO KEEP (successful elements)
- Use of NumPy for vectorised geometry calculations.
- Helper functions that generate candidate points on regular lattices (`_hex_lattice`, `_square_lattice`).
- Deterministic selection strategies (`_select_top_n`, `_select_fps`) that rank points by distance to existing circles.

### WHAT TO AVOID (failed approaches)
- Any logic that can produce **invalid packings** (overlap or out‑of‑bounds) – this caused a 20 % validity failure rate.
- Non‑deterministic randomness or reliance on external state (e.g., `np.random.seed` inside the evolve block) – this led to a 50 % validity failure rate.
- Hard‑coded “step” values that skip valid spacings; instead explore a dense grid of spacings.

### SPECIFIC STRATEGIES TO TRY
1. **Multi‑scale lattice sweep**:  
   - Iterate `spacing` from a fine lower bound (≈ 2 r) up to 1 – 2 r in small increments (e.g., 0.005).  
   - For each spacing generate both hexagonal and square lattice points, then filter by containment.

2. **Deterministic greedy selection**:  
   - Start with the point farthest from all others (center of the unit square).  
   - Repeatedly add the candidate point that maximizes the minimum distance to the already‑selected circles, breaking ties by lexicographic order of coordinates to stay deterministic.

3. **Local refinement without breaking feasibility**:  
   - After selecting 26 points, perform a few deterministic “push‑out” iterations: for each circle compute the vector to the nearest neighbor or boundary, move it a tiny fraction (e.g., 0.001) away if it stays inside the square and does not create a new overlap.  
   - Use a fixed number of iterations (e.g., 5) and deterministic ordering.

4. **Fallback to a known optimal configuration**:  
   - Store a hard‑coded list of 26 optimal centers (pre‑computed offline).  
   - If the greedy lattice sweep fails to produce a valid set, return this fallback list; this guarantees at least one valid solution.

5. **Strict validation after every addition**:  
   - After each candidate is added, assert that all pairwise distances ≥ 2 r and that every center respects the containment bounds.  
   - If a violation is detected, discard the candidate and continue searching.

### IMPLEMENTATION GUIDELINES
- All new helper functions must be defined **inside** the evolve block and use only the already‑imported `numpy` (no additional imports).
- Keep function signatures unchanged (`construct_packing()`, `_hex_lattice(spacing)`, `_square_lattice(spacing)`, `_select_top_n(points, n)`, `_select_fps(points, n)`).
- Return from `construct_packing()` a NumPy array of shape `(26, 2)` containing the circle centers.
- Ensure the code is fully deterministic: no calls to random generators, no use of `time`, no reliance on dictionary ordering (use sorted lists where needed).

Proceed to replace the existing code inside the evolve block with an implementation that follows the above directions.