## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Code Evolution for Circle Packing**

You are tasked with improving only the functions inside the evolve block, specifically `construct_packing()` and any helper functions it uses. The surrounding code (imports, `run_packing()`, visualisation, etc.) is fixed and will be merged automatically, so **do not modify or reference anything outside the evolve block**.

### Mandatory Output Rules  
- **Output ONLY the Python code that belongs between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.**  
- **Do NOT include the markers themselves** in your response.  
- **Do NOT output any additional text, explanations, or code outside those boundaries.**  
- The system will insert your snippet into the existing file, preserving all other sections.

### Goal  
Produce a deterministic arrangement of **26 circles** inside the unit square that:

1. **Validity = 1.0** – no two circles overlap and every circle lies completely inside the square.  
2. **Maximises the combined score** (sum of radii, density, or the metric defined by the evaluation harness).  
3. Is **repeatable** (no random seeds or nondeterministic behaviour).

### What to Keep (successful ideas from the current best solution)  
- Use **NumPy** for vectorised distance calculations.  
- Generate a **hexagonal/triangular lattice** as the base layout; this pattern is known to be near‑optimal for dense packings.  
- Compute each circle’s radius as the **minimum distance to any neighbour or to the square boundary**, then halve it.  

### What to Avoid (failed approaches)  
- Random‑search or stochastic optimisation that can leave circles partially outside the unit square.  
- Heuristic “grow‑until‑collision” loops that do not guarantee a final non‑overlapping state.  
- Hard‑coded radius values that ignore the actual geometry; this caused validity failures in earlier attempts.  

### Suggested Concrete Strategies (you may combine them)  

1. **Multi‑scale Hex Grid**  
   - Create several hexagonal grids with slightly different spacings (e.g., `s`, `s*0.95`, `s*1.05`).  
   - Merge the point sets, then remove duplicates (within a tiny tolerance).  
   - This provides a richer set of candidate centres while preserving the lattice’s regularity.

2. **Boundary‑aware Radius Computation**  
   - For each centre `c = (x, y)`, compute distances to the four walls: `dx = min(x, 1‑x)`, `dy = min(y, 1‑y)`.  
   - Compute distances to all other centres, take the smallest positive distance, and set `r = 0.5 * min(dx, dy, nearest_center_distance)`.  
   - Vectorise this with NumPy broadcasting for speed and determinism.

3. **Iterative Pruning of Over‑crowded Points**  
   - After the initial grid generation, compute radii for all points.  
   - Identify any point whose radius falls below a small threshold (e.g., `0.005`).  
   - Remove the point with the smallest radius, recompute radii, and repeat until exactly 26 points remain.  
   - This guarantees that the final set respects the non‑overlap condition while keeping the highest‑radius circles.

4. **Symmetry‑preserving Placement**  
   - Align the grid so that the pattern is mirrored across the centre of the square; this often yields a higher total radius sum without extra computation.

5. **Deterministic Tie‑Breaking**  
   - When two points have identical radii during pruning, always discard the one with the larger index (or the one farther from the centre).  
   - This eliminates nondeterminism.

### Implementation Checklist  

- **Define helper functions** (e.g., `_hex_grid(num_points, spacing)`, `_compute_radii(centers)`) **inside the evolve block**; they may be called by `construct_packing()`.  
- **Return** a tuple `(centers, radii)` from `construct_packing()` where `centers` is an `np.ndarray` of shape `(26, 2)` and `radii` is an `np.ndarray` of shape `(26,)`.  
- Ensure the function runs **without external randomness** (no `np.random` calls).  
- Include **docstrings** explaining each helper’s purpose; this is allowed inside the evolve block.  

Remember: **Only the code between the markers will be kept**. Follow the output rules exactly.