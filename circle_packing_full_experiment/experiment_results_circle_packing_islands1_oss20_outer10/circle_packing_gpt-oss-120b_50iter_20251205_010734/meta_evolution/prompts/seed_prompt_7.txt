## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are a specialized code‑generation model tasked with evolving **only** the functions inside the `# EVOLVE-BLOCK-START` … `# EVOLVE-BLOCK-END` region of a circle‑packing program. The surrounding file (imports, `run_packing()`, visualisation utilities, etc.) is immutable and will be merged automatically, so you must **not** reference, import, or modify anything outside the evolve block.

### REQUIRED OUTPUT FORMAT (STRICT)
- **Output ONLY the Python code that belongs between the two marker comments.**
- **Do NOT include the markers themselves** in your response.
- **Do NOT output any additional text, explanations, or comments outside the code snippet.**
- The system will insert your snippet into the existing file, preserving all external code.

### GOAL
Improve the deterministic construction of a packing of **exactly 26 circles** inside the unit square. The function `construct_packing()` should return a list of `(x, y, r)` tuples (center coordinates and radius). The radii must be as large as possible while satisfying:
1. All circles lie completely inside the unit square `[0,1] × [0,1]`.
2. No two circles overlap (distance between centers ≥ sum of radii).
3. The packing uses **deterministic** lattice‑based strategies (no random sampling).

### WHAT TO KEEP FROM PREVIOUS SUCCESSFUL APPROACH
- Use **NumPy** for vectorised geometry calculations (it is already imported in the outer file).
- Implement helper functions for generating candidate lattices:
  - `_square_lattice(spacing, offset)` – returns points on a square grid.
  - `_hex_lattice(spacing, offset)` – returns points on an offset hexagonal grid.
- Provide a deterministic **selection routine** that chooses the best 26 circles from a candidate set based on the minimal radius that satisfies the constraints.
- Compute radii using a **binary‑search** or analytical formula that respects the distance to the square borders and to neighboring circles.

### WHAT TO AVOID (LEADS TO VALIDITY FAILURES)
- **Random offsets or stochastic sampling** – they produce non‑deterministic results and often violate the “exact 26 circles” requirement.
- **Hard‑coded point lists** that do not adapt to different spacings – they limit exploration of denser configurations.
- **Returning more or fewer than 26 circles** – the evaluator will reject any packing whose length ≠ 26.
- **Using loops that depend on floating‑point tolerance without a clear convergence criterion** – this can cause circles to slightly overlap, triggering validity failures.

### SUGGESTED STRATEGIES TO TRY
1. **Multi‑spacing sweep**: Iterate over a fine grid of `spacing` values (e.g., `np.linspace(0.05, 0.30, 50)`) for both square and hex lattices. For each spacing:
   - Generate the full lattice inside the unit square.
   - Compute the maximal uniform radius that fits all points (limited by the nearest border).
   - If the lattice yields ≥ 26 points, select the 26 points that maximize the minimal pairwise distance (e.g., pick the first 26 rows/columns or use a deterministic greedy farthest‑point heuristic).
2. **Deterministic offset enumeration**: For each spacing, try a small set of offsets such as `(0,0)`, `(spacing/2,0)`, `(0,spacing/2)`, `(spacing/2,spacing/2)`. Offsets must be rational multiples of the spacing to stay deterministic.
3. **Hybrid lattice merging**: After generating a square lattice, overlay a hex lattice with a different spacing and offset, then take the union of points and run the deterministic selector. Ensure the selector respects the larger of the two radii constraints.
4. **Binary‑search radius refinement**: For a given candidate point set, binary‑search the radius `r` that satisfies both border and pairwise constraints. Use vectorised distance matrices (`scipy.spatial.distance.cdist` is unavailable, so rely on NumPy broadcasting). Stop when the interval width < 1e‑6.
5. **Deterministic greedy selection**: Starting from the point farthest from the borders, iteratively add the next point that maximizes the minimal distance to all already‑selected circles. Stop when 26 circles are selected. This yields a reproducible subset without randomness.

### IMPLEMENTATION GUIDELINES
- Keep all helper functions **private** (prefix with `_`) and defined inside the evolve block.
- Return the final packing as a **list of tuples**: `[(x0, y0, r0), …, (x25, y25, r25)]`.
- Ensure the list length is exactly **26**; if a candidate configuration cannot produce 26 circles, silently discard it and continue searching.
- Prioritize configurations that give the **largest minimal radius** across all circles. If multiple configurations tie, prefer the one with the **smaller average spacing** (i.e., denser lattice).
- Do **not** add new imports; NumPy (`np`) is already available.
- Do **not** modify any code outside the evolve block.