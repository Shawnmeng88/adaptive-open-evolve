## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt â€“ Codeâ€‘Evolution Guidance**

---

### ğŸ¯ Goal
Refine the `construct_packing()` function (and any helper functions defined inside the evolve block) to achieve a *perfectly valid* circle packing inside the unit square (scoreâ€¯=â€¯1.0) while keeping the rest of the program untouched.

---

### ğŸ“‹ Core Requirements (DOâ€¯NOTâ€¯BREAK)

1. **Output Scope**  
   - **Only** the Python code that belongs **between** the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
   - **Do not** include the marker lines themselves.  
   - **Do not** add imports, global constants, or any code outside this block (e.g., `run_packing`, topâ€‘level imports, or other utilities).  

2. **Function Signatures**  
   - Preserve the exact signatures of `construct_packing()` and any helper functions that already exist inside the evolve block.  
   - Do **not** rename, remove, or add parameters that are not already present.  

3. **Validity Constraint**  
   - The generated packing must satisfy **perfect validity**: every circle must be completely inside the unit square and must not overlap any other circle.  

---

### ğŸš€ Suggested Strategies (apply **inside** the evolve block)

1. **Robust Radius Computation**  
   - Use a linearâ€‘programming formulation (e.g., `scipy.optimize.linprog`) to maximize radii subject to pairwise nonâ€‘overlap and boundary constraints.  
   - Add a fallback geometric heuristic (minimum distance to nearest neighbor or wall) in case the LP fails to converge.  

2. **Iterative Refinement**  
   - Start with an initial guess (e.g., hexagonal lattice or random jitter).  
   - Run a few iterations of a simple gradientâ€‘descent or â€œpushâ€‘apartâ€ step that reduces any constraint violations while keeping circles inside the square.  

3. **Boundary Handling**  
   - Explicitly enforce `0â€¯â‰¤â€¯xâ€¯âˆ’â€¯r` and `xâ€¯+â€¯râ€¯â‰¤â€¯1` (and similarly for y) after every update.  
   - Clip radii to the minimum of the distance to each wall and the distance to the nearest neighbor divided by two.  

4. **Numerical Stability**  
   - Use a small epsilon (e.g., `1e-9`) when checking constraints to avoid floatingâ€‘point edge cases.  
   - Return radii as `float` values rounded to a reasonable precision (e.g., `np.round(r, 12)`).  

5. **Deterministic Output (optional)**  
   - If reproducibility is desired, seed any random number generators at the start of `construct_packing()`.  

---

### âŒ What to Avoid (explicitly prohibited)

- Adding new imports or global variables outside the evolve block.  
- Changing the signature of `construct_packing()` or removing existing helper functions.  
- Returning circles that intersect the squareâ€™s boundary or each other.  
- Including the `# EVOLVE-BLOCK-START` / `# EVOLVE-BLOCK-END` markers in your output.  

---

### âœ… Deliverable

- Output **only** the updated code that belongs between the two markers.  
- No extra commentary, explanations, or surrounding code.  

Good luck!