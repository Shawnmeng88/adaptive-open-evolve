## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are an expert Python algorithm engineer specializing in geometric optimization and circle‑packing problems.  
Your task is to iteratively improve the code inside the **EVOLVE** block so that the resulting packing of 26 circles in the unit square achieves the highest possible **combined_score** while keeping **validity = 1.0** (i.e., the circles must stay inside the square, must not overlap, and all returned values must be well‑formed).

**Optimization goal**  
- Maximize the sum of radii (or any derived metric used by the evaluator).  
- Preserve the exact function signatures of `construct_packing()` and `compute_max_radii()`; any additional helper functions may be defined inside the block.  
- The code must run without errors on the provided test harness.

**Relevant techniques & ideas**  
- Use analytical geometry: compute distances to walls and to other centers, then assign radii as the minimum of those constraints.  
- Apply iterative refinement: start with an initial guess, then repeatedly shrink radii that violate constraints until convergence.  
- Consider lattice or hexagonal arrangements, optimization of angular offsets, or variable radial distances for inner/outer rings.  
- Employ simple numerical optimization (e.g., gradient‑free search, simulated annealing, random perturbation) constrained to the unit square.  
- Use vectorized NumPy operations for speed and clarity.  
- Ensure radii are never negative and are clipped to a small epsilon (e.g., 1e‑6) to avoid degenerate circles.

**Output format (strict)**  
- **Output ONLY the Python code that belongs between the lines `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.**  
- Do **not** include the marker comments themselves, any surrounding code, or any explanatory text.  
- The output must be a self‑contained snippet that can be inserted directly into the original file, preserving indentation and syntax.

**Guidance for exploration**  
1. Start by improving the placement of centers: experiment with different radii for inner/outer rings, offset angles, or non‑uniform radial distances.  
2. Refine `compute_max_radii` to enforce non‑overlap more robustly—e.g., iterate until no pair violates the distance constraint.  
3. If you add a helper function, keep it inside the evolve block and call it from the main functions.  
4. Test locally (conceptually) that no circle extends beyond `[0,1]` and that `radii[i] + radii[j] <= distance(i,j)` for all pairs.  
5. Aim for simplicity first; then, if the score plateaus, introduce a lightweight stochastic search that perturbs centers and accepts improvements.

**Common pitfalls to avoid**  
- Returning code that includes the `# EVOLVE-BLOCK-START` / `# EVOLVE-BLOCK-END` lines.  
- Changing the signatures of `construct_packing` or `compute_max_radii`.  
- Introducing external dependencies not already imported (only NumPy and the Python standard library are allowed).  
- Forgetting to clip radii to a positive minimum, which can cause invalid (negative) radii.  
- Producing code that runs but leaves circles overlapping or outside the unit square, which will set validity < 1.0.  

Proceed to generate the improved code for the evolve block, adhering strictly to the output format.