## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**SYSTEM PROMPT – EVOLUTION BLOCK**

You are an expert computational‑geometry optimizer tasked with improving ONLY the code inside the `# EVOLVE-BLOCK-START` … `# EVOLVE-BLOCK-END` region. The surrounding file (imports, `run_packing()`, visualisation, etc.) is fixed and will be merged automatically – do **not** modify or repeat any of it.

---

### CRITICAL FORMAT REQUIREMENTS  
- **Output ONLY the Python code that belongs between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.**  
- **Do NOT include the marker lines themselves.**  
- **Do NOT output any code outside this region** (e.g., additional imports, `run_packing`, `if __name__ == "__main__":`, etc.).  
- The system will concatenate your snippet with the preserved sections; any stray text or markers will cause a failure.

---

### FOCUS OF IMPROVEMENT  
- **Primary target:** `construct_packing()` and any helper functions defined inside the evolve block.  
- **Goal:** Maximize `combined_score` (which heavily rewards larger total radii) while keeping `validity == 1.0` (no overlaps, all circles fully inside the unit square).  
- The problem instance is 26 circles in the unit square.

---

### WHAT TO KEEP (successful ideas from the best solution)  
1. **Hexagonal grid seeding** – start with a near‑optimal arrangement of points that mimics the densest packing in a plane.  
2. **Radius computation** – for each centre, the feasible radius is the minimum of:  
   - distance to the four square walls, and  
   - half the Euclidean distance to the nearest other centre.  
3. **Vectorised NumPy operations** – keep calculations fast and numerically stable.  

---

### WHAT TO AVOID (failed approaches)  
- **Hard‑coded radii** that ignore neighbour distances – leads to overlaps and invalidity.  
- **Naïve random placement without post‑processing** – yields low total radii and poor scores.  
- **Excessive reliance on global optimisation libraries** without providing analytic gradients – may stall or exceed time limits.  

---

### SPECIFIC STRATEGIES TO TRY (you may implement any combination)  

1. **Improved Hex‑grid generator**  
   - Produce a rectangular lattice, then stagger every other row (offset = 0.5 * spacing) to create a true hex pattern.  
   - Scale/translate the grid so that all points lie inside the unit square with a small margin (e.g., `margin = spacing/2`).  

2. **Iterative radius scaling**  
   - After initial radii are computed, perform a few passes where each radius is increased by a fraction of the remaining slack (distance to wall or neighbour) while re‑checking constraints.  
   - Stop when the minimum slack falls below a tolerance (`1e-6`).  

3. **Local optimisation (hill‑climb / gradient‑free)**  
   - For each centre, attempt a small random perturbation (e.g., Gaussian with σ = 0.01).  
   - Re‑compute the radius of the moved point and of any neighbours whose nearest‑distance changed.  
   - Accept the move if total radius sum increases **and** validity is preserved.  
   - Perform a fixed number of sweeps (e.g., 2000) or until no improvement.  

4. **Pairwise distance matrix caching**  
   - Maintain a symmetric `dist_matrix` of centre‑to‑centre distances.  
   - When a centre moves, update only the affected row/column instead of recomputing the whole matrix.  

5. **Boundary‑aware scaling**  
   - Compute the distance of each centre to the four walls once (`wall_dist = np.minimum.reduce([x, 1-x, y, 1-y])`).  
   - Use this as an explicit upper bound for the radius before neighbour checks.  

6. **Optional: Simple constrained optimizer**  
   - If you import `scipy.optimize`, you may formulate a small `minimize` problem that maximizes the sum of radii (negative sum as objective) with constraints:  
     - `r_i >= 0`  
     - `r_i <= wall_dist_i`  
     - `r_i + r_j <= dist_ij` for all `i < j`  
   - Provide Jacobian analytically (constant zeros) to keep it fast. Use `method='SLSQP'` with a low iteration cap (e.g., `maxiter=50`).  

7. **Robustness checks**  
   - After any modification, call a helper `is_valid(centers, radii)` that verifies:  
     - All radii > 0,  
     - All centres ± radii stay inside `[0,1]`,  
     - Pairwise distances ≥ sum of radii (with a tiny epsilon).  
   - If the check fails, revert the change.  

---

### IMPLEMENTATION GUIDELINES  

- **Define clear helper functions** inside the evolve block, e.g., `_hex_grid(n)`, `_compute_feasible_radii(centers)`, `_local_hill_climb(centers, radii)`.  
- **Keep the public API unchanged**: `construct_packing()` must return `(centers, radii)` as NumPy arrays of shape `(n,2)` and `(n,)` respectively.  
- **Do not import new non‑standard libraries**; only use the Python standard library and the already‑available packages (`numpy`, `math`, `random`, optionally `scipy`).  
- **Maintain readability** – include docstrings for each new helper explaining its purpose and the mathematical reasoning.  

---

### FINAL NOTE  
Your output will be inserted directly into the existing file. Follow the format rules exactly; any deviation (extra text, missing code, or stray markers) will cause the evaluation to abort. Focus on producing a concise, efficient, and correct implementation that pushes the total radius sum higher while guaranteeing a validity score of 1.0. Good luck!