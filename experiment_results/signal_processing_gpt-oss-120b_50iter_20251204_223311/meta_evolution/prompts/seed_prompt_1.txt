## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Code Evolution for `construct_packing()`**

You are tasked with evolving the `construct_packing()` function (and any helper functions defined inside the **evolve block**) to produce a correct, efficient packing algorithm. The surrounding code (imports, `run_packing()`, etc.) will be preserved automatically; **you must output ONLY the Python code that belongs BETWEEN the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.** Do **not** include the markers themselves, any surrounding code, or any explanatory text.

### What You Must Do
1. **Focus exclusively on `construct_packing()` and its internal helpers.**  
   - Refactor, add, or remove helper functions *only* if they improve correctness or performance.  
   - Do **not** modify any code outside the evolve block.

2. **Produce a valid, runnable implementation** that:
   - Correctly respects all packing constraints (e.g., item sizes, bin capacities, ordering rules).  
   - Returns the expected data structure (list of bins, each bin a list of placed items) as used by the test harness.  
   - Handles edge‑cases gracefully (empty input, oversized items, duplicate identifiers, etc.).  

3. **Adopt one of the following concrete strategies** (pick the one you think will best solve the problem and implement it fully):
   - **Greedy First‑Fit Decreasing (FFD):**  
     - Sort items by descending size.  
     - Iterate through bins, placing each item into the first bin that can accommodate it; create a new bin when necessary.  
   - **Recursive Backtracking with Pruning:**  
     - Try to place each item into every feasible bin, backtrack when a dead‑end is reached.  
     - Use memoization (e.g., a tuple of remaining items and current bin loads) to avoid duplicate work.  
   - **Dynamic Programming / Bin‑Packing Approximation:**  
     - Compute a lower bound (e.g., total volume / bin capacity).  
     - Build bins incrementally, using a DP table to track reachable load states and reconstruct a feasible packing.  
   - **Hybrid Approach:**  
     - Start with a fast greedy pass to obtain an initial solution, then improve it with a limited backtracking search limited by a step counter or time budget.

4. **Implement helper utilities only if they directly support the chosen strategy**, such as:
   - `can_place(item, bin)` – returns a boolean.  
   - `place(item, bin)` – updates bin state immutably or mutably (choose one style and stay consistent).  
   - `clone_state(state)` – for backtracking branches.  
   - Any caching structures needed for memoization.

5. **Maintain clean, readable code**:
   - Use descriptive variable names.  
   - Add short inline comments (max one line) explaining non‑obvious logic.  
   - Keep the function signatures unchanged (the test harness expects the original names and parameters).

### What You Must **NOT** Do
- **Do not** output any text outside the code block (no explanations, no markers, no markdown).  
- **Do not** repeat the previous failure pattern: producing completely invalid programs, missing required returns, or violating the output format.  
- **Do not** add imports, global variables, or modify code outside the evolve block.  
- **Do not** leave placeholder `pass` statements or `TODO` comments that would cause a runtime error.  
- **Do not** change the overall algorithmic contract of `construct_packing()` (e.g., returning a different data type).

### Mandatory Output Format
- **Only** the Python source code that belongs between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- **Do not** include the markers themselves.  
- **Do not** include any additional text, explanations, or formatting.

Proceed to implement the chosen strategy, ensuring the resulting code is syntactically correct and satisfies all packing constraints. Good luck!