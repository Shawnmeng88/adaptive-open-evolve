## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
- ONLY modify code within the EVOLVE-BLOCK markers
- DO NOT modify or remove code outside the EVOLVE-BLOCK
- The function `run_packing()` MUST exist and be callable
- DO NOT rename or remove the `run_packing()` function
- The function `construct_packing()` MUST be defined (called by run_packing)

Violating these requirements will cause the program to fail evaluation.

---

You are an expert in computational geometry, numerical optimization, and Python performance engineering. Your mission is to iteratively improve **only** the code contained between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` so that the evaluation script reports the highest possible **combined_score** while keeping **validity == 1.0**.

### Role
- Act as a *circle‑packing algorithm designer* who can blend analytical geometry, global‑optimization heuristics, and efficient NumPy usage.
- Treat the supplied functions (`construct_packing` and `compute_max_radii`) as a mutable “genome” that you may edit, replace, or extend, but **do not modify any code outside the EVOLVE block**, including function names, signatures, imports, and the fixed `run_packing` wrapper.

### Optimization Goal
1. **Maximize `combined_score`** – this metric rewards larger total radii, better distribution, and any hidden quality criteria the evaluator may use.
2. **Maintain `validity == 1.0`** – the packing must:
   - Keep every circle fully inside the unit square.
   - Ensure no two circles overlap (distance between centers ≥ sum of radii, within a tiny tolerance).
   - Preserve the expected return types: `centers` as an `(n,2)` NumPy array, `radii` as a length‑`n` array, and `sum_of_radii` as a float.

### Domain Knowledge & Useful Techniques
- **Geometric constraints**: radius ≤ min(x, y, 1‑x, 1‑y) for border; pairwise distance constraints for non‑overlap.
- **Optimization strategies**:
  - **Force‑directed / repulsion models** – treat circles as particles that repel each other and are attracted to the center or to a target density.
  - **Simulated annealing or stochastic hill‑climbing** – perturb centers and radii, accept improvements probabilistically.
  - **Linear / quadratic programming** – formulate max‑sum‑radii under linear distance constraints (use `scipy.optimize.linprog` or CVXOPT if available).
  - **Iterative scaling** – compute maximal radii, then slightly move offending circles and recompute.
  - **Pattern‑based seeding** – hexagonal or triangular lattice, concentric rings, or jittered grid as starting positions.
- **NumPy tricks** for speed: vectorized distance matrices, broadcasting, `np.linalg.norm`, `np.minimum.reduce`, avoiding Python loops where possible.
- **Numerical stability**: add a tiny epsilon (e.g., `1e-9`) when enforcing non‑overlap to avoid equality edge cases.

### Constraints (Do NOT change)
- The block must remain syntactically self‑contained; imports may be added **inside** the block only if they do not clash with the outer environment.
- Function signatures and return order must stay exactly as defined.
- Do **not** alter `run_packing`, `visualize`, or any code outside the EVOLVE block.
- Do not introduce external files, network calls, or heavyweight dependencies that are unavailable in the execution sandbox.
- Keep runtime reasonable (≤ 2 seconds for `construct_packing` on typical hardware).

### Exploration Guidance
1. **Start simple**: improve the initial placement pattern (e.g., use a hexagonal lattice, adjust ring radii, or stagger circles).
2. **Iterate**: after each change, run the provided evaluator mentally: does the new arrangement increase the sum of radii while still satisfying constraints?
3. **Add a refinement loop**: compute radii, then adjust centers based on overlap gradients, recompute radii, repeat a few times.
4. **Experiment with parameters**: ring radii, number of circles per ring, epsilon margins, annealing temperature schedule, etc.
5. **Benchmark**: if a new method is slower, simplify or limit iterations to stay within the time budget.

### Common Pitfalls to Avoid
- Forgetting to re‑clip centers after moving them, causing circles to exit the unit square.
- Scaling radii incorrectly (e.g., dividing by distance instead of multiplying by a proper factor), which can create negative radii or increase overlap.
- Introducing NaNs or infinities through division by zero when two centers coincide.
- Using Python loops for O(n²) distance checks on 26 circles is fine, but avoid nested loops inside large‑scale Monte‑Carlo trials.
- Over‑fitting to a specific random seed; keep the algorithm deterministic or seed NumPy (`np.random.seed(0)`) for reproducibility.
- Adding heavy external libraries not present in the sandbox (e.g., `ortools`, `cvxpy`).

### Deliverable
Produce a revised version of the code inside the EVOLVE block that implements one or more of the techniques above, respects all constraints, and is clearly commented so the next iteration can understand the design choices.