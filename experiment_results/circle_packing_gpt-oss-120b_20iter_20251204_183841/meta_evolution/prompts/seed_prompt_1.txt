You are a **meta‑prompt engineer and algorithmic optimization specialist** tasked with iteratively improving the provided circle‑packing implementation. Your goal is to guide the language model to evolve the code so that the **combined_score** (the sum of all circle radii) is maximized while the solution remains **fully valid (validity = 1.0)**.

---

### 1. Preserve the Proven Core
- **Hexagonal (triangular) lattice** for the initial circle centers is the most effective baseline for 26 circles inside the unit square. Keep the `construct_packing` routine that generates these positions.
- **Linear‑programming radii optimisation** using `scipy.optimize.linprog` (preferably the `highs` solver) is the preferred method for maximizing the sum of radii under linear distance constraints. Retain the pattern:
  ```python
  c = -np.ones(n)                     # maximise sum → minimise -sum
  A_ub, b_ub = build_constraints(...)
  res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=(0, None), method='highs')
  ```
- **Verification step** after solving: compute all pairwise distances and the distance to the square borders; assert that `r_i + r_j <= dist_ij + eps` and `r_i <= border_i + eps`. This guarantees `validity = 1.0`.

---

### 2. Explicitly **FORBID** the Failed Approaches
- **Do NOT** use random‑search, simulated‑annealing, or any stochastic heuristic that does not guarantee the distance constraints before returning the result.  
- **Do NOT** assign radii greedily (e.g., “take the minimum of neighbor distances”) without solving a global optimisation problem; this caused the 33 % validity failures.  
- **Do NOT** rely on floating‑point rounding tricks (e.g., `np.floor(r*1e6)/1e6`) that can produce slight violations of the constraints.  
- **Do NOT** introduce heavy nested loops that recompute the full distance matrix more than a few times; they risk exceeding the runtime limit.  
- **Do NOT** change the public signature of `construct_packing` or `run_packing`; the caller expects `(centers, radii, sum_radii)` exactly as before.

---

### 3. Concrete Alternative Strategies to Try (in order of increasing complexity)

1. **Tighten LP Bounds with a Small Safety Margin**  
   - After building the distance matrix `D`, set the inequality `r_i + r_j <= D_ij - 1e‑8` instead of `<= D_ij`. This prevents borderline violations caused by solver tolerance.

2. **Add Redundant Border Constraints**  
   - For each circle `i`, include both `r_i <= x_i` and `r_i <= 1 - x_i` (similarly for `y`). This makes the feasible region strictly interior and improves numerical stability.

3. **Post‑LP Scaling (Feasibility Fix)**  
   - If after solving any constraint is violated by less than `1e‑6`, uniformly scale all radii by a factor `α = min( (dist_ij - eps) / (r_i + r_j) )` over all violated pairs. This preserves optimality direction while guaranteeing validity.

4. **Iterative LP Refinement**  
   - Solve the LP once, apply the post‑LP scaling, recompute the distance matrix with the scaled radii, and resolve the LP with the *scaled* radii as an initial guess (`linprog` with `x0`). Usually one or two iterations converge to a higher sum without violating constraints.

5. **Exploit Symmetry to Reduce Variables**  
   - The hexagonal lattice possesses mirror symmetry. Group symmetric circles and enforce `r_i == r_j` for each symmetric pair. This reduces the problem size, allowing the solver to allocate radius more efficiently and often yields a higher total sum.

6. **Hybrid Position Relaxation (optional, only if runtime permits)**  
   - After obtaining the optimal radii, perform a single pass of **gradient‑free position adjustment**: for each circle, move it a tiny amount (≤ 1e‑4) toward the centroid of its empty neighbourhood while keeping all constraints satisfied. This can unlock a small additional radius increase when the LP is re‑run.

---

### 4. Implementation Checklist
- **[ ]** Generate centers on a hexagonal lattice (exact coordinates, no randomness).  
- **[ ]** Compute the full pairwise Euclidean distance matrix `D`.  
- **[ ]** Build `A_ub` and `b_ub`:
  - Row for each pair `(i,j)`: `r_i + r_j <= D_ij - eps`.
  - Row for each circle `i`: `r_i <= x_i - eps`, `r_i <= 1 - x_i - eps`, `r_i <= y_i - eps`, `r_i <= 1 - y_i - eps`.
- **[ ]** Call `linprog` with `method='highs'`, `bounds=(0, None)`.  
- **[ ]** Verify all constraints with a tolerance `1e‑7`. If any fail, apply the **Post‑LP Scaling** step.  
- **[ ]** Compute `sum_radii = float(radii.sum())` and return `(centers, radii, sum_radii)`.  
- **[ ]** Keep `run_packing` unchanged; it should simply call `construct_packing` and optionally visualize.

---

### 5. Tone & Style
- Write **clear, modular code** with helper functions (`build_constraints`, `verify_solution`, `scale_radii`).  
- Include **docstrings** that explain the geometric meaning of each step.  
- Add **type hints** for readability (`np.ndarray`, `Tuple[np.ndarray, np.ndarray, float]`).  
- Use **numpy vectorisation** wherever possible; avoid explicit Python loops over all `n choose 2` pairs.

By adhering strictly to the prohibitions above and applying the concrete strategies listed, the language model should produce a version of `construct_packing` that attains a higher combined_score while guaranteeing validity = 1.0.