# Prompt Type: B
# Outer Iteration: 3
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 3
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 6790 chars
- Current best prompt length: 8680 chars

## Convergence History:
### Successful Patterns:
- Explicit constraint mentions helped
- Change that helped: expanded by 1869 chars
- Negative guidance (what to avoid) helped
- Change that helped: expanded by 1041 chars

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9642
- Valid: 9, Invalid: 1
- Failure modes: ['Validity failures: 1/10 (10.0%)']

## CODE ANALYSIS (What Actually Happened):
## Code Analysis from Recent Iterations

*Analysis performed by LLM*

### Approaches Tried:
  - **deterministic geometric pattern** (best score: 0.3642)
    Places a large central circle and a fixed ring of circles around it using hard‑coded coordinates.
  - **grid initialization + LP radii + simple stochastic local search** (best score: 0.8852)
    Starts from a regular grid (plus a centre point), computes maximal feasible radii with a linear program, and then performs a modest random walk to improve the layout.
  - **multi‑restart stochastic search with LP radii optimization** (best score: 0.9642)
    Generates many independent random starts, repeatedly perturbs centre positions with small Gaussian moves, re‑optimises radii via a linear program each time, and keeps the best solution.

### Best Result (score: 0.9642):
  **Main Idea:** Generate many random initial centre configurations, compute the optimal radii for each configuration by solving a linear program that maximises the total radius while respecting wall and pairwise non‑overlap constraints, and iteratively refine the centres with small stochastic moves across multiple restarts, keeping the best packing found.
  **Placement:** Centres are created by jittering points from a coarse grid (or fully random) and then repeatedly applying small Gaussian perturbations; each restart works independently and the best configuration across all restarts is returned.
  **Radius:** For a fixed set of centres, a linear program maximises the sum of radii subject to: each radius ≤ distance to the nearest square side, and for every pair of circles the sum of their radii ≤ Euclidean distance between the two centres.
  **Constraints:** The linear program guarantees that all radii satisfy wall and non‑overlap constraints; after each centre move the LP is resolved, discarding any move that would make the LP infeasible.

### Score Improvements:
  - Iter 1: +0.5011 - Replaced the hand‑crafted ring layout with a grid of points and introduced LP‑based radius optimisation plus a simple random‑walk improvement.
  - Iter 10: +0.0199 - Added multi‑restart and more aggressive stochastic search, allowing the algorithm to escape local optima.
  - Iter 12: +0.079 - Switched to many small‑scale Gaussian moves per restart and refined the acceptance strategy, yielding a higher‑quality packing.

### Stuck Patterns (AVOID THESE):
  - Repeated reliance on a single deterministic initial pattern quickly plateaus at low scores.
  - Increasing the number of hyper‑parameters (e.g., temperature schedules) without systematic tuning can degrade performance, as seen after iteration 12.

### Novel Discoveries:
  - Decoupling centre placement from radius sizing via a linear program allows any centre configuration to be evaluated instantly, turning the problem into a pure optimisation over point locations.

### Error Patterns:
  - truncated_code_lines: 2 occurrences
    Likely cause: Automatic code generation cut off lines mid‑statement, producing syntactically incomplete snippets.

### Convergence Analysis:
  - Trend: improving up to iteration 12 then plateauing/declining
  - Best Score: 0.9642
  - Iterations Since Improvement: 8
  - Approach Diversity: medium

### Recommendations:
  - Introduce a global optimisation layer (e.g., differential evolution or CMA‑ES) to search the centre space before the LP step, providing more diverse high‑quality starting configurations.
  - Implement an adaptive move‑scale schedule that enlarges perturbations when progress stalls and shrinks them as the solution nears convergence, reducing premature convergence.
  - Seed the initial centres with a known dense packing pattern (hexagonal lattice or previously discovered good solutions) and then apply the LP‑based radius optimisation, leveraging domain knowledge to jump to better regions of the search space.


# ============================================
# FINAL REFINED PROMPT (seed_prompt_3):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Instructions for the Evolve Block**

**Output Requirements (must be obeyed exactly)**
- Produce **only** the Python code that belongs between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- **Do not** include the `# EVOLVE-BLOCK-START` / `# EVOLVE-BLOCK-END` markers themselves.  
- **Do not** output calls to `run_packing()` or `visualize()` – those are added automatically.  
- The surrounding code (imports, driver, visualisation, etc.) will be merged with whatever you output.  

**Function Definition Rule**
- Every function that your code calls must be **fully defined** within the block you output. No external references are allowed.

---

### What Has Proven Effective

1. **Separate centre‑position search from radius optimisation**  
   - Treat the circle centres as free variables and, for any fixed set of centres, compute the optimal radii by solving a linear program that maximises the total radius while enforcing wall‑distance and pairwise non‑overlap constraints.  
   - This decoupling lets you evaluate arbitrary centre configurations instantly and turn the overall problem into a pure optimisation over point locations.

2. **Stochastic local search with adaptive step size**  
   - Start from a diverse set of centre configurations (e.g., jittered grid points, hexagonal lattice seeds, or random points).  
   - Repeatedly perturb the centres with small Gaussian moves, resolve the linear‑program for radii, and keep the move only if the new total radius improves.  
   - Adapt the perturbation scale: enlarge it when progress stalls, shrink it as the solution nears convergence. This helps escape local optima while allowing fine‑grained refinement.

3. **Multi‑restart strategy**  
   - Run many independent searches in parallel (or sequentially) with different random seeds or different initial patterns.  
   - Keep the best packing found across all restarts. This provides robustness against unlucky initialisation.

4. **Informed seeding**  
   - Initialise some searches with known dense patterns such as a hexagonal lattice or previously discovered good solutions.  
   - Combining domain‑knowledge seeds with the stochastic refinement often jumps to higher‑quality regions of the search space.

5. **Optional global optimiser layer**  
   - Before the local search, you may apply a population‑based optimiser (e.g., differential evolution, CMA‑ES) to explore the centre space globally.  
   - Use the optimiser’s candidates as starting points for the LP‑based radius optimisation and subsequent local refinement.

---

### What to Avoid

- **Purely deterministic geometric patterns** (fixed rings, single‑grid layouts) – they quickly plateau and cannot reach high packing densities.  
- **Excessive hyper‑parameter tuning without systematic control** – adding many unrelated parameters (e.g., complex temperature schedules) tends to degrade performance and increase code length without benefit.  
- **Leaving any function call undefined** – every helper you invoke must be fully implemented inside the evolve block, otherwise the merged program will raise a `NameError`.  
- **Generating code that is truncated or syntactically incomplete** – ensure all statements are complete and properly indented.

---

### Guidance for Implementation

- **Linear‑program formulation**: For each centre `c_i`, constrain its radius `r_i` by  
  `r_i ≤ min(distance to left wall, distance to right wall, distance to bottom wall, distance to top wall)`.  
  For every pair `(i, j)`, add the constraint `r_i + r_j ≤ ‖c_i - c_j‖`.  
  Maximise `∑ r_i`. Use `scipy.optimize.linprog` (already available) or any LP solver you import.

- **Perturbation logic**: Generate a candidate centre set by adding `σ * np.random.randn(num_circles, 2)` to the current centres, where `σ` is the current step size. After solving the LP, accept the move only if the objective value increased.

- **Adaptive step‑size schedule**: Monitor the number of accepted moves in the last `k` iterations. If few moves are accepted, increase `σ` (up to a reasonable maximum). If many moves improve the objective, decrease `σ` to fine‑tune.

- **Restart handling**: Encapsulate the whole search (initialisation → local refinement) into a function that returns the best packing found for that run. Loop over the desired number of restarts and keep the overall best result.

- **Result packaging**: Return a data structure (e.g., a tuple of centre array and radius array) that the outer driver expects.

Follow these directions while respecting the strict output format and function‑definition rules. Your code will replace the existing evolve block and be merged with the surrounding infrastructure automatically. Good luck!

---

## Code Analysis from Recent Iterations

*Analysis performed by LLM*

### Approaches Tried:
  - **deterministic geometric pattern** (best score: 0.3642)
    Places a large central circle and a fixed ring of circles around it using hard‑coded coordinates.
  - **grid initialization + LP radii + simple stochastic local search** (best score: 0.8852)
    Starts from a regular grid (plus a centre point), computes maximal feasible radii with a linear program, and then performs a modest random walk to improve the layout.
  - **multi‑restart stochastic search with LP radii optimization** (best score: 0.9642)
    Generates many independent random starts, repeatedly perturbs centre positions with small Gaussian moves, re‑optimises radii via a linear program each time, and keeps the best solution.

### Best Result (score: 0.9642):
  **Main Idea:** Generate many random initial centre configurations, compute the optimal radii for each configuration by solving a linear program that maximises the total radius while respecting wall and pairwise non‑overlap constraints, and iteratively refine the centres with small stochastic moves across multiple restarts, keeping the best packing found.
  **Placement:** Centres are created by jittering points from a coarse grid (or fully random) and then repeatedly applying small Gaussian perturbations; each restart works independently and the best configuration across all restarts is returned.
  **Radius:** For a fixed set of centres, a linear program maximises the sum of radii subject to: each radius ≤ distance to the nearest square side, and for every pair of circles the sum of their radii ≤ Euclidean distance between the two centres.
  **Constraints:** The linear program guarantees that all radii satisfy wall and non‑overlap constraints; after each centre move the LP is resolved, discarding any move that would make the LP infeasible.

### Score Improvements:
  - Iter 1: +0.5011 - Replaced the hand‑crafted ring layout with a grid of points and introduced LP‑based radius optimisation plus a simple random‑walk improvement.
  - Iter 10: +0.0199 - Added multi‑restart and more aggressive stochastic search, allowing the algorithm to escape local optima.
  - Iter 12: +0.079 - Switched to many small‑scale Gaussian moves per restart and refined the acceptance strategy, yielding a higher‑quality packing.

### Stuck Patterns (AVOID THESE):
  - Repeated reliance on a single deterministic initial pattern quickly plateaus at low scores.
  - Increasing the number of hyper‑parameters (e.g., temperature schedules) without systematic tuning can degrade performance, as seen after iteration 12.

### Novel Discoveries:
  - Decoupling centre placement from radius sizing via a linear program allows any centre configuration to be evaluated instantly, turning the problem into a pure optimisation over point locations.

### Error Patterns:
  - truncated_code_lines: 2 occurrences
    Likely cause: Automatic code generation cut off lines mid‑statement, producing syntactically incomplete snippets.

### Convergence Analysis:
  - Trend: improving up to iteration 12 then plateauing/declining
  - Best Score: 0.9642
  - Iterations Since Improvement: 8
  - Approach Diversity: medium

### Recommendations:
  - Introduce a global optimisation layer (e.g., differential evolution or CMA‑ES) to search the centre space before the LP step, providing more diverse high‑quality starting configurations.
  - Implement an adaptive move‑scale schedule that enlarges perturbations when progress stalls and shrinks them as the solution nears convergence, reducing premature convergence.
  - Seed the initial centres with a known dense packing pattern (hexagonal lattice or previously discovered good solutions) and then apply the LP‑based radius optimisation, leveraging domain knowledge to jump to better regions of the search space.


