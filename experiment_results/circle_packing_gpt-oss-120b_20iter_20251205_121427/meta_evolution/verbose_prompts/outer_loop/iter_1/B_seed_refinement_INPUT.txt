# Prompt Type: B
# Outer Iteration: 1
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 1
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 4155 chars
- Current best prompt length: 4566 chars

## Convergence History:
### Successful Patterns:
- Negative guidance (what to avoid) helped
- Explicit constraint mentions helped

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9645
- Valid: 13, Invalid: 0
- Failure modes: []

## CODE ANALYSIS (What Actually Happened):
## Code Analysis from Recent Iterations

### Approaches Tried:
  ‚úì linear_programming: 4 attempts
  ‚úì grid_based: 4 attempts
  ‚úì iterative_refinement: 4 attempts
  ‚úì constraint_solving: 3 attempts
  ‚úì random_search: 2 attempts

### Best Performing Approach: linear_programming
Key techniques in best code:
  - LP for radius optimization
  - pairwise distance constraints
  - boundary constraint handling

### What Led to Improvements:
  - Iter 0: +0.3642 using linear_programming, grid_based
  - Iter 1: +0.4538 using linear_programming, grid_based
  - Iter 2: +0.1465 using linear_programming, grid_based

### Recommendations for Next Prompt:
  - BUILD ON: linear_programming has been successful - refine and extend this approach
  - KEEP: Best improvement used: LP for radius optimization, pairwise distance constraints, position perturbation

# ============================================
# FINAL REFINED PROMPT (seed_prompt_1):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt ‚Äì Code Evolution Guidance**

---

### üìå CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
- **Output ONLY the code that belongs between** `# EVOLVE-BLOCK-START` **and** `# EVOLVE-BLOCK-END`.
- **Do NOT include** the `# EVOLVE-BLOCK-START` / `# EVOLVE-BLOCK-END` markers themselves.
- **Do NOT include** calls to `run_packing()` or `visualize()` ‚Äì those are preserved automatically.
- The system will merge your output with the surrounding code automatically.

### üì¶ IMPORTS
- You may add additional `import` statements if needed (e.g., `from scipy.optimize import minimize`).
- `import numpy as np` and `from scipy.optimize import linprog` are already available in the surrounding scope.

### üéØ FOCUS
- **Improve only** the `construct_packing()` function and any helper functions it uses.  
- You may create new helper functions, but they must be called (directly or indirectly) from `construct_packing()`.
- Do **not** modify `run_packing()` or `visualize()`.

### ‚úÖ WHAT TO BUILD ON (PROVEN SUCCESS)
1. **Linear Programming (LP) radius optimization** ‚Äì the best-performing approach so far.  
2. **Explicit pair‚Äëwise distance constraints** (‚Äñc_i‚Äëc_j‚Äñ¬†‚â•¬†r_i¬†+¬†r_j).  
3. **Boundary constraints** (r_i¬†‚â§¬†min(x_i,‚ÄØ1‚Äëx_i,‚ÄØy_i,‚ÄØ1‚Äëy_i)).  
4. **Position perturbation / grid seeding** ‚Äì start from a regular grid or hexagonal lattice, then slightly jitter points to improve feasibility before solving the LP.  
5. **Negative guidance** works well: explicitly state constraints that must *not* be violated.

### üö´ WHAT TO AVOID (FAILED OR INEFFICIENT APPROACHES)
- Pure **random search** or Monte‚ÄëCarlo placement without a deterministic refinement step.  
- **Brute‚Äëforce enumeration** of all possible center permutations.  
- Heavy **iterative refinement loops** that do not incorporate a convex optimization step (they added runtime without improving the score).  
- Any approach that **omits explicit boundary or non‚Äëoverlap constraints** ‚Äì the evaluator will reject such solutions.

### üõ†Ô∏è RECOMMENDATIONS FOR THE NEXT ITERATION
- **Keep the LP core** but improve the formulation:
  * Use a tighter objective, e.g., maximize the sum of radii (`c = -np.ones(n)`) or a weighted combination that rewards larger total area.
  * Add a small slack variable to allow the solver to relax constraints minimally if needed, then post‚Äëprocess to enforce feasibility.
- **Generate a high‚Äëquality initial layout**:
  * Start with a hexagonal close‚Äëpacking pattern scaled to fit the unit square.
  * Apply a deterministic jitter (e.g., sinusoidal offset) to break symmetry and give the LP more freedom.
- **Validate before returning**:
  * After solving, run a quick check that all circles satisfy the boundary and non‚Äëoverlap constraints; if any violation is detected, fall back to a simple safe layout (e.g., uniform grid with small radii) to preserve `validity = 1.0`.
- **Optional helper functions** you may add:
  * `_hexagonal_grid(n)` ‚Äì returns `n` centers arranged in a hexagonal lattice within the unit square.
  * `_solve_radius_lp(centers)` ‚Äì builds and solves the LP, returning radii or `None` on failure.
  * `_verify_packing(centers, radii)` ‚Äì returns `True` if the configuration is valid.

### üìã SUMMARY OF REQUIRED OUTPUT
Provide **only** the Python code that will replace the contents between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
Do **not** include any surrounding markers, `run_packing()`, or `visualize()` calls.

---
