"""
Deterministic hexagonal‑lattice circle packing for n = 26.

The idea
--------
1. Choose the *largest* possible lattice spacing `s` such that a
   hexagonal (triangular) lattice with a margin of `s/2` from the square
   borders still contains at least 26 points.
2. With that spacing the distance from every centre to the four sides of the
   unit square is at least `s/2`.  The nearest‑neighbour distance of the
   lattice is exactly `s`, therefore the maximal admissible radius for every
   circle is `s/2`.
3. The construction is completely deterministic, uses only NumPy and a
   tiny binary‑search loop, and returns the exact maximal radii for the
   chosen centres.

Because the radii are all equal to `s/2`, the sum of radii is simply
`13 * s`.  Maximising `s` therefore directly maximises the fitness
(`sum_radii`) while keeping the packing perfectly valid.
"""

import numpy as np

# ----------------------------------------------------------------------
# Helper: generate the centred hexagonal lattice for a given spacing `s`
# ----------------------------------------------------------------------
def _generate_centres(s: float) -> np.ndarray:
    """
    Generate points of a hexagonal lattice inside the unit square
    with a margin of `s/2` from every side.

    Parameters
    ----------
    s : float
        Lattice spacing (horizontal distance between adjacent points).

    Returns
    -------
    np.ndarray, shape (m, 2)
        All lattice points that satisfy the margin condition.
    """
    margin = s / 2.0
    dy = s * np.sqrt(3.0) / 2.0                     # vertical step

    # y‑coordinates of rows (starting at the lower margin)
    y_vals = np.arange(margin, 1.0 - margin + 1e-12, dy)

    points = []
    for row_idx, y in enumerate(y_vals):
        # staggered rows: even rows start at `margin`,
        # odd rows are shifted by `s/2`
        offset = 0.0 if (row_idx % 2 == 0) else s / 2.0
        x_start = margin + offset
        x_vals = np.arange(x_start, 1.0 - margin + 1e-12, s)
        for x in x_vals:
            points.append((x, y))

    return np.array(points, dtype=np.float64)


# ----------------------------------------------------------------------
# Find the maximal spacing that still yields at least 26 points
# ----------------------------------------------------------------------
def _optimal_spacing(min_s: float = 0.05, max_s: float = 0.60,
                     target_n: int = 26, eps: float = 1e-7) -> float:
    """
    Binary‑search for the largest spacing `s` such that the lattice
    generated by `_generate_centres(s)` contains at least `target_n`
    points.

    The search is deterministic and stops when the interval width is
    smaller than `eps`.
    """
    low, high = min_s, max_s
    best = low

    for _ in range(50):                     # enough iterations for 1e‑7 precision
        mid = (low + high) / 2.0
        cnt = _generate_centres(mid).shape[0]

        if cnt >= target_n:                 # we can afford a larger spacing
            best = mid
            low = mid
        else:
            high = mid

        if high - low < eps:
            break

    return best


# ----------------------------------------------------------------------
# Public API required by the evaluator
# ----------------------------------------------------------------------
def construct_packing():
    """
    Build a packing of 26 circles inside the unit square.

    Returns
    -------
    centres : np.ndarray, shape (26, 2)
        (x, y) coordinates of the circle centres.
    radii   : np.ndarray, shape (26,)
        Radii that satisfy the non‑overlap and boundary constraints.
    sum_radii : float
        Sum of all radii (the quantity we try to maximise).
    """
    # 1️⃣  Determine the best possible spacing.
    spacing = _optimal_spacing()

    # 2️⃣  Generate the full lattice and keep the first 26 points.
    all_centres = _generate_centres(spacing)
    if all_centres.shape[0] < 26:
        raise RuntimeError("Unexpected: not enough points after spacing optimisation.")
    centres = all_centres[:26]

    # 3️⃣  Radii are simply `spacing/2` for every centre.
    radii = compute_max_radii(centres)

    # 4️⃣  Return results.
    sum_radii = float(np.sum(radii))
    return centres, radii, sum_radii


def compute_max_radii(centres: np.ndarray) -> np.ndarray:
    """
    Return the maximal admissible radii for the supplied centres.
    For the lattice constructed by `construct_packing` the answer is
    exactly `spacing/2`, but we recompute it from first principles to stay
    fully general and to keep the function self‑contained.

    Parameters
    ----------
    centres : np.ndarray, shape (n, 2)
        Coordinates of the circle centres.

    Returns
    -------
    np.ndarray, shape (n,)
        Maximal admissible radii (all > 0).
    """
    # distance to the four sides of the unit square
    boundary = np.minimum.reduce(
        [
            centres[:, 0],               # left
            centres[:, 1],               # bottom
            1.0 - centres[:, 0],         # right
            1.0 - centres[:, 1],         # top
        ]
    )

    # pairwise centre distances
    diff = centres[:, np.newaxis, :] - centres[np.newaxis, :, :]   # (n, n, 2)
    dists = np.sqrt(np.sum(diff ** 2, axis=2))                  # (n, n)
    np.fill_diagonal(dists, np.inf)                            # ignore self‑distance
    nearest = np.min(dists, axis=1)                             # closest neighbour

    # maximal admissible radius for each circle
    radii = np.minimum(boundary, nearest / 2.0)

    # safety against numerical under‑flow – all radii must be strictly positive
    eps = 1e-12
    radii = np.maximum(radii, eps)

    return radii


# ----------------------------------------------------------------------
# Fixed helper code – unchanged by the evolutionary process.
# ----------------------------------------------------------------------
def run_packing():
    """Run the circle packing constructor for n=26."""
    centres, radii, sum_radii = construct_packing()
    return centres, radii, sum_radii


def visualize(centres, radii):
    """
    Visualise the packing using Matplotlib.

    Parameters
    ----------
    centres : np.ndarray, shape (n, 2)
        Circle centres.
    radii   : np.ndarray, shape (n,)
        Circle radii.
    """
    import matplotlib.pyplot as plt
    from matplotlib.patches import Circle

    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_aspect("equal")
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.set_title(f"Optimised hexagonal packing (n={len(centres)}, sum={np.sum(radii):.6f})")
    ax.grid(True)

    for i, (c, r) in enumerate(zip(centres, radii)):
        circ = Circle(c, r, edgecolor="black", facecolor="C0", alpha=0.5)
        ax.add_patch(circ)
        ax.text(c[0], c[1], str(i), ha="center", va="center", color="white")

    plt.show()


if __name__ == "__main__":
    centres, radii, sum_radii = run_packing()
    print(f"Sum of radii: {sum_radii:.6f}")
    # Uncomment to visualise the result:
    # visualize(centres, radii)