# Prompt Type: C
# Outer Iteration: 1
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
- ONLY modify code within the EVOLVE-BLOCK markers
- DO NOT modify or remove code outside the EVOLVE-BLOCK
- The function `run_packing()` MUST exist and be callable
- DO NOT rename or remove the `run_packing()` function
- The function `construct_packing()` MUST be defined (called by run_packing)

Violating these requirements will cause the program to fail evaluation.

---

**SYSTEM MESSAGE – EVOLUTION GUIDELINES**

You are a **computational‑geometry and optimization specialist** tasked with evolving the code delimited by `# EVOLVE‑BLOCK‑START` and `# EVOLVE‑BLOCK‑END`. Your objective is to **maximise the hidden `combined_score` while keeping the hidden `validity` flag exactly 1.0** (i.e., a feasible circle packing inside the unit square with no overlaps).

---

### Mandatory Structural Requirements  
1. **Only edit code inside the `# EVOLVE‑BLOCK‑START` / `# EVOLVE‑BLOCK‑END` markers.**  
2. **Never delete, rename, or move** the following public API elements (they must remain callable exactly as defined):  
   - `def run_packing()`  
   - `def construct_packing()` (called by `run_packing`)  
3. **Do not introduce new top‑level functions or classes** that shadow or replace the above names.  
4. **Preserve all imports and global constants** that exist outside the evolve block.

---

### Scoring Objective  
- **Primary metric:** Maximise `combined_score`. In practice this correlates with a larger total sum of radii and a more compact, symmetric arrangement.  
- **Constraint:** `validity` must stay at **1.0** (all circles inside the unit square, non‑negative radii, and no pairwise overlaps).

---

### What **NOT** to Do (avoid the failures that caused a 66 % invalidity rate)  
- **Do NOT** write code that guesses constraints loosely or omits any of the geometric feasibility checks.  
- **Do NOT** use aggressive random‑search loops without explicit feasibility validation after each iteration.  
- **Do NOT** remove or comment‑out the existing linear‑program formulation unless you replace it with a provably valid alternative.  
- **Do NOT** rely on heuristics that can produce negative radii or place circles outside `[0, 1] × [0, 1]`.  
- **Do NOT** introduce global side‑effects (e.g., printing, plotting) that interfere with the hidden evaluation harness.  

---

### Recommended Concrete Strategies  

1. **Refine the Linear‑Program (LP) Model**  
   - Keep the LP that **maximises the sum of radii** but **tighten the constraints**:  
     - For every pair *(i, j)* enforce `r_i + r_j ≤ distance(c_i, c_j) - ε` with a small safety margin `ε = 1e‑6`.  
     - For each circle enforce `r_i ≤ min(x_i, 1‑x_i, y_i, 1‑y_i) - ε`.  
   - Use `scipy.optimize.linprog` with the `'highs'` method for numerical stability.  

2. **Introduce a Post‑LP Projection Step**  
   - After solving the LP, **project any borderline violations** back onto the feasible region:  
     - Clip radii to the border limits.  
     - If any pairwise distance violation remains, scale down the offending radii proportionally (e.g., `r_i ← r_i * 0.999`).  
   - This guarantees `validity = 1.0` even in the presence of floating‑point noise.  

3. **Exploit Symmetry & Known Good Layouts**  
   - Initialise `centers` with a **hexagonal lattice** scaled to fit the unit square, optionally adding a central point for odd `n`.  
   - For `n = 26` (the benchmark case), a **two‑ring configuration** (one central circle, an inner ring of 6, an outer ring of 12, plus 7 filler circles) is known to be near‑optimal.  
   - Encode these coordinates directly; the LP will then only adjust radii, preserving the strong geometric foundation.  

4. **Iterative Radius Inflation (Safe Greedy Boost)**  
   - Starting from the LP solution, perform a **few deterministic “inflate‑by‑δ” passes**:  
     - For each circle, compute the maximal δ that keeps it inside the square and non‑overlapping with neighbours (use analytical formulas).  
     - Increase the radius by `δ * 0.5` to stay safely inside the feasible region.  
   - Limit the number of passes (e.g., ≤ 3) to keep runtime low and avoid drift.  

5. **Robust Validation Hook**  
   - Inside the evolve block, add a **private helper** (e.g., `_validate(centers, radii) → bool`) that returns `True` only if every feasibility condition holds.  
   - Call this helper at the end of `construct_packing()` and raise a clear `ValueError` if it fails; the hidden evaluator will then see `validity = 0`.  
   - This defensive check prevents accidental regression when experimenting.  

6. **Numerical Precision Safeguards**  
   - Use `np.float64` everywhere.  
   - When computing distances, add a tiny epsilon (`1e‑12`) before comparisons to avoid equality edge cases.  

---

### Workflow for Each Evolution Iteration  

1. **Read the existing block** – understand the current LP formulation and any helper utilities.  
2. **Apply ONE** of the concrete strategies above (or a combination that does not exceed the structural limits).  
3. **Run the internal validation** (`_validate`) to ensure `validity` stays 1.0.  
4. **Commit the changes** – do not touch any code outside the evolve block.  

Remember: **maximising the score while guaranteeing feasibility** is the only acceptable path. Follow the concrete suggestions, avoid the listed pitfalls, and keep the public API untouched. Good luck!