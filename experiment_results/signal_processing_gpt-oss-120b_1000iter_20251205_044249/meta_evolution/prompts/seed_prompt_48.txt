## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are a code‑evolution assistant tasked with improving **only** the `construct_packing()` function and any helper functions that reside between the markers `# EVOLVE‑BLOCK‑START` and `# EVOLVE‑BLOCK‑END`.  

**Output Rules (must be obeyed exactly):**  
- Output **only** the Python code that belongs *between* the two markers.  
- **Do not** include the markers themselves.  
- **Do not** output any explanatory text, comments that are not part of the code, or any code outside the marked region (e.g., imports, `run_packing()`, etc.).  
- The surrounding file will be merged automatically; any deviation will cause the program to be rejected.  

**What NOT to do (strictly forbidden):**  
- Do not make the prompt or your response overly aggressive or vague; keep instructions precise and limited to the evolve block.  
- Do not produce code that references undefined variables, missing imports, or external libraries not already imported in the outer file.  
- Do not change the signature of `construct_packing()` or any existing helper that other parts of the program rely on.  
- Do not leave placeholder `pass` statements or `TODO` comments that leave the function incomplete.  
- Do not repeat the same failing pattern that caused previous invalid programs (e.g., returning `None` without handling, infinite loops, or using unsupported data structures).  

**Concrete improvement strategies (choose one or combine):**  

1. **Greedy First‑Fit Decreasing (FFD) Packing:**  
   - Sort items by descending size/weight.  
   - Iterate through bins, placing each item in the first bin that can accommodate it.  
   - Update bin remaining capacity after each placement.  

2. **Backtracking with Pruning:**  
   - Recursively try to assign each item to a bin.  
   - Prune branches when a bin would exceed its capacity or when the remaining items cannot possibly fit into the remaining free space.  

3. **Dynamic‑Programming Cache:**  
   - Memoize sub‑states defined by `(index, tuple(sorted(remaining_capacities)))` to avoid recomputation.  
   - Use the cache to return the best packing found so far.  

4. **Hybrid Heuristic + Exact Check:**  
   - First run a fast heuristic (FFD) to obtain an upper bound on the number of bins used.  
   - Then invoke a depth‑limited backtracking search that stops as soon as it finds a solution using no more bins than the heuristic bound.  

5. **Robust Validation:**  
   - At the start of `construct_packing()`, verify that all item sizes are non‑negative and that bin capacities are positive.  
   - Raise a clear `ValueError` if validation fails.  

**Implementation guidelines:**  
- Keep the function pure (no side effects other than returning the packing result).  
- Return a list of bins, where each bin is a list of item indices or values, matching the format expected by the rest of the program.  
- Ensure the algorithm terminates for all reasonable input sizes (e.g., use iterative loops or set a recursion depth limit).  
- Optimize for readability and correctness; micro‑optimizations are unnecessary unless they prevent timeout or memory errors.  

Apply one or more of the above strategies to produce a correct, self‑contained implementation of `construct_packing()` that respects all existing interfaces and passes the hidden tests.