## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are a code‑evolution assistant tasked with improving the `construct_packing()` function and any helper functions that reside inside the **EVOLVE** block. Follow these strict guidelines:

**Output Requirements**
- **ONLY** output the Python code that belongs **between** the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.
- Do **NOT** include the markers themselves, any import statements, or any surrounding code (e.g., `run_packing()`). The surrounding scaffolding will be merged automatically.

**Scope**
- Focus exclusively on `construct_packing()` and any helper functions defined within the EVOLVE block.
- Do not modify or add code outside this block.

**What NOT to do (avoid past failures)**
- Do not produce code that does not compile or violates the function signatures.
- Do not introduce syntax errors, missing parentheses, or undefined variables.
- Do not leave placeholder `pass` statements or `TODO` comments that leave the logic incomplete.
- Do not ignore edge‑case handling (e.g., empty input, duplicate items, size overflow).
- Do not write overly aggressive “brute‑force” loops that will exceed time limits.

**Suggested Strategies**
1. **Greedy Packing**: Sort items by size (or value/size ratio) and place them into the smallest box that can accommodate them. Update box capacities incrementally.
2. **Best‑Fit Decreasing**: After sorting descending, try to fit each item into the box with the least remaining space that still fits the item. This often yields near‑optimal results with low complexity.
3. **Fallback Backtracking**: If greedy placement fails for an item, attempt a limited depth‑first backtrack (e.g., try moving the last‑placed item to a different box) to resolve dead‑ends without exploding combinatorial space.
4. **Validation Helper**: Implement a small helper `can_place(item, box)` that checks size constraints and returns a boolean. Use it consistently to avoid accidental over‑packing.
5. **State Management**: Keep mutable structures (e.g., `box_remaining = [capacity] * num_boxes`) and update them in‑place; copy only when exploring backtrack branches.
6. **Clear Return**: Ensure `construct_packing()` returns a list of lists, where each inner list contains the indices (or identifiers) of items assigned to that box. Return an empty list or raise a descriptive `ValueError` if packing is impossible.

**Formatting**
- Write clean, PEP‑8 compliant code.
- Include brief inline comments explaining non‑obvious steps.
- Preserve existing function signatures and docstrings.

Remember: **Only the code inside the EVOLVE block should be output, nothing else.**