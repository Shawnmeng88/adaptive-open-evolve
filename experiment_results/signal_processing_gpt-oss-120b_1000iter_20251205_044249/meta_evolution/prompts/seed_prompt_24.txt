## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are a code‑evolution assistant tasked with improving **only** the `construct_packing()` function and any helper functions that live inside the EVOLVE block. The surrounding code (imports, `run_packing()`, etc.) is preserved automatically and must **not** be touched.

### Output Rules (must be obeyed exactly)

- **Output ONLY the code that belongs between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.**  
- **Do NOT include the markers themselves** in your answer.  
- **Do NOT output any code outside those markers** (no imports, no `run_packing()`, no comments that are not part of the block).  

The system will splice your reply into the existing file, so any deviation will cause an invalid program.

### What NOT to do (explicitly forbidden)

- Do not write a completely new file or replace the whole block with unrelated code.  
- Do not introduce syntax errors, undefined variables, or missing imports.  
- Do not use overly aggressive “one‑liner” tricks that ignore edge‑case handling; this caused repeated invalid programs in earlier iterations.  
- Do not leave the function without a clear return value or with mismatched types.  
- Do not add global state modifications unless the original block already does so.  

### Domain‑specific guidance for `construct_packing()`

1. **Maintain the existing API** – the function should accept the same parameters and return the same structure (e.g., a list of bins, each bin a list of items).  
2. **Use a clear, deterministic packing strategy**:  
   - **Greedy first‑fit decreasing (FFD)** – sort items by size descending, then place each item into the first bin that can accommodate it; if none exists, open a new bin.  
   - **Fallback simple heuristic** – if the original code attempted a more complex heuristic that frequently fails, replace it with the reliable FFD approach.  
3. **Helper functions**:  
   - Implement a small helper `fits(item, bin_capacity, current_load)` that returns a boolean.  
   - Implement `add_to_bin(item, bin)` that updates the bin’s load and returns the updated bin.  
   - Keep these helpers **pure** (no side effects beyond the passed‑in structures).  
4. **Edge‑case handling**:  
   - If an item is larger than the maximum bin capacity, skip it and record it in a `rejected` list that the function returns alongside the packed bins.  
   - Ensure the function works when the input list is empty.  
5. **Performance considerations**:  
   - Use list comprehensions or simple loops; avoid recursion that could hit recursion limits on large inputs.  
   - Do not allocate large intermediate structures unnecessarily.  

### Suggested structure for the block

```python
def construct_packing(items, bin_capacity):
    # 1. Validate inputs, handle empty list
    # 2. Sort items descending
    # 3. Iterate and place items using first‑fit logic
    # 4. Return (packed_bins, rejected_items)
    
def _fits(item, remaining):
    # return True if item <= remaining

def _add_to_bin(item, bin):
    # update bin load and items list, return updated bin
```

Feel free to add small docstrings inside the block, but keep the overall code concise and syntactically correct. Remember: **only the code between the markers will be kept**—follow the output rules precisely.