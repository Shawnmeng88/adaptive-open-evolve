## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Code Evolution for `construct_packing()`**

You are tasked with improving the `construct_packing()` function (and any helper functions defined inside the evolve block). Follow these rules exactly:

1. **Output Restrictions**  
   - **Only** output the Python statements that belong **between** the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
   - **Do NOT** include the markers themselves.  
   - **Do NOT** output any import statements, the surrounding `run_packing()` wrapper, or any other code outside the evolve block. The surrounding framework will be merged automatically.

2. **What to Change**  
   - Refactor `construct_packing()` to produce a correct, efficient packing plan for the given items and container constraints.  
   - You may add or modify helper functions **inside** the evolve block, but they must be referenced only from within `construct_packing()`.  
   - Preserve the existing function signatures; do not rename parameters or return types.

3. **Forbidden Approaches (must be avoided)**  
   - Writing overly aggressive or vague logic that ignores the problem constraints (e.g., “try random placements until it works”).  
   - Leaving placeholders, `TODO` comments, or raising `NotImplementedError`.  
   - Producing code that will raise exceptions for any valid input (e.g., division by zero, index errors).  
   - Re‑introducing the same bugs that caused the previous 13/13 invalid runs (such as undefined variables, mismatched return values, or missing imports).  

4. **Concrete Strategies to Try**  
   - **Greedy First‑Fit Decreasing**: Sort items by volume (or a weighted size metric) descending, then place each item into the first container that still has enough remaining capacity.  
   - **Bin‑Packing Heuristics**: Implement a simple “Best‑Fit” where you compute the remaining free space of each container and choose the container that leaves the smallest leftover after placement.  
   - **Capacity Checks**: Before adding an item, explicitly verify that `current_weight + item.weight <= max_weight` **and** `current_volume + item.volume <= max_volume`. Abort placement for that container if either check fails.  
   - **Deterministic Loop**: Use a `for` loop over items and a nested `for` loop over containers; avoid recursion or random sampling which can cause nondeterministic failures.  
   - **Return Structure**: Ensure the function returns a list (or dict) exactly matching the expected format used by `run_packing()`. Typically this is a list of containers, each containing a list of placed item IDs.  

5. **Testing Mindset**  
   - After writing the new logic, mentally walk through a small example (e.g., 3 items, 2 containers) to confirm that every item is either placed correctly or skipped without causing an error.  
   - Verify that the final return value is always defined, even if no items fit.  

**Remember:** The only permissible output is the code inside the evolve block, adhering strictly to the format above. Any deviation will be rejected. Good luck!