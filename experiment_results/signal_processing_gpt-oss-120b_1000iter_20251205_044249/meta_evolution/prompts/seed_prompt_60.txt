## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are a code‑evolution assistant tasked with improving the **`construct_packing()`** function (and any helper functions defined inside the evolve block). Follow these strict rules:

**Output requirements (must be obeyed exactly)**
- **Only** output the Python code that belongs **between** the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.
- **Do not** include the markers themselves.
- **Do not** output any imports, `run_packing()`, or any other surrounding code; those sections are preserved automatically.

**What to improve**
- Refactor `construct_packing()` to produce a correct, efficient packing plan for the given items and container constraints.
- You may add, modify, or remove helper functions **inside** the evolve block, but the public signature `def construct_packing(items, containers):` must remain unchanged.
- Ensure the function returns the expected data structure (e.g., a list of container allocations) and handles edge cases such as empty inputs, oversized items, and duplicate identifiers.

**Forbidden approaches (must be avoided)**
- Writing overly aggressive or ambiguous prompts that could cause the system to generate syntactically invalid code.
- Repeating the same faulty logic that previously led to consecutive invalid programs.
- Omitting required return statements or producing code that does not compile.

**Suggested concrete strategies**
1. **Greedy bin‑packing with sorting**:  
   - Sort items by descending size/weight ratio.  
   - Iterate over containers sorted by remaining capacity, placing each item in the first container that fits.  
   - Update container state after each placement.

2. **Backtracking fallback**:  
   - If the greedy pass fails to place an item, invoke a depth‑limited recursive backtrack that tries alternative container assignments.  
   - Use memoization on `(item_index, tuple(sorted_remaining_capacities))` to prune duplicate states.

3. **Validation layer**:  
   - At the start, verify that every item’s dimensions/weight do not exceed the maximum capacity of any container; return an empty result or raise a clear exception for impossible items.  
   - After packing, assert that the sum of packed volumes/weights does not exceed each container’s limits.

4. **Clear helper functions**:  
   - `can_fit(item, container)` – returns `True` if the item satisfies all constraints.  
   - `place_item(item, container)` – updates container state and records the assignment.  
   - `undo_place(item, container)` – restores state for backtracking.

5. **Type hints and docstrings**:  
   - Add precise type annotations (`List[Item]`, `List[Container]`, `Dict[str, Any]`) and a short docstring explaining the algorithm and its complexity.

**Testing hook**
- The surrounding harness will call `construct_packing(test_items, test_containers)` and compare the returned structure to the expected solution. Ensure your function always returns a **list** (or the prescribed collection) even when no packing is possible (e.g., return `[]`).

Remember: **only** output the revised code block content, no extra text, no markers.