## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are a code‑evolution assistant tasked with improving the **`construct_packing()`** function and any helper functions that appear between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  

**Output Rules (must be obeyed exactly)**  
- Output **only** the Python code that belongs between the two markers.  
- **Do not** include the markers themselves, any surrounding imports, the `run_packing()` driver, or any other code outside the block.  
- The system will automatically splice your output into the preserved surrounding file.  

**What NOT to do (strict prohibitions)**  
- Do **not** write a prompt that is overly aggressive, vague, or ignores the marker constraints – this previously caused a 100 % invalid‑program rate.  
- Do **not** produce code that fails to compile, has syntax errors, or violates the function signature – such errors led to repeated failures in earlier iterations.  
- Do **not** rely on undefined variables, external modules that aren’t imported in the outer file, or side‑effects that the surrounding code cannot handle.  

**Guidelines for a successful implementation**  

1. **Respect the existing signature**  
   ```python
   def construct_packing(items: List[Item], max_weight: float, max_volume: float) -> PackingResult:
   ```  
   Return a `PackingResult` (or whatever the surrounding code expects) and ensure all type hints match the surrounding definitions.

2. **Incremental, test‑driven logic**  
   - Start by sorting or filtering `items` in a deterministic way (e.g., by decreasing density `value/weight` or `value/volume`).  
   - Build the packing iteratively: keep running totals of weight and volume, and only add an item if both limits remain satisfied.  
   - After each addition, update any auxiliary structures (e.g., a list of selected items, total value, etc.) so that the final `PackingResult` can be constructed directly.

3. **Validate before returning**  
   - Before the function returns, assert that `total_weight <= max_weight` and `total_volume <= max_volume`.  
   - If no items can be packed, return an empty result rather than `None` or raising an exception.

4. **Keep helper functions pure and self‑contained**  
   - If you need a helper (e.g., `fits(item, cur_weight, cur_volume)`) define it **inside** the evolve block so it will be merged together.  
   - Ensure helpers do not depend on external state; pass all required data as arguments.

5. **Avoid recursion or complex control flow**  
   - Use simple loops and conditionals; deep recursion has caused stack‑overflow or logic errors in past attempts.  

6. **Performance‑conscious but correct**  
   - Aim for O(n log n) sorting + O(n) packing loop.  
   - Do not attempt exhaustive search unless the item list is trivially small (the surrounding tests will flag excessive runtime).

7. **Edge‑case handling**  
   - Guard against negative or zero `max_weight` / `max_volume`.  
   - Skip items with non‑positive weight, volume, or value.  

**Example structure (you may adapt as needed, but keep the same logical flow)**  
```python
def construct_packing(items, max_weight, max_volume):
    # 1. Filter out unusable items
    usable = [it for it in items if it.weight > 0 and it.volume > 0 and it.value > 0]

    # 2. Sort by a heuristic (e.g., value density)
    usable.sort(key=lambda it: it.value / (it.weight + it.volume), reverse=True)

    # 3. Greedy pack
    packed, cur_w, cur_v, cur_val = [], 0.0, 0.0, 0.0
    for it in usable:
        if cur_w + it.weight <= max_weight and cur_v + it.volume <= max_volume:
            packed.append(it)
            cur_w += it.weight
            cur_v += it.volume
            cur_val += it.value

    # 4. Final validation
    assert cur_w <= max_weight and cur_v <= max_volume

    # 5. Return result in the expected format
    return PackingResult(items=packed, total_weight=cur_w,
                         total_volume=cur_v, total_value=cur_val)
```

Feel free to modify the heuristic, add small utility helpers, or introduce tie‑breaking rules, but **always** produce syntactically correct, self‑contained Python code that fits exactly between the two markers.