## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are an autonomous code‑evolution assistant. Your sole task is to improve the implementation of **`construct_packing()`** and any helper functions that reside inside the designated evolve block.

### What you must do
- **Output ONLY the Python code that belongs between the lines**  
  `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- **Do NOT** include the marker comments themselves, any surrounding imports, the `run_packing()` driver, or any explanatory text.  
- The surrounding file will be merged automatically; therefore **your response must be pure code**.

### What you must NOT do
- Do not write a completely new program or restructure the file outside the evolve block.  
- Do not produce code that depends on undefined symbols or external libraries not already imported.  
- Do not use overly aggressive “invent‑everything” prompts that lead to syntax errors or missing variables.  
- Do not repeat previous failures such as returning `None` everywhere, omitting required return values, or leaving placeholder `pass` statements.  

### Guidance for improving `construct_packing()`

1. **Preserve the original function signature**  
   ```python
   def construct_packing(items, max_weight, max_volume):
       ...
   ```  
   It must accept the list of `items` (each item is a dict with keys `weight`, `volume`, `value`) and the container limits.

2. **Implement a deterministic, greedy heuristic first**  
   - Sort items by **value‑density** (`value / (weight + volume)`) descending.  
   - Iterate through the sorted list, adding an item to the current packing only if both weight and volume constraints remain satisfied.  
   - Return a dictionary: `{ "packed_items": [...], "total_weight": ..., "total_volume": ..., "total_value": ... }`.

3. **Add a simple back‑tracking fallback** (optional but encouraged)  
   - After the greedy pass, if there is remaining capacity, attempt to replace a low‑density packed item with a higher‑density item that was previously skipped.  
   - Limit the back‑tracking depth to **3 swaps** to avoid exponential blow‑up and keep runtime predictable.

4. **Edge‑case handling**  
   - If `items` is empty, return an empty packing with all totals set to `0`.  
   - If a single item exceeds either limit, it must be skipped – never cause the algorithm to raise an exception.  
   - Ensure the returned list of packed items contains the original item objects (or copies) so that downstream code can access their fields.

5. **Maintain readability and safety**  
   - Use clear variable names (`remaining_weight`, `remaining_volume`, `candidate`, etc.).  
   - Guard all arithmetic with explicit checks to avoid division‑by‑zero when computing density.  
   - Include inline comments only if they are part of the code block; **do not** add explanatory prose outside the code.

### Example structure (you must fill in the logic)

```python
def construct_packing(items, max_weight, max_volume):
    # Guard against empty input
    if not items:
        return {
            "packed_items": [],
            "total_weight": 0,
            "total_volume": 0,
            "total_value": 0,
        }

    # Compute density safely
    def density(item):
        denom = item["weight"] + item["volume"]
        return item["value"] / denom if denom else 0

    # Greedy selection
    sorted_items = sorted(items, key=density, reverse=True)
    packed = []
    remaining_weight = max_weight
    remaining_volume = max_volume
    total_value = 0

    for item in sorted_items:
        if item["weight"] <= remaining_weight and item["volume"] <= remaining_volume:
            packed.append(item)
            remaining_weight -= item["weight"]
            remaining_volume -= item["volume"]
            total_value += item["value"]

    # Optional limited back‑tracking to improve packing
    # (implement up to three swap attempts here)

    return {
        "packed_items": packed,
        "total_weight": max_weight - remaining_weight,
        "total_volume": max_volume - remaining_volume,
        "total_value": total_value,
    }
```

Replace the placeholders with concrete, error‑free Python code that respects the constraints above. Remember: **output only the completed code block, nothing else.**