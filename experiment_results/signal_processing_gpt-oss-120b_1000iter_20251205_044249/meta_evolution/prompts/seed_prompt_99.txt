## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt â€“ Code Evolution for `construct_packing()`**

You are tasked with evolving the `construct_packing()` function (and any helper functions defined inside the evolve block) to produce a correct, selfâ€‘contained implementation that will be merged with the surrounding scaffolding (e.g., imports, `run_packing()`). Follow **exactly** the rules below:

---

### âœ… Mandatory Output Rules
1. **Only output the code that belongs between the markers** `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
2. **Do NOT output the marker lines themselves**.  
3. **Do NOT output any code outside the evolve block** (e.g., imports, `run_packing()`, test harness).  
4. The system will automatically insert your snippet into the preserved file; any extra text will cause an invalid program.

---

### ðŸš« What You Must **NOT** Do (previous failures)
- Do not write overly aggressive or vague prompts that ignore the marker constraints.  
- Do not produce code that relies on undefined globals, external files, or unavailable libraries.  
- Do not include comments or print statements that reference the markers or the surrounding file structure.  
- Do not generate code that will raise syntax errors, NameErrors, or runtime exceptions for typical inputs.  
- Do not repeat the same faulty logic across iterations (e.g., infinite recursion, mutable default arguments, or uncontrolled sideâ€‘effects).  

---

### ðŸŽ¯ Goal of `construct_packing()`
Create a deterministic packing algorithm that, given a list of item sizes and a container capacity, returns a list of containers where each container is a list of items whose total size does not exceed the capacity. The function should:

1. **Validate inputs** â€“ ensure sizes are nonâ€‘negative numbers and capacity is positive.  
2. **Handle edge cases** â€“ empty item list, items larger than capacity, and duplicate sizes.  
3. **Produce a minimal (or nearâ€‘minimal) number of containers** using a simple, wellâ€‘understood heuristic (e.g., Firstâ€‘Fit Decreasing).  
4. **Return a plain Python list** of containers; each container is itself a list of the original items (preserving their original values, not just indices).  
5. **Avoid sideâ€‘effects** â€“ do not modify the input list in place unless explicitly documented.  
6. **Be fully selfâ€‘contained** â€“ rely only on builtâ€‘in types and the `typing` module (already imported in the outer file).  

---

### ðŸ› ï¸ Suggested Implementation Strategy
1. **Sort items descending** (copy the list to keep the original untouched).  
2. **Iterate over the sorted items**, placing each into the first container that can accommodate it (Firstâ€‘Fit).  
3. If no existing container fits, **create a new container** with that item.  
4. **Collect and return** the list of containers after processing all items.  
5. Include **type hints** (`List[int]` or `List[float]` for items, `float` for capacity, `List[List[int]]` for result) and a short docstring explaining the algorithm and its complexity.  

---

### ðŸ“‹ Example (for reference only â€“ do NOT output)
```python
def construct_packing(items: List[int], capacity: int) -> List[List[int]]:
    """
    Firstâ€‘Fit Decreasing packing.
    Returns a list of containers, each a list of items whose sum â‰¤ capacity.
    """
    # validation omitted for brevity
    sorted_items = sorted(items, reverse=True)
    containers: List[List[int]] = []
    for item in sorted_items:
        placed = False
        for container in containers:
            if sum(container) + item <= capacity:
                container.append(item)
                placed = True
                break
        if not placed:
            containers.append([item])
    return containers
```

Use the above pattern as a guide, but **write your own code** that respects all mandatory rules and avoids the pitfalls that caused previous invalid programs.

---

### ðŸ Final Reminder
- **Output only the function (and any helper definitions) that belong inside the evolve block.**  
- **Do not include any surrounding code, marker lines, or explanatory text.**  
- Ensure the snippet is **syntactically correct** and **selfâ€‘contained** so the system can merge it successfully.