## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

You are a code‑evolution assistant tasked with improving only the `construct_packing()` function and any helper functions that reside **inside** the `# EVOLVE-BLOCK-START` … `# EVOLVE-BLOCK-END` region.  

**OUTPUT REQUIREMENTS**  
- **Output ONLY the Python code that belongs between the two markers.**  
- **Do NOT include the markers themselves** (`# EVOLVE-BLOCK-START` / `# EVOLVE-BLOCK-END`).  
- **Do NOT output any code that lies outside the evolve block** (imports, `run_packing()`, global constants, etc.).  
- The system will automatically splice your output into the surrounding file, preserving everything else.

**WHAT TO DO**  
1. **Focus exclusively on `construct_packing()` and any helper functions defined inside the block.**  
2. Implement a **deterministic, well‑documented packing algorithm** (e.g., First‑Fit Decreasing, Best‑Fit, or a simple recursive back‑track with a depth limit).  
3. Keep the function signatures unchanged; only modify the bodies and add/adjust internal helper functions.  
4. Ensure the code **returns the same type of object** that the surrounding code expects (typically a list of bins, each bin a list of items).  
5. Add **inline comments** that explain each step of the algorithm, so future evolutions can reason about it.

**WHAT TO AVOID (based on past failures)**  
- Do **not** write a vague or overly aggressive prompt inside the code (e.g., “# TODO: improve this massively”).  
- Do **not** introduce new global variables or modify imports outside the block.  
- Do **not** leave syntax errors, undefined names, or mismatched indentation.  
- Do **not** produce code that depends on external libraries not already imported in the outer file.  
- Do **not** generate code that returns a different data structure than the original implementation.

**ALTERNATIVE STRATEGIES TO TRY (choose ONE and implement it cleanly)**  
- **First‑Fit Decreasing (FFD):**  
  - Sort items descending by size.  
  - Place each item into the first bin that can accommodate it; if none exists, open a new bin.  
- **Best‑Fit Decreasing (BFD):**  
  - Same sorting, but place each item into the bin that will have the least remaining space after insertion.  
- **Limited Depth‑First Backtrack:**  
  - Recursively try to place the next item into each feasible bin up to a configurable depth; fall back to a greedy method when the depth limit is reached.  
- **Hybrid Greedy + Local Optimization:**  
  - Run a greedy pass (FFD), then attempt a single‑pass “swap” improvement that moves items between bins to reduce waste.

Pick the strategy that best matches the existing code style and implement it with clear variable names, error‑checking, and comments.

**FINAL NOTE**  
Remember: **only the code between the markers will be kept**. Deliver a syntactically correct, self‑contained implementation of `construct_packing()` (and any needed helpers) that adheres to the above constraints.