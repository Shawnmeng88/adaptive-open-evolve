## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Message – Evolving `construct_packing()` and its helpers**

You are tasked with improving the `construct_packing()` function (and any helper functions defined inside the evolve block) so that the packing algorithm correctly selects items, respects capacity constraints, and produces a valid solution for the given problem instance.

### 1. Core Requirements
- **Correctness:** The function must return a packing (e.g., a list/tuple of selected item indices, a boolean mask, or any representation expected by the surrounding code) that satisfies all problem constraints (capacity, item availability, etc.) and maximizes the objective (e.g., total value) as far as possible within reasonable computation time.
- **Determinism for Testing:** The implementation should be deterministic given the same input (avoid random seeds unless explicitly required by the problem statement).
- **Efficiency:** Use algorithms appropriate for the problem size (e.g., greedy, dynamic programming, branch‑and‑bound, or a simple heuristic) rather than exhaustive search unless the instance is trivially small.

### 2. Mandatory Output Format (CRITICAL)
- **Only output the code that belongs between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.**
- **Do NOT include the markers themselves.**
- **Do NOT include any imports, global variables, or surrounding wrapper functions (e.g., `run_packing`).** Those are preserved automatically by the system.
- Your submission will be merged with the existing outer code; any stray lines will cause a merge failure.

### 3. Forbidden Approaches (must be avoided)
- **Over‑aggressive prompts:** Do not request the model to “write the perfect optimal algorithm for any size instance” without bounding the complexity. This leads to time‑outs or invalid code.
- **Unclear constraints:** Do not assume unknown data structures; only use the variables and signatures already present in the evolve block.
- **Repeated invalid programs:** Avoid generic “fill‑in‑the‑blank” or copy‑paste of unrelated code. Each change must be a concrete, testable improvement to `construct_packing()` or its helpers.
- **Random‑only solutions:** Pure randomness without a deterministic fallback will cause nondeterministic test failures.

### 4. Suggested Concrete Strategies
1. **Analyze the Input Shape**  
   - Inspect the provided `items`, `weights`, `values`, and `capacity` (or whatever names are present).  
   - If the number of items ≤ 30, consider a **meet‑in‑the‑middle** or **bitmask DP** for exact optimality.  
   - If the number of items is larger, fall back to a **value‑density greedy** (value/weight) heuristic, optionally followed by a **local improvement pass** (swap out low‑density items for higher‑density ones if capacity permits).

2. **Implement a Simple DP for Bounded Capacity**  
   ```python
   dp = [0] * (capacity + 1)
   chosen = [[[] for _ in range(capacity + 1)] for _ in range(len(items) + 1)]
   for i, (w, v) in enumerate(zip(weights, values), 1):
       for cap in range(capacity, w - 1, -1):
           if dp[cap - w] + v > dp[cap]:
               dp[cap] = dp[cap - w] + v
               chosen[i][cap] = chosen[i-1][cap-w] + [i-1]
   best_cap = max(range(capacity + 1), key=lambda c: dp[c])
   result = chosen[len(items)][best_cap]
   ```
   - Adapt variable names to match those in the evolve block.
   - Return `result` in the format expected by the outer code (e.g., a list of indices or a boolean mask).

3. **Greedy + Repair Heuristic**  
   - Sort items by `value/weight` descending.  
   - Add items while capacity permits.  
   - After the greedy pass, attempt a **single‑swap repair**: for each excluded item, try swapping it with a combination of currently included items whose total weight frees enough space and yields a higher total value.

4. **Modular Helper Functions**  
   - If the evolve block already defines helper stubs (e.g., `_greedy_select`, `_dp_select`), flesh them out and let `construct_packing()` choose the appropriate method based on `len(items)` or `capacity`.  
   - Keep each helper self‑contained and return the same data structure.

5. **Edge‑Case Handling**  
   - Return an empty packing if no item fits.  
   - Guard against zero or negative capacities.  
   - Ensure that duplicate item indices are never returned.

### 5. Prompting Guidance for the Model
- **State the chosen algorithm** explicitly in a comment at the top of your code block (e.g., `# Greedy‑plus‑repair heuristic`).  
- **Use only variables that exist** in the surrounding block; do not introduce new globals.  
- **Keep the code concise** (≤ 30 lines) to avoid merge errors.  
- **Test mentally**: walk through a tiny example (e.g., 3 items) to verify that the returned packing respects capacity and improves the objective.

---

**Remember:** The only content you may output is the Python code that belongs inside the evolve block, nothing else. Follow the format strictly, and apply one of the concrete strategies above to produce a correct, deterministic packing implementation. Good luck!