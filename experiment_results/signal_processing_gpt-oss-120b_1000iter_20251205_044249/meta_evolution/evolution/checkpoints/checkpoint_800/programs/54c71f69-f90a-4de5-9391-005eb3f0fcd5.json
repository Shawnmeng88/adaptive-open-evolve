{"id": "54c71f69-f90a-4de5-9391-005eb3f0fcd5", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\nfrom typing import Callable\n\ndef _to_array(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(arr, w):\n    \"\"\"Validate window size.\"\"\"\n    return isinstance(w, int) and w > 0 and arr.size >= w\n\n@lru_cache(maxsize=64)\ndef _exp_weights(w):\n    \"\"\"Cached right\u2011biased exponential weights that sum to 1.\"\"\"\n    w = int(w)\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Simple moving\u2011average filter (valid output).\"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"Exponentially weighted moving\u2011average filter (valid output).\"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    \"\"\"Classic EMA aligned to the simple\u2011MA length.\"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"Variance of (original \u2013 filtered) over the overlapping region.\"\"\"\n    m = min(len(original), len(filtered))\n    if m == 0:\n        return float(\"inf\")\n    return float(np.var(original[:m] - filtered[:m]))\n\ndef _combined_filter(x, window_size=20):\n    \"\"\"\n    Deterministic hybrid filter:\n    - Compute simple moving average and exponential\u2011weighted average.\n    - Blend them with weights inversely proportional to their residual variance\n      against the original (truncated) signal.\n    \"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n\n    simple = adaptive_filter(a, w)\n    weighted = weighted_filter(a, w)\n\n    # Align original to filtered length for variance calculation\n    orig_trunc = a[w - 1 :]\n\n    var_simple = _residual_variance(orig_trunc, simple)\n    var_weighted = _residual_variance(orig_trunc, weighted)\n\n    # Perfect match shortcut\n    if var_simple == 0 and var_weighted == 0:\n        return simple\n\n    inv_simple = 1.0 / var_simple if var_simple > 0 else 0.0\n    inv_weighted = 1.0 / var_weighted if var_weighted > 0 else 0.0\n    total = inv_simple + inv_weighted\n\n    if total == 0.0:\n        # Fallback to plain average\n        return (simple + weighted) / 2.0\n\n    return (inv_simple * simple + inv_weighted * weighted) / total\n\ndef _select_best_filter(x, window_size=20):\n    \"\"\"\n    Evaluate a small set of filters and return the one with the lowest\n    residual variance against the original signal.\n    \"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n\n    candidates = {\n        \"adaptive\": adaptive_filter(a, w),\n        \"weighted\": weighted_filter(a, w),\n        \"ema\": ema_filter(a, w),\n        \"combined\": _combined_filter(a, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n\n    best_key = min(candidates, key=lambda k: _residual_variance(a, candidates[k]))\n    return candidates[best_key]\n\ndef _apply_filter(name: str, x, w) -> np.ndarray:\n    \"\"\"Map filter name to its implementation.\"\"\"\n    mapping: dict[str, Callable[[np.ndarray, int], np.ndarray]] = {\n        \"adaptive\": adaptive_filter,\n        \"basic\": adaptive_filter,\n        \"weighted\": weighted_filter,\n        \"ema\": ema_filter,\n        \"combined\": _combined_filter,\n    }\n    func = mapping.get(name)\n    return func(x, w) if func else np.empty(0, dtype=float)\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        - \"adaptive\" / \"basic\" : simple moving average\n        - \"weighted\"           : exponential\u2011weighted moving average\n        - \"ema\"                : classic EMA (aligned output)\n        - \"combined\" / \"enhanced\" / \"hybrid\"\n                               : variance\u2011weighted hybrid of adaptive & weighted\n        - \"auto\"               : automatically select the best filter\n        - any other value     : fallback to the hybrid filter\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"adaptive\", \"basic\"):\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if alg in (\"combined\", \"enhanced\", \"hybrid\"):\n        return _combined_filter(input_signal, window_size)\n    if alg == \"auto\":\n        return _select_best_filter(input_signal, window_size)\n    # Unknown algorithm \u2013 default to the hybrid filter\n    return _combined_filter(input_signal, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "507926fe-897c-4150-a5f3-9bda4bb17cf4", "generation": 9, "timestamp": 1764942777.6538649, "iteration_found": 766, "metrics": {"runs_successfully": 1.0, "composite_score": 0.40531618708992745, "output_length": 91.0, "overall_score": 0.36615629786154524, "slope_changes": 75.4, "lag_error": 0.994348148233542, "avg_error": 1.2929943724687027, "false_reversals": 63.0, "correlation": 0.3105055092578505, "noise_reduction": 0.0, "smoothness_score": 0.20964360587002095, "responsiveness_score": 0.5014169671858607, "accuracy_score": 0.3105055092578505, "efficiency_score": 1.0, "execution_time": 0.00035915374755859377, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.41069177655857453, "output_length": 91.0, "overall_score": 0.36931604257091033, "slope_changes": 70.2, "lag_error": 1.0017800350739763, "avg_error": 1.30369374594483, "false_reversals": 59.0, "correlation": 0.30346716971522975, "noise_reduction": 0.0, "smoothness_score": 0.22172949002217296, "responsiveness_score": 0.49955538694492213, "accuracy_score": 0.30346716971522975, "efficiency_score": 1.0, "execution_time": 0.00034546852111816406, "success_rate": 1.0}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)\n## OUTPUT FORMAT (CRITICAL)\n- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers\n- Do NOT include the markers themselves in your output\n- Do NOT include any code outside the markers (imports, run_packing, etc.)\n- The system will automatically merge your output with the preserved code sections\n\n## FOCUS\n- Improve ONLY the `construct_packing()` function and helper functions within the evolve block\n- Functions like `run_packing()` are preserved automatically - do not include them\n\nViolating these requirements will cause the program to fail evaluation.\n\n---\n\n**System Prompt \u2013\u202fEvolve Block Guidance**\n\nYou are to modify only the code that resides between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`. **Do not output the markers themselves** and **do not include any code outside that region** (imports, `run_packing()`, etc.). The system will automatically splice your output into the preserved surrounding code.\n\n### Core Task\nImprove the `construct_packing()` function and any helper functions defined inside the evolve block so that they correctly build a feasible packing plan for the given items and containers.\n\n### Mandatory Output Rules (must be obeyed)\n- **Output ONLY the code** that should replace the existing contents between the markers.  \n- **Do NOT** include the `# EVOLVE-BLOCK-START` / `# EVOLVE-BLOCK-END` lines.  \n- **Do NOT** add, remove, or modify any code outside the evolve block.  \n\nViolating these rules will cause the program to be rejected.\n\n### What Must NOT Be Done (avoid these failures)\n- **Do not** write overly aggressive or speculative code that ignores the existing data structures (e.g., redefining `Item` or `Container`).  \n- **Do not** produce code that is syntactically invalid, contains undefined names, or relies on external libraries not already imported.  \n- **Do not** create deep, uncontrolled recursion that can cause a stack overflow for moderate\u2011size inputs.  \n- **Do not** leave placeholder `pass` statements or `TODO` comments; every path must be executable.  \n- **Do not** change the function signatures of `construct_packing` or its helpers; keep the public API identical.  \n\n### Concrete Strategies to Try (use one or combine several)\n\n1. **Greedy First\u2011Fit with Backtracking**  \n   - Sort items by decreasing volume (or weight) to place the largest items first.  \n   - Iterate over containers, trying to fit the current item using a helper `can_place(item, container, state)`.  \n   - If an item cannot be placed in any container, backtrack: remove the last placed item and try the next container option.  \n   - Limit backtracking depth by aborting early when the remaining free volume across all containers is insufficient for the remaining items.\n\n2. **State\u2011Tracking Helper Functions**  \n   - `can_place(item, container, state) \u2192 bool` \u2013 checks volume/weight limits and any custom constraints.  \n   - `add_item(item, container, state) \u2192 None` \u2013 updates the mutable `state` (e.g., `state['used_vol'][cid]`).  \n   - `remove_item(item, container, state) \u2192 None` \u2013 reverts the changes made by `add_item`.  \n   Using these helpers keeps `construct_packing` readable and isolates side\u2011effects.\n\n3. **Iterative Packing Loop with Early Exit**  \n   - Use a `while unplaced_items:` loop rather than recursion.  \n   - Inside the loop, attempt to place the next item; if no container can accommodate it, break and return the best\u2011so\u2011far packing (or raise a clear \u201cNo feasible packing\u201d exception).  \n   - This avoids recursion limits and makes debugging easier.\n\n4. **Memoization of Failed Sub\u2011states**  \n   - Store a frozenset of `(item_ids, container_usage)` that has already been proven unsolvable.  \n   - Before trying a placement, check the memo; if the state is cached, skip the expensive trial.  \n   - This dramatically reduces duplicate work for inputs with many similar items.\n\n5. **Robust Edge\u2011Case Handling**  \n   - If `items` is empty, return an empty packing list immediately.  \n   - If any single item exceeds *all* container capacities, raise a descriptive `ValueError`.  \n   - Validate that container capacities are positive numbers before the main loop.\n\n6. **Clear Documentation & Type Hints**  \n   - Add a concise docstring to `construct_packing` describing the algorithm, its inputs, and its return value.  \n   - Use Python type hints for all parameters and return types to help the evaluator catch mismatches early.\n\n### Example Skeleton (you may adapt and flesh out)\n\n```python\ndef construct_packing(items: List[Item], containers: List[Container]) -> PackingResult:\n    \"\"\"\n    Build a feasible packing using a greedy first\u2011fit with limited backtracking.\n    Returns a PackingResult (or raises ValueError if impossible).\n    \"\"\"\n    # 1\ufe0f\u20e3 Sort items by decreasing volume (or weight)\n    sorted_items = sorted(items, key=lambda i: i.volume, reverse=True)\n\n    # 2\ufe0f\u20e3 Initialise mutable state tracking used volume/weight per container\n    state = {\n        \"used_vol\": {c.id: 0 for c in containers},\n        \"used_wt\":  {c.id: 0 for c in containers},\n        \"placements\": [],                     # list of (item.id, container.id)\n    }\n\n    # 3\ufe0f\u20e3 Helper memo for failed states\n    failed_states: Set[frozenset] = set()\n\n    # 4\ufe0f\u20e3 Main packing loop (iterative with explicit backtrack stack)\n    stack: List[Tuple[int, List[Tuple[int, int]]]] = [(0, [])]  # (next_item_index, current_placements)\n\n    while stack:\n        idx, placements = stack.pop()\n        if idx == len(sorted_items):\n            # All items placed \u2013 fill result and return\n            state[\"placements\"] = placements\n            return build_result_from_state(state, containers)\n\n        item = sorted_items[idx]\n        placed = False\n\n        for container in containers:\n            if can_place(item, container, state):\n                # Record placement\n                add_item(item, container, state)\n                new_placements = placements + [(item.id, container.id)]\n\n                # Encode current sub\u2011state for memoization\n                sub_state_key = frozenset(new_placements)\n                if sub_state_key not in failed_states:\n                    stack.append((idx + 1, new_placements))\n                else:\n                    # Previously proven dead\u2011end \u2013 skip\n                    remove_item(item, container, state)\n                    continue\n\n                placed = True\n                # Do NOT break here; we push all viable branches onto the stack\n                # to allow limited backtracking later.\n                remove_item(item, container, state)\n\n        if not placed:\n            # No container could accept this item \u2013 mark this sub\u2011state as dead\n            dead_key = frozenset(placements)\n            failed_states.add(dead_key)\n\n    # If we exit the loop, no feasible packing was found\n    raise ValueError(\"No feasible packing exists for the given items and containers.\")\n```\n\nYou may restructure the above, add missing helper implementations, and adjust the algorithm (e.g., switch to pure recursion if you prefer) as long as you respect the rules above.\n\n**Remember:** Only output the final, syntactically correct Python code that should replace the content between the markers. No extra text, no markers, no surrounding code. Good luck!", "user": "# Current Program Information\n- Fitness: 14.2259\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 14.7995 \u2192 14.2259. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4053, output_length: 91.0000, overall_score: 0.3662, slope_changes: 75.4000, lag_error: 0.9943, avg_error: 1.2930, false_reversals: 63.0000, correlation: 0.3105, noise_reduction: 0.0000, smoothness_score: 0.2096, responsiveness_score: 0.5014, accuracy_score: 0.3105, efficiency_score: 1.0000, execution_time: 0.0004, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4053, output_length: 91.0000, overall_score: 0.3662, slope_changes: 75.4000, lag_error: 0.9943, avg_error: 1.2930, false_reversals: 63.0000, correlation: 0.3105, noise_reduction: 0.0000, smoothness_score: 0.2096, responsiveness_score: 0.5014, accuracy_score: 0.3105, efficiency_score: 1.0000, execution_time: 0.0004, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4001, output_length: 91.0000, overall_score: 0.3625, slope_changes: 80.4000, lag_error: 0.9635, avg_error: 1.2731, false_reversals: 65.8000, correlation: 0.3131, noise_reduction: 0.0000, smoothness_score: 0.1992, responsiveness_score: 0.5093, accuracy_score: 0.3131, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 15.2834)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _prep(x, ws):\n    ws = int(ws)\n    if ws <= 0:\n        raise ValueError(f\"window_size must be positive, got {ws}\")\n    a = np.asarray(x, dtype=float).ravel()\n    if a.size < ws:\n        return np.empty(0, dtype=float), ws\n    return a, ws\n\n@lru_cache(maxsize=64)\ndef _expw(ws):\n    w = np.exp(np.linspace(-2, 0, ws))\n    return w / w.sum()\n\ndef adaptive_filter(x, window_size=20):\n    a, ws = _prep(x, window_size)\n    if a.size == 0:\n        return a\n    c = np.cumsum(np.insert(a, 0, 0.0))\n    return (c[ws:] - c[:-ws]) / ws\n\ndef weighted_filter(x, window_size=20):\n    a, ws = _prep(x, window_size)\n    if a.size == 0:\n        return a\n    return np.convolve(a, _expw(ws), mode=\"valid\")\n\ndef exponential_smoothing(x, window_size=20):\n    a, ws = _prep(x, window_size)\n    if a.size == 0:\n        return a\n    alpha = 2.0 / (ws + 1.0)\n    y = np.empty_like(a)\n    y[0] = a[0]\n    for i in range(1, a.size):\n        y[i] = alpha * a[i] + (1 - alpha) * y[i - 1]\n    return y[ws - 1 :]\n\ndef _resvar(orig, filt):\n    m = min(len(orig), len(filt))\n    if m == 0:\n        return float(\"inf\")\n    d = orig[:m] - filt[:m]\n    return float(np.mean(d * d))\n\ndef _combined(x, ws):\n    a, _ = _prep(x, ws)\n    if a.size == 0:\n        return a\n    # generate candidate filters\n    cand = {\n        \"basic\": adaptive_filter(a, ws),\n        \"weighted\": weighted_filter(a, ws),\n        \"exp\": exponential_smoothing(a, ws),\n    }\n    # compute residual variances, keep only non\u2011empty results\n    vars = {k: _resvar(a, v) for k, v in cand.items() if v.size}\n    if not vars:\n        return np.empty(0, dtype=float)\n    # perfect match shortcut\n    for k, v in vars.items():\n        if v == 0.0:\n            return cand[k][:len(a) - ws + 1]\n    # inverse\u2011variance weighting (deterministic order)\n    keys = sorted(vars)\n    inv = np.array([1.0 / vars[k] for k in keys])\n    wts = inv / inv.sum()\n    min_len = min(len(cand[k]) for k in keys)\n    combined = sum(wts[i] * cand[k][:min_len] for i, k in enumerate(keys))\n    return combined\n\ndef _best(x, ws):\n    return _combined(x, ws)\n\ndef process_signal(sig, window_size=20, algorithm_type=\"enhanced\"):\n    alg = str(algorithm_type).lower()\n    if alg == \"basic\":\n        return adaptive_filter(sig, window_size)\n    if alg == \"enhanced\":\n        return _combined(sig, window_size)\n    if alg == \"exp\":\n        return exponential_smoothing(sig, window_size)\n    return _best(sig, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4001), Performs well on output_length (91.0000), Performs well on overall_score (0.3625), Performs well on slope_changes (80.4000), Performs well on lag_error (0.9635), Performs well on avg_error (1.2731), Performs well on false_reversals (65.8000), Performs well on correlation (0.3131), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1992), Performs well on responsiveness_score (0.5093), Performs well on accuracy_score (0.3131), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 14.7995)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _as_array(x, ws):\n    \"\"\"\n    Convert input to a 1\u2011D float array and validate ``ws``.\n    Returns a tuple ``(array, window)``; if the array is shorter than the\n    window an empty array is returned (no exception is raised).\n    \"\"\"\n    w = int(ws)\n    if w <= 0:\n        raise ValueError(\"window_size must be positive\")\n    a = np.asarray(x, dtype=float).ravel()\n    if a.size < w:\n        return np.empty(0, dtype=float), w\n    return a, w\n\ndef _moving_average(arr: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Fast simple moving average using cumulative sum (valid convolution).\"\"\"\n    if w <= 1:\n        return arr.copy()\n    csum = np.cumsum(np.insert(arr, 0, 0.0))\n    return (csum[w:] - csum[:-w]) / w\n\n@lru_cache(maxsize=64)\ndef _exp_weights(w: int) -> np.ndarray:\n    \"\"\"Cached exponential weighting vector (right\u2011biased).\"\"\"\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Simple moving\u2011average filter (valid output length).\"\"\"\n    arr, w = _as_array(x, window_size)\n    if arr.size == 0:\n        return np.empty(0, dtype=float)\n    return _moving_average(arr, w)\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"Exponential\u2011weighted moving average (valid output length).\"\"\"\n    arr, w = _as_array(x, window_size)\n    if arr.size == 0:\n        return np.empty(0, dtype=float)\n    return np.convolve(arr, _exp_weights(w), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    \"\"\"Classic exponential moving average (output aligns with other filters).\"\"\"\n    arr, w = _as_array(x, window_size)\n    if arr.size == 0:\n        return np.empty(0, dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(arr)\n    ema[0] = arr[0]\n    for i in range(1, arr.size):\n        ema[i] = alpha * arr[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"\n    Deterministic hybrid filter:\n    - Compute simple moving average and exponential\u2011weighted average.\n    - Blend them with weights inversely proportional to their residual variance\n      against the original (truncated) signal.\n    This often yields higher correlation and better noise reduction than a\n    single filter while keeping the output length ``n\u2011w+1``.\n    \"\"\"\n    arr, w = _as_array(x, window_size)\n    if arr.size == 0:\n        return np.empty(0, dtype=float)\n\n    # Individual filter outputs (both length n\u2011w+1)\n    adv = _moving_average(arr, w)\n    wgt = np.convolve(arr, _exp_weights(w), mode=\"valid\")\n\n    # Align original signal to filtered length for variance calculation\n    orig_trunc = arr[w - 1 :]\n\n    # Residual variances (protect against division by zero)\n    var_adv = np.var(orig_trunc - adv) if adv.size else float(\"inf\")\n    var_wgt = np.var(orig_trunc - wgt) if wgt.size else float(\"inf\")\n\n    # If both perfect, just return one of them\n    if var_adv == 0 and var_wgt == 0:\n        return adv\n\n    inv_adv = 1.0 / var_adv if var_adv > 0 else 0.0\n    inv_wgt = 1.0 / var_wgt if var_wgt > 0 else 0.0\n    total = inv_adv + inv_wgt\n\n    if total == 0.0:\n        # Fallback to simple average when variances are infinite\n        return (adv + wgt) / 2.0\n\n    # Weighted combination\n    return (inv_adv * adv + inv_wgt * wgt) / total\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"Variance of the residual (original - filtered) over the overlapping region.\"\"\"\n    m = min(len(original), len(filtered))\n    if m == 0:\n        return float(\"inf\")\n    return float(np.var(original[:m] - filtered[:m]))\n\ndef _select_best_filter(x, window_size):\n    \"\"\"\n    Evaluate all available filters and return the one with the lowest residual\n    variance (i.e., the best noise\u2011reduction estimate).\n    \"\"\"\n    candidates = {\n        \"adaptive\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n    }\n    best_name = min(candidates, key=lambda k: _residual_variance(\n        np.asarray(x, dtype=float).ravel(), candidates[k]\n    ))\n    return candidates[best_name]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatch to the selected filtering algorithm.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        \"basic\" / \"adaptive\" \u2013 simple moving average\n        \"weighted\"            \u2013 exponential\u2011weighted moving average\n        \"ema\"                 \u2013 classic EMA\n        \"enhanced\"            \u2013 hybrid variance\u2011weighted filter\n        any other value       \u2013 automatic selection of the best filter\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"basic\", \"adaptive\"):\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if alg == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(input_signal, window_size)\n    # fallback: auto\u2011select the best filter\n    return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4053), Performs well on output_length (91.0000), Performs well on overall_score (0.3662), Performs well on slope_changes (75.4000), Performs well on lag_error (0.9943), Performs well on avg_error (1.2930), Performs well on false_reversals (63.0000), Performs well on correlation (0.3105), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2096), Performs well on responsiveness_score (0.5014), Performs well on accuracy_score (0.3105), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0004), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 14.7995)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _prepare_input(x, window_size):\n    \"\"\"Validate window size and convert input to a 1\u2011D float array.\"\"\"\n    if not isinstance(window_size, int) or window_size <= 0:\n        raise ValueError(f\"window_size must be a positive integer, got {window_size}\")\n    arr = np.asarray(x, dtype=float).ravel()\n    if arr.size < window_size:\n        # Return empty array to signal that processing cannot be performed\n        return np.empty(0, dtype=float), window_size\n    return arr, window_size\n\n@lru_cache(maxsize=64)\ndef _exp_weights(ws):\n    \"\"\"Cached right\u2011biased exponential weighting vector that sums to 1.\"\"\"\n    w = np.exp(np.linspace(-2, 0, ws))\n    return w / w.sum()\n\ndef _moving_average(arr, ws):\n    \"\"\"Fast simple moving average using cumulative sum (valid output).\"\"\"\n    csum = np.cumsum(np.insert(arr, 0, 0.0))\n    return (csum[ws:] - csum[:-ws]) / ws\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Uniform moving\u2011average filter (valid output length).\"\"\"\n    arr, ws = _prepare_input(x, window_size)\n    if arr.size == 0:\n        return arr\n    return _moving_average(arr, ws)\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"Exponentially weighted moving\u2011average filter (valid output length).\"\"\"\n    arr, ws = _prepare_input(x, window_size)\n    if arr.size == 0:\n        return arr\n    return np.convolve(arr, _exp_weights(ws), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    \"\"\"Classic exponential moving average (output aligned with other filters).\"\"\"\n    arr, ws = _prepare_input(x, window_size)\n    if arr.size == 0:\n        return arr\n    alpha = 2.0 / (ws + 1)\n    ema = np.empty_like(arr)\n    ema[0] = arr[0]\n    for i in range(1, arr.size):\n        ema[i] = alpha * arr[i] + (1 - alpha) * ema[i - 1]\n    return ema[ws - 1 :]\n\ndef _residual_variance(original, filtered):\n    \"\"\"Variance of the residual (original \u2013 filtered) over overlapping region.\"\"\"\n    m = min(len(original), len(filtered))\n    if m == 0:\n        return float(\"inf\")\n    return float(np.var(original[:m] - filtered[:m]))\n\ndef combined_filter(x, window_size=20):\n    \"\"\"\n    Deterministic hybrid filter:\n    - Compute simple moving average and exponential\u2011weighted average.\n    - Blend them with weights inversely proportional to their residual variance.\n    \"\"\"\n    arr, ws = _prepare_input(x, window_size)\n    if arr.size == 0:\n        return arr\n\n    simple = _moving_average(arr, ws)\n    weighted = np.convolve(arr, _exp_weights(ws), mode=\"valid\")\n\n    # Align original signal to filtered length for variance calculation\n    orig_trunc = arr[ws - 1 :]\n\n    var_simple = _residual_variance(orig_trunc, simple)\n    var_weighted = _residual_variance(orig_trunc, weighted)\n\n    # Handle perfect or undefined cases\n    if var_simple == 0 and var_weighted == 0:\n        return simple\n    inv_simple = 1.0 / var_simple if var_simple > 0 else 0.0\n    inv_weighted = 1.0 / var_weighted if var_weighted > 0 else 0.0\n    total = inv_simple + inv_weighted\n    if total == 0.0:\n        return (simple + weighted) / 2.0\n\n    return (inv_simple * simple + inv_weighted * weighted) / total\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"combined\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        - \"adaptive\" / \"basic\" : simple moving average\n        - \"weighted\"           : exponential weighted moving average\n        - \"ema\"                : classic EMA (aligned output)\n        - \"enhanced\" / \"combined\" : hybrid filter with variance weighting\n        - any other value     : defaults to the combined filter\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"adaptive\", \"basic\"):\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    # \"enhanced\", \"combined\", or unknown \u2192 use hybrid approach\n    return combined_filter(input_signal, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4053), Performs well on output_length (91.0000), Performs well on overall_score (0.3662), Performs well on slope_changes (75.4000), Performs well on lag_error (0.9943), Performs well on avg_error (1.2930), Performs well on false_reversals (63.0000), Performs well on correlation (0.3105), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2096), Performs well on responsiveness_score (0.5014), Performs well on accuracy_score (0.3105), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0004), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 14.2259)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\nfrom typing import List\n\ndef _to_array(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(arr, w):\n    \"\"\"Check that window size is positive and fits the array.\"\"\"\n    return isinstance(w, int) and w > 0 and arr.size >= w\n\n@lru_cache(maxsize=64)\ndef _exp_weights(w):\n    \"\"\"Cached right\u2011biased exponential weights that sum to 1.\"\"\"\n    w = int(w)\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Simple moving\u2011average filter.\"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"Exponentially weighted moving\u2011average filter.\"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    \"\"\"Recursive exponential moving\u2011average (EMA) filter.\"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\ndef hybrid_filter(x, window_size=20):\n    \"\"\"Average of adaptive and weighted filters (same length).\"\"\"\n    s = adaptive_filter(x, window_size)\n    w = weighted_filter(x, window_size)\n    if s.size == 0:\n        return w\n    if w.size == 0:\n        return s\n    return (s + w) / 2.0\n\ndef _residual_variance(orig, filt):\n    \"\"\"Variance of the residual (orig \u2013 filt) over the overlapping region.\"\"\"\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(orig[:n] - filt[:n]))\n\ndef _auto_select(x, window_size=20):\n    \"\"\"Pick the filter with the lowest residual variance.\"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    candidates = {\n        \"adaptive\": adaptive_filter(a, w),\n        \"weighted\": weighted_filter(a, w),\n        \"ema\": ema_filter(a, w),\n        \"hybrid\": hybrid_filter(a, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best_key = min(candidates, key=lambda k: _residual_variance(a, candidates[k]))\n    return candidates[best_key]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"Dispatch to a filtering algorithm.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        - \"adaptive\" / \"basic\"\n        - \"weighted\"\n        - \"ema\"\n        - \"enhanced\" / \"hybrid\"\n        - \"auto\"   \u2013 automatic selection based on residual variance\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"adaptive\", \"basic\"):\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if alg in (\"enhanced\", \"hybrid\"):\n        return hybrid_filter(input_signal, window_size)\n    if alg == \"auto\":\n        return _auto_select(input_signal, window_size)\n    # Fallback to enhanced for unknown types\n    return hybrid_filter(input_signal, window_size)\n\ndef _best_fit_bin(item_size: int, remaining: List[int]) -> int:\n    \"\"\"Return index of bin with the smallest remaining space that fits the item,\n    or -1 if no bin can accommodate it.\"\"\"\n    best_idx = -1\n    min_space = None\n    for i, space in enumerate(remaining):\n        if item_size <= space:\n            leftover = space - item_size\n            if min_space is None or leftover < min_space:\n                min_space = leftover\n                best_idx = i\n    return best_idx\n\ndef construct_packing(items: List[int], capacity: int) -> List[List[int]]:\n    \"\"\"\n    First\u2011Fit Decreasing (with best\u2011fit tie\u2011breaker) bin\u2011packing.\n\n    Parameters\n    ----------\n    items : List[int]\n        Non\u2011negative sizes of items to pack.\n    capacity : int\n        Positive capacity of each bin.\n\n    Returns\n    -------\n    List[List[int]]\n        A list of bins, each containing the original indices of items placed in that bin.\n    \"\"\"\n    if capacity <= 0:\n        raise ValueError(\"capacity must be a positive integer\")\n    if not items:\n        return []\n\n    # Pair each item with its original index and sort descending by size\n    indexed = [(idx, size) for idx, size in enumerate(items)]\n    indexed.sort(key=lambda x: x[1], reverse=True)\n\n    bins: List[List[int]] = []\n    remaining: List[int] = []  # remaining capacity for each bin\n\n    for idx, size in indexed:\n        if size > capacity:\n            # Item too large: allocate its own bin (cannot be combined)\n            bins.append([idx])\n            remaining.append(0)\n            continue\n\n        bin_idx = _best_fit_bin(size, remaining)\n        if bin_idx >= 0:\n            bins[bin_idx].append(idx)\n            remaining[bin_idx] -= size\n        else:\n            # Open a new bin\n            bins.append([idx])\n            remaining.append(capacity - size)\n\n    # Optional: sort indices within each bin for readability\n    for b in bins:\n        b.sort()\n    return bins\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 14.2259)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _prepare(x, ws):\n    ws = int(ws)\n    if ws <= 0:\n        raise ValueError(\"window_size must be positive\")\n    arr = np.asarray(x, dtype=float)\n    if arr.ndim != 1:\n        raise ValueError(\"input must be 1\u2011D\")\n    if arr.size < ws:\n        return np.empty(0, dtype=float), ws\n    return arr, ws\n\n@lru_cache(maxsize=64)\ndef _exp_weights(ws):\n    w = np.exp(np.linspace(-2, 0, ws))\n    return w / w.sum()\n\ndef adaptive_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    c = np.cumsum(np.insert(a, 0, 0.0))\n    return (c[w:] - c[:-w]) / w\n\ndef weighted_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    trend = adaptive_filter(a, w)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = a - trend_full\n    return weighted_filter(detrended, w)\n\ndef _hybrid_filter(x, window_size=20):\n    \"\"\"Average of weighted and adaptive filters \u2013 keeps length unchanged.\"\"\"\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    weighted = weighted_filter(a, w)\n    adaptive = adaptive_filter(a, w)\n    # both have identical length (n\u2011w+1)\n    return (weighted + adaptive) / 2.0\n\ndef _residual_variance(orig, filt):\n    m = min(len(orig), len(filt))\n    return float(np.var(orig[:m] - filt[:m])) if m else float(\"inf\")\n\ndef _select_best_filter(x, window_size):\n    cand = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n        \"hybrid\": _hybrid_filter(x, window_size),\n    }\n    return cand[min(cand, key=lambda k: _residual_variance(x, cand[k]))]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    alg = (algorithm_type or \"\").lower()\n    if alg == \"basic\":\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if alg == \"enhanced\":\n        # use hybrid for stronger noise reduction while preserving length\n        return _hybrid_filter(input_signal, window_size)\n    # fallback to auto\u2011selection of the best filter\n    return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 14.0152, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom typing import List\n\ndef _to_np(x):\n    \"\"\"Convert input to 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _gaussian_weights(w):\n    \"\"\"Generate normalized Gaussian kernel of length w.\"\"\"\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w)\n    weights = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    return weights / weights.sum()\n\n\ndef adaptive_filter(x, w=20):\n    \"\"\"Simple moving\u2011average (valid convolution).\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(x, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted_filter(x, w=20):\n    \"\"\"Gaussian\u2011weighted moving average.\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    weights = _gaussian_weights(w)\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema_filter(x, w=20):\n    \"\"\"Classic exponential moving average (EMA) aligned with MA length.\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(x, w=20):\n    \"\"\"\n    Detrend with a simple moving average, then apply a Gaussian weighted filter.\n    Returns empty array if detrending fails.\n    \"\"\"\n    trend = adaptive_filter(x, w)\n    if trend.size == 0:\n        return np.array([], dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = _to_np(x) - trend_full\n    return weighted_filter(detrended, w)\n\n\ndef median_filter(x, w=20):\n    \"\"\"Sliding\u2011window median filter.\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    stride = x.strides[0]\n    shape = (x.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(x, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef combined_filter(x, w=20):\n    \"\"\"\n    Detrend \u2192 Gaussian weighted moving average \u2192 median smoothing.\n    Returns empty array if any stage fails.\n    \"\"\"\n    trend = adaptive_filter(x, w)\n    if trend.size == 0:\n        return np.array([], dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = _to_np(x) - trend_full\n\n    weighted = weighted_filter(detrended, w)\n    if weighted.size == 0:\n        return np.array([], dtype=float)\n\n    return median_filter(weighted, w)\n\n\ndef _residual_variance(original, filtered):\n    \"\"\"Variance of (original \u2013 filtered) after aligning lengths.\"\"\"\n    if filtered.size == 0:\n        return float(\"inf\")\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(original[:n] - filtered[:n]))\n\n\ndef _select_best_filter(x, w):\n    \"\"\"Choose the filter with the lowest residual variance.\"\"\"\n    x_np = _to_np(x)\n    candidates = {\n        \"basic\": adaptive_filter(x_np, w),\n        \"weighted\": weighted_filter(x_np, w),\n        \"ema\": ema_filter(x_np, w),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x_np, w),\n        \"combined\": combined_filter(x_np, w),\n        \"median\": median_filter(x_np, w),\n    }\n    best_key = min(candidates, key=lambda k: _residual_variance(x_np, candidates[k]))\n    return candidates[best_key]\n\n\ndef process_signal(sig, window_size=20, algorithm_type=\"basic\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Supported algorithm_type values (case\u2011insensitive):\n        - \"basic\"   : simple moving average\n        - \"weighted\": Gaussian weighted average\n        - \"ema\"     : classic EMA\n        - \"enhanced\": detrended weighted filter (now auto\u2011selected for best result)\n        - \"combined\": detrend \u2192 weighted \u2192 median\n        - \"median\"  : median filter\n        - any other value falls back to automatic selection.\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    x = _to_np(sig)\n\n    if alg == \"basic\":\n        return adaptive_filter(x, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(x, window_size)\n    if alg == \"ema\":\n        return ema_filter(x, window_size)\n    if alg == \"combined\":\n        return combined_filter(x, window_size)\n    if alg == \"median\":\n        return median_filter(x, window_size)\n    if alg == \"enhanced\":\n        return _select_best_filter(x, window_size)\n\n    # Fallback: auto\u2011select best filter\n    return _select_best_filter(x, window_size)\n\n\ndef _best_fit_decreasing(items: List[int], capacity: int) -> List[List[int]]:\n    \"\"\"\n    Helper implementing Best\u2011Fit Decreasing bin packing.\n    Returns bins as lists of original zero\u2011based indices.\n    \"\"\"\n    # Pair each item with its original index\n    indexed = [(i, size) for i, size in enumerate(items)]\n    # Sort by size descending\n    indexed.sort(key=lambda x: x[1], reverse=True)\n\n    bins: List[List[int]] = []\n    remaining: List[int] = []\n\n    for idx, size in indexed:\n        if size > capacity:\n            # Item cannot fit in any bin; give it a dedicated bin.\n            bins.append([idx])\n            remaining.append(0)\n            continue\n\n        best_bin = -1\n        best_leftover = None\n        for b_idx, cap_left in enumerate(remaining):\n            if size <= cap_left:\n                leftover = cap_left - size\n                if best_leftover is None or leftover < best_leftover:\n                    best_leftover = leftover\n                    best_bin = b_idx\n\n        if best_bin >= 0:\n            bins[best_bin].append(idx)\n            remaining[best_bin] -= size\n        else:\n            bins.append([idx])\n            remaining.append(capacity - size)\n\n    # Sort indices inside each bin for readability\n    for b in bins:\n        b.sort()\n    return bins\n\n\ndef construct_packing(items: List[int], capacity: int) -> List[List[int]]:\n    \"\"\"\n    First\u2011Fit Decreasing (FFD) bin\u2011packing for 1\u2011D items.\n\n    This implementation now uses a deterministic Best\u2011Fit Decreasing\n    heuristic to often achieve a tighter packing while preserving the\n    original interface (list of bins with original item indices).\n    \"\"\"\n    if capacity <= 0:\n        raise ValueError(\"capacity must be a positive integer\")\n    if not items:\n        return []\n\n    # Delegate to the helper that performs the actual packing.\n    return _best_fit_decreasing(items, capacity)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 2 (Score: 14.0152, Type: Migrant)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _arr(x):\n    return np.asarray(x, float).ravel()\n\ndef _ok(a, w):\n    return w > 0 and a.size >= w\n\ndef _simple(x, w):\n    a = _arr(x)\n    return np.convolve(a, np.ones(w) / w, \"valid\") if _ok(a, w) else np.empty(0)\n\ndef _weighted(x, w):\n    a = _arr(x)\n    if not _ok(a, w):\n        return np.empty(0)\n    wts = np.exp(np.linspace(-2, 0, w))\n    wts /= wts.sum()\n    return np.convolve(a, wts, \"valid\")\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    k = str(alg).lower()\n    return _weighted(sig, w) if k == \"weighted\" else _simple(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 3 (Score: 14.0152, Type: Migrant)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef adaptive_filter(x: np.ndarray, window_size: int = 20) -> np.ndarray:\n    \"\"\"Simple moving\u2011average filter.\"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    return np.convolve(x, np.ones(window_size) / window_size, mode=\"valid\")\n\n\ndef process_signal(\n    input_signal: np.ndarray,\n    window_size: int = 20,\n    algorithm_type: str = \"combined\",\n) -> np.ndarray:\n    \"\"\"\n    Return a basic moving\u2011average filter regardless of the requested algorithm.\n    \"\"\"\n    return adaptive_filter(input_signal, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\nfrom typing import Callable\n\ndef _to_array(x):\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(arr, w):\n    return isinstance(w, int) and w > 0 and arr.size >= w\n\n@lru_cache(maxsize=64)\ndef _exp_weights(w):\n    w = int(w)\n    weights = np.exp(np.linspace(-2, 0, w))\n    return weights / weights.sum()\n\ndef adaptive_filter(x, window_size=20):\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted_filter(x, window_size=20):\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\ndef _apply_filter(name: str, x, w) -> np.ndarray:\n    \"\"\"Map filter name to its implementation.\"\"\"\n    mapping: dict[str, Callable[[np.ndarray, int], np.ndarray]] = {\n        \"adaptive\": adaptive_filter,\n        \"basic\": adaptive_filter,\n        \"weighted\": weighted_filter,\n        \"ema\": ema_filter,\n    }\n    func = mapping.get(name)\n    return func(x, w) if func else np.empty(0, dtype=float)\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"adaptive\", \"basic\"):\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if alg in (\"enhanced\", \"hybrid\"):\n        a = adaptive_filter(input_signal, window_size)\n        b = weighted_filter(input_signal, window_size)\n        if a.size == 0:\n            return b\n        if b.size == 0:\n            return a\n        return (a + b) / 2.0\n    # default fallback (covers unknown types)\n    return adaptive_filter(input_signal, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["import numpy as np\nfrom functools import lru_cache\nfrom typing import Callable\n\ndef _to_array(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(arr, w):\n    \"\"\"Validate window size.\"\"\"\n    return isinstance(w, int) and w > 0 and arr.size >= w\n\n@lru_cache(maxsize=64)\ndef _exp_weights(w):\n    \"\"\"Cached right\u2011biased exponential weights that sum to 1.\"\"\"\n    w = int(w)\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Simple moving\u2011average filter (valid output).\"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"Exponentially weighted moving\u2011average filter (valid output).\"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    \"\"\"Classic EMA aligned to the simple\u2011MA length.\"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"Variance of (original \u2013 filtered) over the overlapping region.\"\"\"\n    m = min(len(original), len(filtered))\n    if m == 0:\n        return float(\"inf\")\n    return float(np.var(original[:m] - filtered[:m]))\n\ndef _combined_filter(x, window_size=20):\n    \"\"\"\n    Deterministic hybrid filter:\n    - Compute simple moving average and exponential\u2011weighted average.\n    - Blend them with weights inversely proportional to their residual variance\n      against the original (truncated) signal.\n    \"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n\n    simple = adaptive_filter(a, w)\n    weighted = weighted_filter(a, w)\n\n    # Align original to filtered length for variance calculation\n    orig_trunc = a[w - 1 :]\n\n    var_simple = _residual_variance(orig_trunc, simple)\n    var_weighted = _residual_variance(orig_trunc, weighted)\n\n    # Perfect match shortcut\n    if var_simple == 0 and var_weighted == 0:\n        return simple\n\n    inv_simple = 1.0 / var_simple if var_simple > 0 else 0.0\n    inv_weighted = 1.0 / var_weighted if var_weighted > 0 else 0.0\n    total = inv_simple + inv_weighted\n\n    if total == 0.0:\n        # Fallback to plain average\n        return (simple + weighted) / 2.0\n\n    return (inv_simple * simple + inv_weighted * weighted) / total\n\ndef _select_best_filter(x, window_size=20):\n    \"\"\"\n    Evaluate a small set of filters and return the one with the lowest\n    residual variance against the original signal.\n    \"\"\"\n    a = _to_array(x)\n    w = int(window_size)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n\n    candidates = {\n        \"adaptive\": adaptive_filter(a, w),\n        \"weighted\": weighted_filter(a, w),\n        \"ema\": ema_filter(a, w),\n        \"combined\": _combined_filter(a, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n\n    best_key = min(candidates, key=lambda k: _residual_variance(a, candidates[k]))\n    return candidates[best_key]\n\ndef _apply_filter(name: str, x, w) -> np.ndarray:\n    \"\"\"Map filter name to its implementation.\"\"\"\n    mapping: dict[str, Callable[[np.ndarray, int], np.ndarray]] = {\n        \"adaptive\": adaptive_filter,\n        \"basic\": adaptive_filter,\n        \"weighted\": weighted_filter,\n        \"ema\": ema_filter,\n        \"combined\": _combined_filter,\n    }\n    func = mapping.get(name)\n    return func(x, w) if func else np.empty(0, dtype=float)\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        - \"adaptive\" / \"basic\" : simple moving average\n        - \"weighted\"           : exponential\u2011weighted moving average\n        - \"ema\"                : classic EMA (aligned output)\n        - \"combined\" / \"enhanced\" / \"hybrid\"\n                               : variance\u2011weighted hybrid of adaptive & weighted\n        - \"auto\"               : automatically select the best filter\n        - any other value     : fallback to the hybrid filter\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"adaptive\", \"basic\"):\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if alg in (\"combined\", \"enhanced\", \"hybrid\"):\n        return _combined_filter(input_signal, window_size)\n    if alg == \"auto\":\n        return _select_best_filter(input_signal, window_size)\n    # Unknown algorithm \u2013 default to the hybrid filter\n    return _combined_filter(input_signal, window_size)"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}