{"id": "c89c2255-b53e-485d-9bb6-89450854c6bf", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _arr(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(arr, w):\n    \"\"\"Return True if window size is positive and fits the array.\"\"\"\n    return w > 0 and arr.size >= w\n\n\ndef _ma(x, w, wt=None):\n    \"\"\"Simple moving average (uniform or custom weights).\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    if wt is None:\n        wt = np.ones(w) / w\n    else:\n        wt = np.asarray(wt, dtype=float)\n        if wt.size != w:\n            raise ValueError(\"Weight vector length must equal window size\")\n        wt = wt / wt.sum()\n    return np.convolve(a, wt, mode=\"valid\")\n\n\ndef _ema(x, w):\n    \"\"\"Classic exponential moving average (recursive).\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(a)\n    e[0] = a[0]\n    for i in range(1, len(a)):\n        e[i] = alpha * a[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\n\ndef _gaussian(x, w):\n    \"\"\"Gaussian\u2011kernel moving average.\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w, dtype=float)\n    kernel = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    kernel /= kernel.sum()\n    return np.convolve(a, kernel, mode=\"valid\")\n\n\ndef _median(x, w):\n    \"\"\"Median filter.\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    stride = a.strides[0]\n    shape = (a.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(a, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef _combined_ma_ema(x, w):\n    \"\"\"Average of MA and EMA where both are available.\"\"\"\n    ma = _ma(x, w)\n    ema = _ema(x, w)\n    if ma.size and ema.size:\n        return (ma + ema) / 2.0\n    return ma if ma.size else ema\n\n\ndef _detrended_weighted(x, w):\n    \"\"\"\n    Detrend with a simple moving average, smooth the detrended series\n    using a Gaussian kernel, then re\u2011add the trend.\n    \"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n\n    # Estimate trend via MA\n    trend = _ma(a, w)                     # length = n - w + 1\n    # Pad trend to original length (repeat first value for missing prefix)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n\n    # Detrend\n    detrended = a - trend_full\n\n    # Smooth detrended part\n    smooth = _gaussian(detrended, w)\n\n    # Align and add back trend (trend already aligned with smooth output)\n    return smooth + trend\n\n\ndef _resvar(orig, filt):\n    \"\"\"Mean\u2011squared deviation between overlapping portions of two signals.\"\"\"\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n])) if n else float(\"inf\")\n\n\ndef _best(x, w):\n    \"\"\"Select the filter with the lowest residual variance (deterministic tie\u2011break).\"\"\"\n    a = _arr(x)\n    candidates = {\n        \"ma\": _ma(a, w),\n        \"ema\": _ema(a, w),\n        \"gauss\": _gaussian(a, w),\n        \"median\": _median(a, w),\n        \"combined\": _combined_ma_ema(a, w),\n        \"detrended\": _detrended_weighted(a, w),\n    }\n    # Discard empty results\n    filtered = [(name, arr) for name, arr in candidates.items() if arr.size]\n    if not filtered:\n        return np.empty(0, float)\n\n    # Compute residual variance for each candidate\n    metrics = [( _resvar(a, arr), name, arr) for name, arr in filtered]\n    # Deterministic: smallest variance, then alphabetical name\n    _, _, best_arr = min(metrics, key=lambda t: (t[0], t[1]))\n    return best_arr\n\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    w : int, optional\n        Window size (default 20).\n    alg : str, optional\n        Algorithm identifier. Supported (case\u2011insensitive):\n        - \"basic\" / \"ma\"          : simple moving average\n        - \"ema\" / \"ewma\"          : exponential moving average\n        - \"gaussian\" / \"weighted\": Gaussian\u2011kernel smoothing\n        - \"median\"                : median filter\n        - \"combined\" / \"average\"  : average of MA and EMA\n        - \"detrended\" / \"trend\"  : detrended\u2011weighted filter\n        - any other value         : automatic best\u2011filter selection\n\n    Returns\n    -------\n    ndarray\n        Filtered signal (may be empty if window is invalid).\n    \"\"\"\n    a = _arr(sig)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n\n    key = (alg or \"\").lower()\n    if key in (\"basic\", \"ma\"):\n        return _ma(a, w)\n    if key in (\"ema\", \"ewma\"):\n        return _ema(a, w)\n    if key in (\"gaussian\", \"weighted\"):\n        return _gaussian(a, w)\n    if key == \"median\":\n        return _median(a, w)\n    if key in (\"combined\", \"average\"):\n        return _combined_ma_ema(a, w)\n    if key in (\"detrended\", \"trend\"):\n        return _detrended_weighted(a, w)\n\n    # Fallback: automatic selection of the best filter\n    return _best(a, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "8d3d58aa-c8f1-48d8-994b-a9333c5ace3d", "generation": 7, "timestamp": 1764941685.7672892, "iteration_found": 0, "metrics": {"runs_successfully": 1.0, "composite_score": 0.4205150578718804, "output_length": 91.0, "overall_score": 0.38035985150742135, "slope_changes": 68.0, "lag_error": 0.9780360456577568, "avg_error": 1.2635358917076887, "false_reversals": 57.8, "correlation": 0.3334964145206185, "noise_reduction": 0.0, "smoothness_score": 0.22727272727272727, "responsiveness_score": 0.5055519600844633, "accuracy_score": 0.3334964145206185, "efficiency_score": 1.0, "execution_time": 0.0015051841735839843, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.4205150578718804, "output_length": 91.0, "overall_score": 0.38035985150742135, "slope_changes": 68.0, "lag_error": 0.9780360456577568, "avg_error": 1.2635358917076887, "false_reversals": 57.8, "correlation": 0.3334964145206185, "noise_reduction": 0.0, "smoothness_score": 0.22727272727272727, "responsiveness_score": 0.5055519600844633, "accuracy_score": 0.3334964145206185, "efficiency_score": 1.0, "execution_time": 0.0005811691284179687, "success_rate": 1.0}, "island": 2, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}