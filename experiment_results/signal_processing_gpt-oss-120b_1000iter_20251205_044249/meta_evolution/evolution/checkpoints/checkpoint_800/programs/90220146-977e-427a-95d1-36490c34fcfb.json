{"id": "90220146-977e-427a-95d1-36490c34fcfb", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _to_array(x):\n    \"\"\"Convert input to 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(arr, w):\n    \"\"\"Return True if window size is positive and fits the array.\"\"\"\n    return w > 0 and arr.size >= w\n\n@lru_cache(None)\ndef _exp_weights(w):\n    \"\"\"Right\u2011biased exponential weights that sum to 1.\"\"\"\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef adaptive(x, w=20):\n    \"\"\"Simple moving\u2011average filter.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    return a.copy() if w == 1 else np.convolve(a, np.ones(w) / w, \"valid\")\n\ndef weighted(x, w=20):\n    \"\"\"Exponential\u2011weighted moving average (recent samples weighted more).\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    return a.copy() if w == 1 else np.convolve(a, _exp_weights(w)[::-1], \"valid\")\n\ndef median(x, w=21):\n    \"\"\"Median filter (odd window size).\"\"\"\n    if w % 2 == 0:\n        w += 1\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    s = a.strides[0]\n    win = np.lib.stride_tricks.as_strided(a, (a.size - w + 1, w), (s, s))\n    return np.median(win, axis=1)\n\ndef hybrid(x, w=20):\n    \"\"\"Apply adaptive then weighted filtering.\"\"\"\n    return weighted(adaptive(x, w), w)\n\ndef _residual_variance(orig, filt):\n    \"\"\"Variance of the residual (orig \u2013 filt) over overlapping region.\"\"\"\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return np.inf\n    return float(np.var(orig[:n] - filt[:n]))\n\ndef _select_best(arr, w):\n    \"\"\"Choose the filter with the lowest residual variance.\"\"\"\n    candidates = {\n        \"adaptive\": adaptive(arr, w),\n        \"weighted\": weighted(arr, w),\n        \"median\": median(arr, w),\n        \"hybrid\": hybrid(arr, w),\n    }\n    # discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best_key = min(candidates, key=lambda k: _residual_variance(arr, candidates[k]))\n    return candidates[best_key]\n\ndef process_signal(sig, w=20, alg=\"auto\"):\n    \"\"\"Dispatch to a filtering algorithm, with auto\u2011selection.\"\"\"\n    a = str(alg).lower()\n    if a == \"adaptive\":\n        return adaptive(sig, w)\n    if a == \"weighted\" or a == \"enhanced\":\n        return weighted(sig, w)\n    if a == \"median\":\n        return median(sig, w)\n    if a == \"hybrid\":\n        return hybrid(sig, w)\n    # auto\u2011selection: pick filter with minimal residual variance\n    return _select_best(_to_array(sig), w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "c0c50115-afff-4164-ab38-03d03cbaa0a8", "generation": 6, "timestamp": 1764939649.815626, "iteration_found": 402, "metrics": {"runs_successfully": 1.0, "composite_score": 0.42000321782831856, "output_length": 91.0, "overall_score": 0.38987798748202884, "slope_changes": 66.0, "lag_error": 0.8696516134600849, "avg_error": 1.241821020768923, "false_reversals": 55.2, "correlation": 0.3768253622186232, "noise_reduction": 0.0, "smoothness_score": 0.23255813953488372, "responsiveness_score": 0.5348590041057663, "accuracy_score": 0.3768253622186232, "efficiency_score": 1.0, "execution_time": 0.00030145645141601565, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.42000321782831856, "output_length": 91.0, "overall_score": 0.38987798748202884, "slope_changes": 66.0, "lag_error": 0.8696516134600849, "avg_error": 1.241821020768923, "false_reversals": 55.2, "correlation": 0.3768253622186232, "noise_reduction": 0.0, "smoothness_score": 0.23255813953488372, "responsiveness_score": 0.5348590041057663, "accuracy_score": 0.3768253622186232, "efficiency_score": 1.0, "execution_time": 0.00037384033203125, "success_rate": 1.0}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)\n## OUTPUT FORMAT (CRITICAL)\n- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers\n- Do NOT include the markers themselves in your output\n- Do NOT include any code outside the markers (imports, run_packing, etc.)\n- The system will automatically merge your output with the preserved code sections\n\n## FOCUS\n- Improve ONLY the `construct_packing()` function and helper functions within the evolve block\n- Functions like `run_packing()` are preserved automatically - do not include them\n\nViolating these requirements will cause the program to fail evaluation.\n\n---\n\nYou are a code\u2011evolution assistant tasked with improving the **`construct_packing()`** function and any helper functions that appear between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  \n\n**Output Rules (must be obeyed exactly)**  \n- Output **only** the Python code that belongs between the two markers.  \n- **Do not** include the markers themselves, any surrounding imports, the `run_packing()` driver, or any other code outside the block.  \n- The system will automatically splice your output into the preserved surrounding file.  \n\n**What NOT to do (strict prohibitions)**  \n- Do **not** write a prompt that is overly aggressive, vague, or ignores the marker constraints \u2013 this previously caused a 100\u202f% invalid\u2011program rate.  \n- Do **not** produce code that fails to compile, has syntax errors, or violates the function signature \u2013 such errors led to repeated failures in earlier iterations.  \n- Do **not** rely on undefined variables, external modules that aren\u2019t imported in the outer file, or side\u2011effects that the surrounding code cannot handle.  \n\n**Guidelines for a successful implementation**  \n\n1. **Respect the existing signature**  \n   ```python\n   def construct_packing(items: List[Item], max_weight: float, max_volume: float) -> PackingResult:\n   ```  \n   Return a `PackingResult` (or whatever the surrounding code expects) and ensure all type hints match the surrounding definitions.\n\n2. **Incremental, test\u2011driven logic**  \n   - Start by sorting or filtering `items` in a deterministic way (e.g., by decreasing density `value/weight` or `value/volume`).  \n   - Build the packing iteratively: keep running totals of weight and volume, and only add an item if both limits remain satisfied.  \n   - After each addition, update any auxiliary structures (e.g., a list of selected items, total value, etc.) so that the final `PackingResult` can be constructed directly.\n\n3. **Validate before returning**  \n   - Before the function returns, assert that `total_weight <= max_weight` and `total_volume <= max_volume`.  \n   - If no items can be packed, return an empty result rather than `None` or raising an exception.\n\n4. **Keep helper functions pure and self\u2011contained**  \n   - If you need a helper (e.g., `fits(item, cur_weight, cur_volume)`) define it **inside** the evolve block so it will be merged together.  \n   - Ensure helpers do not depend on external state; pass all required data as arguments.\n\n5. **Avoid recursion or complex control flow**  \n   - Use simple loops and conditionals; deep recursion has caused stack\u2011overflow or logic errors in past attempts.  \n\n6. **Performance\u2011conscious but correct**  \n   - Aim for O(n log n) sorting + O(n) packing loop.  \n   - Do not attempt exhaustive search unless the item list is trivially small (the surrounding tests will flag excessive runtime).\n\n7. **Edge\u2011case handling**  \n   - Guard against negative or zero `max_weight` / `max_volume`.  \n   - Skip items with non\u2011positive weight, volume, or value.  \n\n**Example structure (you may adapt as needed, but keep the same logical flow)**  \n```python\ndef construct_packing(items, max_weight, max_volume):\n    # 1. Filter out unusable items\n    usable = [it for it in items if it.weight > 0 and it.volume > 0 and it.value > 0]\n\n    # 2. Sort by a heuristic (e.g., value density)\n    usable.sort(key=lambda it: it.value / (it.weight + it.volume), reverse=True)\n\n    # 3. Greedy pack\n    packed, cur_w, cur_v, cur_val = [], 0.0, 0.0, 0.0\n    for it in usable:\n        if cur_w + it.weight <= max_weight and cur_v + it.volume <= max_volume:\n            packed.append(it)\n            cur_w += it.weight\n            cur_v += it.volume\n            cur_val += it.value\n\n    # 4. Final validation\n    assert cur_w <= max_weight and cur_v <= max_volume\n\n    # 5. Return result in the expected format\n    return PackingResult(items=packed, total_weight=cur_w,\n                         total_volume=cur_v, total_value=cur_val)\n```\n\nFeel free to modify the heuristic, add small utility helpers, or introduce tie\u2011breaking rules, but **always** produce syntactically correct, self\u2011contained Python code that fits exactly between the two markers.", "user": "# Current Program Information\n- Fitness: 13.7277\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 13.9626 \u2192 13.7277. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4191, output_length: 91.0000, overall_score: 0.3857, slope_changes: 67.0000, lag_error: 0.8804, avg_error: 1.2336, false_reversals: 58.0000, correlation: 0.3604, noise_reduction: 0.0000, smoothness_score: 0.2299, responsiveness_score: 0.5318, accuracy_score: 0.3604, efficiency_score: 1.0000, execution_time: 0.0003, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4205, output_length: 91.0000, overall_score: 0.3804, slope_changes: 68.0000, lag_error: 0.9780, avg_error: 1.2635, false_reversals: 57.8000, correlation: 0.3335, noise_reduction: 0.0000, smoothness_score: 0.2273, responsiveness_score: 0.5056, accuracy_score: 0.3335, efficiency_score: 1.0000, execution_time: 0.0003, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4205, output_length: 91.0000, overall_score: 0.3804, slope_changes: 68.0000, lag_error: 0.9780, avg_error: 1.2635, false_reversals: 57.8000, correlation: 0.3335, noise_reduction: 0.0000, smoothness_score: 0.2273, responsiveness_score: 0.5056, accuracy_score: 0.3335, efficiency_score: 1.0000, execution_time: 0.0004, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _arr(x):\n    return np.asarray(x, float).ravel()\n\ndef _valid(a, w):\n    return w > 0 and a.size >= w\n\ndef adaptive(x, w=20):\n    a = _arr(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted(x, w=20):\n    a = _arr(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    wts = np.exp(np.linspace(-2, 0, w))\n    wts /= wts.sum()\n    return np.convolve(a, wts, mode=\"valid\")\n\ndef _auto(sig, w):\n    a = _arr(sig)\n    return weighted if np.var(a) > 1 else adaptive\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    key = str(alg).lower()\n    if key == \"auto\":\n        return _auto(sig, w)(sig, w)\n    if key in (\"adaptive\", \"enhanced\"):\n        return adaptive(sig, w)\n    if key == \"weighted\":\n        return weighted(sig, w)\n    raise ValueError(f\"Unsupported algorithm_type: {alg}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4205), Performs well on output_length (91.0000), Performs well on overall_score (0.3804), Performs well on slope_changes (68.0000), Performs well on lag_error (0.9780), Performs well on avg_error (1.2635), Performs well on false_reversals (57.8000), Performs well on correlation (0.3335), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2273), Performs well on responsiveness_score (0.5056), Performs well on accuracy_score (0.3335), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0004), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _validate_signal(x, window_size):\n    \"\"\"Validate and convert input to a 1\u2011D float array.\"\"\"\n    if not isinstance(window_size, int) or window_size <= 0:\n        raise ValueError(f\"window_size must be a positive integer, got {window_size}\")\n    arr = np.asarray(x, dtype=float).ravel()\n    if arr.size == 0:\n        return arr\n    if arr.size < window_size:\n        return np.empty(0, dtype=float)\n    return arr\n\ndef _moving_average(arr, w):\n    \"\"\"Fast moving\u2011average using cumulative sum (valid convolution).\"\"\"\n    if w <= 1:\n        return arr.copy()\n    csum = np.cumsum(np.insert(arr, 0, 0.0))\n    return (csum[w:] - csum[:-w]) / w\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Simple moving\u2011average filter.\"\"\"\n    arr = _validate_signal(x, window_size)\n    if arr.size == 0:\n        return np.array([], dtype=float)\n    return _moving_average(arr, window_size)\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"Dispatch to the selected algorithm (all map to simple moving average).\"\"\"\n    return adaptive_filter(input_signal, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4205), Performs well on output_length (91.0000), Performs well on overall_score (0.3804), Performs well on slope_changes (68.0000), Performs well on lag_error (0.9780), Performs well on avg_error (1.2635), Performs well on false_reversals (57.8000), Performs well on correlation (0.3335), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2273), Performs well on responsiveness_score (0.5056), Performs well on accuracy_score (0.3335), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0003), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 13.9626)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _as_arr(x, w):\n    a = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be >0\")\n    if a.ndim != 1:\n        raise ValueError(\"1\u2011D array required\")\n    if a.size < w:\n        raise ValueError(\"signal shorter than window\")\n    return a\n\n@lru_cache(None)\ndef _exp_weights(w):\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef adaptive(x, w=20):\n    a = _as_arr(x, w)\n    return a.copy() if w == 1 else np.convolve(a, np.ones(w) / w, \"valid\")\n\ndef enhanced(x, w=20):\n    a = _as_arr(x, w)\n    return a.copy() if w == 1 else np.convolve(a, _exp_weights(w)[::-1], \"valid\")\n\ndef enhanced_blend(x, w=20):\n    \"\"\"Blend simple and exponential weighted averages.\"\"\"\n    a = _as_arr(x, w)\n    if w == 1:\n        return a.copy()\n    e = np.convolve(a, _exp_weights(w)[::-1], \"valid\")\n    m = np.convolve(a, np.ones(w) / w, \"valid\")\n    # both outputs have same length (len(a)-w+1)\n    return (e + m) / 2.0\n\ndef median(x, w=21):\n    if w % 2 == 0:\n        w += 1\n    a = _as_arr(x, w)\n    if w == 1:\n        return a.copy()\n    s = a.strides[0]\n    win = np.lib.stride_tricks.as_strided(a, (a.size - w + 1, w), (s, s))\n    return np.median(win, axis=1)\n\ndef hybrid(x, w=20):\n    \"\"\"Median filter followed by blended enhanced smoothing.\"\"\"\n    med = median(x, w if w % 2 else w + 1)\n    return enhanced_blend(med, w)\n\ndef _residual_variance(original, filtered):\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return np.inf\n    return float(np.var(original[:n] - filtered[:n]))\n\ndef process_signal(sig, w=20, alg=\"auto\"):\n    a = alg.lower()\n    if a == \"adaptive\":\n        return adaptive(sig, w)\n    if a == \"enhanced\":\n        return enhanced_blend(sig, w)\n    if a == \"median\":\n        return median(sig, w)\n    if a == \"hybrid\":\n        return hybrid(sig, w)\n\n    # auto\u2011selection: evaluate candidates and pick lowest residual variance\n    candidates = {\n        \"adaptive\": adaptive(sig, w),\n        \"enhanced\": enhanced_blend(sig, w),\n        \"median\": median(sig, w),\n        \"hybrid\": hybrid(sig, w),\n    }\n    # discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best = min(candidates, key=lambda k: _residual_variance(sig, candidates[k]))\n    return candidates[best]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4191), Performs well on output_length (91.0000), Performs well on overall_score (0.3857), Performs well on slope_changes (67.0000), Performs well on lag_error (0.8804), Performs well on avg_error (1.2336), Performs well on false_reversals (58.0000), Performs well on correlation (0.3604), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2299), Performs well on responsiveness_score (0.5318), Performs well on accuracy_score (0.3604), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0003), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"\n    Simple moving average filter using convolution.\n    Returns the filtered signal with length len(x) - window_size + 1.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        # Not enough data \u2013 return empty array for consistency\n        return np.array([], dtype=float)\n    return np.convolve(x, np.ones(window_size) / window_size, mode=\"valid\")\n\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"\n    Exponential weighted moving average.\n    Emphasises recent samples while preserving overall trend.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    weights = np.exp(np.linspace(-2, 0, window_size))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema_filter(x, window_size=20):\n    \"\"\"\n    Classic exponential moving average (EMA).\n    Output length matches other filters (len(x) - window_size + 1).\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (window_size + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[window_size - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"\n    Detrends the signal using a simple moving average, then applies\n    a weighted moving average to the detrended series.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    # Estimate local trend\n    trend = adaptive_filter(x, window_size)\n    # Pad trend to original length (repeat edge values)\n    trend_full = np.concatenate((np.full(window_size - 1, trend[0]), trend))\n    detrended = x - trend_full\n    return weighted_filter(detrended, window_size)\n\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"\n    Compute variance of the residual (original - filtered).\n    Signals are aligned to the shortest length.\n    \"\"\"\n    min_len = min(len(original), len(filtered))\n    if min_len == 0:\n        return np.inf\n    residual = original[:min_len] - filtered[:min_len]\n    return float(np.var(residual))\n\n\ndef _select_best_filter(x: np.ndarray, window_size: int) -> np.ndarray:\n    \"\"\"\n    Evaluate all available filters and return the one that yields the lowest\n    residual variance (i.e., highest estimated noise reduction).\n    \"\"\"\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n    }\n    # Choose filter with minimal residual variance relative to the raw signal\n    best_name = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_name]\n\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatches to the requested filtering algorithm.\n    Supported types:\n        - \"basic\": simple moving average (adaptive_filter)\n        - \"weighted\": exponential weighted moving average (weighted_filter)\n        - \"ema\": classic exponential moving average (ema_filter)\n        - \"enhanced\": detrended weighted filter (enhanced_filter_with_trend_preservation)\n        - any other value: automatic selection of the best filter based on residual variance.\n    \"\"\"\n    if algorithm_type == \"basic\":\n        return adaptive_filter(input_signal, window_size)\n    if algorithm_type == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if algorithm_type == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if algorithm_type == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(input_signal, window_size)\n\n    # Fallback: automatic selection\n    return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef _exp_weights(w: int) -> np.ndarray:\n    \"\"\"Right\u2011biased exponential weights that sum to 1.\"\"\"\n    w_arr = np.exp(np.linspace(-2, 0, w))\n    return w_arr / w_arr.sum()\n\ndef _to_array(x) -> np.ndarray:\n    \"\"\"Convert input to a 1\u2011D float array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(arr: np.ndarray, w: int) -> bool:\n    \"\"\"Check that window size is positive and fits the array.\"\"\"\n    return w > 0 and arr.size >= w\n\ndef adaptive(x, w=20) -> np.ndarray:\n    \"\"\"Simple moving\u2011average filter.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted(x, w=20) -> np.ndarray:\n    \"\"\"Exponential\u2011weighted moving average.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema(x, w=20) -> np.ndarray:\n    \"\"\"Classic exponential moving average (EMA).\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(a)\n    e[0] = a[0]\n    for i in range(1, len(a)):\n        e[i] = alpha * a[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\ndef gaussian(x, w=20) -> np.ndarray:\n    \"\"\"Zero\u2011phase Gaussian weighted moving average.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    mid = (w - 1) / 2.0\n    sigma = max(w / 6.0, 1e-8)\n    idx = np.arange(w)\n    g = np.exp(-0.5 * ((idx - mid) / sigma) ** 2)\n    g /= g.sum()\n    return np.convolve(a, g[::-1], mode=\"valid\")\n\ndef hybrid(x, w=20) -> np.ndarray:\n    \"\"\"Adaptive filter followed by exponential\u2011weighted filter.\"\"\"\n    return weighted(adaptive(x, w), w)\n\ndef enhanced(x, w=20) -> np.ndarray:\n    \"\"\"Detrend with simple moving average, then apply weighted filter.\"\"\"\n    trend = adaptive(x, w)\n    if trend.size == 0:\n        return np.empty(0, dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    return weighted(x - trend_full, w)\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"Variance of the residual (original \u2013 filtered) over overlapping region.\"\"\"\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return np.inf\n    return float(np.var(original[:n] - filtered[:n]))\n\n_algorithms = {\n    \"adaptive\": adaptive,\n    \"weighted\": weighted,\n    \"ema\": ema,\n    \"gaussian\": gaussian,\n    \"hybrid\": hybrid,\n    \"enhanced\": enhanced,\n}\n\ndef _auto_select(signal, w):\n    \"\"\"Pick a filter based on signal variance.\"\"\"\n    arr = _to_array(signal)\n    return hybrid if np.var(arr) > 1.0 else weighted\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n    Supported ``alg`` values (case\u2011insensitive):\n        - \"adaptive\"\n        - \"weighted\"\n        - \"ema\"\n        - \"gaussian\"\n        - \"hybrid\"\n        - \"enhanced\"\n        - \"auto\"  \u2013 automatic selection based on variance\n    Unknown values fall back to the enhanced filter.\n    \"\"\"\n    key = str(alg).lower()\n    if key == \"auto\":\n        func = _auto_select(sig, w)\n    else:\n        func = _algorithms.get(key, enhanced)\n    return func(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 13.7277, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Simple moving average using convolution.\"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        raise ValueError(f\"Input length ({x.size}) < window_size ({window_size})\")\n    return np.convolve(x, np.ones(window_size) / window_size, \"valid\")\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"Exponential\u2011weighted moving average that emphasizes recent samples.\"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        raise ValueError(f\"Input length ({x.size}) < window_size ({window_size})\")\n    w = np.exp(np.linspace(-2, 0, window_size))\n    w /= w.sum()\n    # reverse weights so recent samples get larger coefficients\n    return np.convolve(x, w[::-1], \"valid\")\n\ndef median_filter(x, window_size=20):\n    \"\"\"Median filter for impulsive noise (window_size must be odd).\"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if window_size % 2 == 0:\n        raise ValueError(\"median_filter requires an odd window_size\")\n    if x.size < window_size:\n        raise ValueError(f\"Input length ({x.size}) < window_size ({window_size})\")\n    half = window_size // 2\n    result = np.empty(x.size - window_size + 1, dtype=float)\n    for i in range(len(result)):\n        result[i] = np.median(x[i : i + window_size])\n    return result\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"Select and apply the requested filtering algorithm.\"\"\"\n    algo = algorithm_type.lower()\n    if algo == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(input_signal, window_size)\n    if algo == \"adaptive\":\n        return adaptive_filter(input_signal, window_size)\n    if algo == \"median\":\n        return median_filter(input_signal, window_size)\n    if algo == \"hybrid\":\n        # apply adaptive then enhanced on the result\n        interim = adaptive_filter(input_signal, window_size)\n        return enhanced_filter_with_trend_preservation(interim, window_size)\n    raise ValueError(f\"Unsupported algorithm_type: {algorithm_type}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 2 (Score: 10.9072, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n# ----------------------------------------------------------------------\n# Helper utilities\n# ----------------------------------------------------------------------\ndef _to_array(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(arr, w):\n    \"\"\"Validate that window size is positive and fits the array.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(f\"window size must be a positive integer, got {w}\")\n    if arr.size < w:\n        # Not enough data \u2013 return an empty array for consistency\n        return np.empty(0, dtype=float)\n    return arr\n\n\n@lru_cache(maxsize=None)\ndef _exp_weights(w):\n    \"\"\"Right\u2011biased exponential weights that sum to 1.\"\"\"\n    wgt = np.exp(np.linspace(-2, 0, w))\n    return wgt / wgt.sum()\n\n\n@lru_cache(maxsize=None)\ndef _gaussian_kernel(w):\n    \"\"\"Zero\u2011phase Gaussian kernel.\"\"\"\n    mid = (w - 1) / 2.0\n    sigma = max(w / 6.0, 1e-8)\n    idx = np.arange(w)\n    g = np.exp(-0.5 * ((idx - mid) / sigma) ** 2)\n    return g / g.sum()\n\n\ndef _combined_kernel(w):\n    \"\"\"Product of Gaussian and exponential kernels, re\u2011normalised.\"\"\"\n    g = _gaussian_kernel(w)\n    e = _exp_weights(w)\n    c = g * e\n    return c / c.sum()\n\n\ndef _detrend(arr, w):\n    \"\"\"Remove a simple moving\u2011average trend while preserving original length.\"\"\"\n    trend = np.convolve(arr, np.ones(w) / w, mode=\"valid\")\n    # Pad the trend to the original length (edge\u2011value extension)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    return arr - trend_full\n\n\n# ----------------------------------------------------------------------\n# Filtering algorithms\n# ----------------------------------------------------------------------\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Simple moving\u2011average filter (valid convolution).\"\"\"\n    arr = _validate_window(_to_array(x), window_size)\n    if arr.size == 0:\n        return arr\n    kernel = np.ones(window_size) / window_size\n    return np.convolve(arr, kernel, mode=\"valid\")\n\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"Exponential\u2011weighted moving average (recent samples weighted more).\"\"\"\n    arr = _validate_window(_to_array(x), window_size)\n    if arr.size == 0:\n        return arr\n    # reverse weights so newer samples receive larger weight\n    weights = _exp_weights(window_size)[::-1]\n    return np.convolve(arr, weights, mode=\"valid\")\n\n\ndef median_filter(x, window_size=21):\n    \"\"\"Median filter (odd window size) using stride tricks.\"\"\"\n    if window_size % 2 == 0:\n        window_size += 1\n    arr = _validate_window(_to_array(x), window_size)\n    if arr.size == 0:\n        return arr\n    stride = arr.strides[0]\n    shape = (arr.size - window_size + 1, window_size)\n    windows = np.lib.stride_tricks.as_strided(\n        arr, shape=shape, strides=(stride, stride)\n    )\n    return np.median(windows, axis=1)\n\n\ndef enhanced_filter(x, window_size=20):\n    \"\"\"\n    Detrend the signal, apply a combined Gaussian\u2011exponential kernel,\n    then add the trend back (valid length).\n    \"\"\"\n    arr = _validate_window(_to_array(x), window_size)\n    if arr.size == 0:\n        return arr\n    detrended = _detrend(arr, window_size)\n    kernel = _combined_kernel(window_size)\n    filtered = np.convolve(detrended, kernel, mode=\"valid\")\n    trend = np.convolve(arr, np.ones(window_size) / window_size, mode=\"valid\")\n    return filtered + trend\n\n\n# ----------------------------------------------------------------------\n# Model selection utilities\n# ----------------------------------------------------------------------\ndef _residual_variance(orig, filt):\n    \"\"\"Variance of the residual (orig \u2013 filt) over the overlapping region.\"\"\"\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n])) if n else float(\"inf\")\n\n\n_algorithms = {\n    \"adaptive\": adaptive_filter,\n    \"weighted\": weighted_filter,\n    \"median\": median_filter,\n    \"enhanced\": enhanced_filter,\n}\n\n\ndef _select_best(signal, window_size):\n    \"\"\"Pick the filter with the lowest residual variance.\"\"\"\n    arr = _to_array(signal)\n    best_key = None\n    best_var = float(\"inf\")\n    for name, func in _algorithms.items():\n        try:\n            out = func(arr, window_size)\n            if out.size == 0:\n                continue\n            var = _residual_variance(arr, out)\n            if var < best_var:\n                best_var = var\n                best_key = name\n        except Exception:\n            continue\n    return _algorithms.get(best_key, lambda x, w: np.empty(0, dtype=float))\n\n\n# ----------------------------------------------------------------------\n# Public API\n# ----------------------------------------------------------------------\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        - \"adaptive\"\n        - \"weighted\"\n        - \"median\"\n        - \"enhanced\"\n        - \"auto\"   \u2013 automatic selection based on residual variance\n        - any other value defaults to automatic selection\n    \"\"\"\n    alg = str(algorithm_type).lower()\n    if alg in _algorithms:\n        return _algorithms[alg](input_signal, window_size)\n\n    # Automatic selection path\n    selector = _select_best(input_signal, window_size)\n    return selector(_to_array(input_signal), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 3 (Score: 13.9292, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef _exp_weights(w: int) -> np.ndarray:\n    \"\"\"Right\u2011biased exponential weights that sum to 1.\"\"\"\n    w_arr = np.exp(np.linspace(-2, 0, w))\n    return w_arr / w_arr.sum()\n\ndef _to_array(x) -> np.ndarray:\n    \"\"\"Convert input to a 1\u2011D float array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(arr: np.ndarray, w: int) -> bool:\n    \"\"\"Check that window size is positive and fits the array.\"\"\"\n    return w > 0 and arr.size >= w\n\ndef adaptive(x, w=20) -> np.ndarray:\n    \"\"\"Simple moving\u2011average filter.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted(x, w=20) -> np.ndarray:\n    \"\"\"Exponential\u2011weighted moving average.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema(x, w=20) -> np.ndarray:\n    \"\"\"Classic exponential moving average (EMA).\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(a)\n    e[0] = a[0]\n    for i in range(1, len(a)):\n        e[i] = alpha * a[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\ndef gaussian(x, w=20) -> np.ndarray:\n    \"\"\"Zero\u2011phase Gaussian weighted moving average.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    mid = (w - 1) / 2.0\n    sigma = max(w / 6.0, 1e-8)\n    idx = np.arange(w)\n    g = np.exp(-0.5 * ((idx - mid) / sigma) ** 2)\n    g /= g.sum()\n    return np.convolve(a, g[::-1], mode=\"valid\")\n\ndef hybrid(x, w=20) -> np.ndarray:\n    \"\"\"Adaptive filter followed by exponential\u2011weighted filter.\"\"\"\n    return weighted(adaptive(x, w), w)\n\ndef enhanced(x, w=20) -> np.ndarray:\n    \"\"\"Detrend with simple moving average, then apply weighted filter.\"\"\"\n    trend = adaptive(x, w)\n    if trend.size == 0:\n        return np.empty(0, dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    return weighted(x - trend_full, w)\n\ndef median(x, w=20) -> np.ndarray:\n    \"\"\"Median filter (requires odd window size).\"\"\"\n    a = _to_array(x)\n    if w <= 0 or a.size < w:\n        return np.empty(0, dtype=float)\n    # enforce odd window for symmetric median\n    if w % 2 == 0:\n        w += 1\n        if a.size < w:\n            return np.empty(0, dtype=float)\n    shape = (a.size - w + 1, w)\n    strides = (a.strides[0], a.strides[0])\n    windows = np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)\n    return np.median(windows, axis=1)\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"Variance of the residual (original \u2013 filtered) over overlapping region.\"\"\"\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return np.inf\n    return float(np.var(original[:n] - filtered[:n]))\n\ndef _select_best_filter(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Choose the filter yielding the smallest residual variance.\"\"\"\n    candidates = {\n        \"adaptive\": adaptive(x, w),\n        \"weighted\": weighted(x, w),\n        \"ema\": ema(x, w),\n        \"gaussian\": gaussian(x, w),\n        \"hybrid\": hybrid(x, w),\n        \"enhanced\": enhanced(x, w),\n        \"median\": median(x, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best_key = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_key]\n\n_algorithms = {\n    \"adaptive\": adaptive,\n    \"weighted\": weighted,\n    \"ema\": ema,\n    \"gaussian\": gaussian,\n    \"hybrid\": hybrid,\n    \"enhanced\": enhanced,\n    \"median\": median,\n    \"best\": _select_best_filter,\n    \"auto\": _select_best_filter,\n}\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n    Supported ``alg`` values (case\u2011insensitive):\n        - \"adaptive\"\n        - \"weighted\"\n        - \"ema\"\n        - \"gaussian\"\n        - \"hybrid\"\n        - \"enhanced\"\n        - \"median\"\n        - \"best\" / \"auto\"  \u2013 automatic selection of the best filter.\n    Unknown values fall back to the enhanced filter.\n    \"\"\"\n    key = str(alg).lower()\n    func = _algorithms.get(key, enhanced)\n    if func in (adaptive, weighted, ema, gaussian, hybrid, enhanced, median):\n        return func(sig, w)\n    # For selectors that expect only (x, w) and return an array\n    return func(_to_array(sig), w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _as_arr(x,w):\n    a=np.asarray(x,float)\n    if w<=0: raise ValueError(\"window must be >0\")\n    if a.ndim!=1: raise ValueError(\"1\u2011D array required\")\n    if a.size<w: raise ValueError(\"signal shorter than window\")\n    return a\n\n@lru_cache(None)\ndef _exp_weights(w):\n    e=np.exp(np.linspace(-2,0,w))\n    return e/e.sum()\n\ndef adaptive(x,w=20):\n    a=_as_arr(x,w)\n    return a.copy() if w==1 else np.convolve(a,np.ones(w)/w,\"valid\")\n\ndef enhanced(x,w=20):\n    a=_as_arr(x,w)\n    return a.copy() if w==1 else np.convolve(a,_exp_weights(w)[::-1],\"valid\")\n\ndef median(x,w=21):\n    if w%2==0: w+=1\n    a=_as_arr(x,w)\n    if w==1: return a.copy()\n    s=a.strides[0]\n    win=np.lib.stride_tricks.as_strided(a,(a.size-w+1,w),(s,s))\n    return np.median(win,1)\n\ndef hybrid(x,w=20):\n    return enhanced(adaptive(x,w),w)\n\ndef process_signal(sig,w=20,alg=\"auto\"):\n    a=alg.lower()\n    if a==\"adaptive\": return adaptive(sig,w)\n    if a==\"enhanced\": return enhanced(sig,w)\n    if a==\"median\":   return median(sig,w)\n    if a==\"hybrid\":   return hybrid(sig,w)\n    # auto\u2011selection based on variance\n    return median(sig,w) if np.var(sig)>1.0 else enhanced(sig,w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["import numpy as np\nfrom functools import lru_cache\n\ndef _to_array(x):\n    \"\"\"Convert input to 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(arr, w):\n    \"\"\"Return True if window size is positive and fits the array.\"\"\"\n    return w > 0 and arr.size >= w\n\n@lru_cache(None)\ndef _exp_weights(w):\n    \"\"\"Right\u2011biased exponential weights that sum to 1.\"\"\"\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef adaptive(x, w=20):\n    \"\"\"Simple moving\u2011average filter.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    return a.copy() if w == 1 else np.convolve(a, np.ones(w) / w, \"valid\")\n\ndef weighted(x, w=20):\n    \"\"\"Exponential\u2011weighted moving average (recent samples weighted more).\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    return a.copy() if w == 1 else np.convolve(a, _exp_weights(w)[::-1], \"valid\")\n\ndef median(x, w=21):\n    \"\"\"Median filter (odd window size).\"\"\"\n    if w % 2 == 0:\n        w += 1\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    s = a.strides[0]\n    win = np.lib.stride_tricks.as_strided(a, (a.size - w + 1, w), (s, s))\n    return np.median(win, axis=1)\n\ndef hybrid(x, w=20):\n    \"\"\"Apply adaptive then weighted filtering.\"\"\"\n    return weighted(adaptive(x, w), w)\n\ndef _residual_variance(orig, filt):\n    \"\"\"Variance of the residual (orig \u2013 filt) over overlapping region.\"\"\"\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return np.inf\n    return float(np.var(orig[:n] - filt[:n]))\n\ndef _select_best(arr, w):\n    \"\"\"Choose the filter with the lowest residual variance.\"\"\"\n    candidates = {\n        \"adaptive\": adaptive(arr, w),\n        \"weighted\": weighted(arr, w),\n        \"median\": median(arr, w),\n        \"hybrid\": hybrid(arr, w),\n    }\n    # discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best_key = min(candidates, key=lambda k: _residual_variance(arr, candidates[k]))\n    return candidates[best_key]\n\ndef process_signal(sig, w=20, alg=\"auto\"):\n    \"\"\"Dispatch to a filtering algorithm, with auto\u2011selection.\"\"\"\n    a = str(alg).lower()\n    if a == \"adaptive\":\n        return adaptive(sig, w)\n    if a == \"weighted\" or a == \"enhanced\":\n        return weighted(sig, w)\n    if a == \"median\":\n        return median(sig, w)\n    if a == \"hybrid\":\n        return hybrid(sig, w)\n    # auto\u2011selection: pick filter with minimal residual variance\n    return _select_best(_to_array(sig), w)"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}