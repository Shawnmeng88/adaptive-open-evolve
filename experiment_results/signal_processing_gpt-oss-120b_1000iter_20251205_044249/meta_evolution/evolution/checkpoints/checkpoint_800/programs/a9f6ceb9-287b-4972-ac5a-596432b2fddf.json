{"id": "a9f6ceb9-287b-4972-ac5a-596432b2fddf", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_numpy(x):\n    \"\"\"Convert input to a 1\u2011D float ndarray.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(w):\n    \"\"\"Ensure the window size is a positive integer.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window_size must be a positive integer\")\n\n\ndef _ma(x, w):\n    \"\"\"Simple moving\u2011average filter (valid convolution).\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(arr, np.ones(w) / w, mode=\"valid\")\n\n\ndef _gaussian(x, w):\n    \"\"\"Weighted moving\u2011average with a Gaussian kernel.\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w)\n    weights = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    weights /= weights.sum()\n    return np.convolve(arr, weights, mode=\"valid\")\n\n\ndef _ema(x, w):\n    \"\"\"Exponential moving average aligned to MA length.\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(arr)\n    ema[0] = arr[0]\n    for i in range(1, arr.size):\n        ema[i] = alpha * arr[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef _median(x, w):\n    \"\"\"Median filter over a sliding window.\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    stride = arr.strides[0]\n    shape = (arr.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(arr, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef _residual_variance(orig, filt):\n    \"\"\"Mean variance of the difference between original and filtered signals.\"\"\"\n    if filt.size == 0:\n        return float(\"inf\")\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n]))\n\n\ndef _best_filter(x, w):\n    \"\"\"\n    Return the single filter with the lowest residual variance.\n    Deterministic tie\u2011breaking uses alphabetical order of filter names.\n    \"\"\"\n    orig = _to_numpy(x)\n    candidates = {\n        \"ma\": _ma(orig, w),\n        \"gaussian\": _gaussian(orig, w),\n        \"ema\": _ema(orig, w),\n        \"median\": _median(orig, w),\n    }\n    # Keep only non\u2011empty results\n    filtered = [(name, arr) for name, arr in candidates.items() if arr.size]\n    if not filtered:\n        return np.array([], dtype=float)\n\n    # Compute variances\n    metrics = [( _residual_variance(orig, arr), name, arr) for name, arr in filtered]\n    # Sort by variance then name for deterministic choice\n    metrics.sort(key=lambda t: (t[0], t[1]))\n    return metrics[0][2]\n\n\ndef _ensemble_best(x, w, top_n=2):\n    \"\"\"\n    Combine the top `top_n` filters (by residual variance) using\n    inverse\u2011variance weighting. Deterministic tie\u2011breaks ensure reproducibility.\n    \"\"\"\n    orig = _to_numpy(x)\n    candidates = {\n        \"ma\": _ma(orig, w),\n        \"gaussian\": _gaussian(orig, w),\n        \"ema\": _ema(orig, w),\n        \"median\": _median(orig, w),\n    }\n    filtered = [(name, arr) for name, arr in candidates.items() if arr.size]\n    if not filtered:\n        return np.array([], dtype=float)\n\n    metrics = [( _residual_variance(orig, arr), name, arr) for name, arr in filtered]\n    metrics.sort(key=lambda t: (t[0], t[1]))\n    top = metrics[:min(top_n, len(metrics))]\n\n    variances = np.array([m[0] for m in top], dtype=float)\n    # If any variance is zero (perfect fit) give it full weight\n    if np.any(variances == 0):\n        weights = np.where(variances == 0, 1.0, 0.0)\n    else:\n        inv = 1.0 / variances\n        weights = inv / inv.sum()\n\n    combined = sum(wt * arr for wt, (_, _, arr) in zip(weights, top))\n    return combined\n\n\ndef process_signal(sig, w=20, algorithm_type=\"combined\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        - \"basic\" or \"ma\": simple moving average\n        - \"weighted\": Gaussian weighted average\n        - \"ema\": exponential moving average\n        - \"median\": median filter\n        - \"best\": automatic selection of the single best filter\n        - \"combined\", \"ensemble\", \"auto\", \"enhanced\": weighted ensemble of top filters\n        - any other value falls back to the ensemble approach.\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"basic\", \"ma\"):\n        return _ma(sig, w)\n    if alg == \"weighted\":\n        return _gaussian(sig, w)\n    if alg == \"ema\":\n        return _ema(sig, w)\n    if alg == \"median\":\n        return _median(sig, w)\n    if alg == \"best\":\n        return _best_filter(sig, w)\n    # combined / ensemble / auto / enhanced / unknown -> ensemble of top filters\n    return _ensemble_best(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "10264729-4036-4135-bc3d-c2a0b7473ac7", "generation": 12, "timestamp": 1764943063.461592, "iteration_found": 800, "metrics": {"runs_successfully": 1.0, "composite_score": 0.44749818162382915, "output_length": 91.0, "overall_score": 0.4023805994349, "slope_changes": 49.2, "lag_error": 1.059564551407981, "avg_error": 1.2855980124824469, "false_reversals": 43.6, "correlation": 0.3278892928863792, "noise_reduction": 0.0, "smoothness_score": 0.28901734104046245, "responsiveness_score": 0.485539527914466, "accuracy_score": 0.3278892928863792, "efficiency_score": 1.0, "execution_time": 0.0007966995239257812, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.4205150578718804, "output_length": 91.0, "overall_score": 0.38035985150742135, "slope_changes": 68.0, "lag_error": 0.9780360456577568, "avg_error": 1.2635358917076887, "false_reversals": 57.8, "correlation": 0.3334964145206185, "noise_reduction": 0.0, "smoothness_score": 0.22727272727272727, "responsiveness_score": 0.5055519600844633, "accuracy_score": 0.3334964145206185, "efficiency_score": 1.0, "execution_time": 0.001191568374633789, "success_rate": 1.0}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)\n## OUTPUT FORMAT (CRITICAL)\n- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers\n- Do NOT include the markers themselves in your output\n- Do NOT include any code outside the markers (imports, run_packing, etc.)\n- The system will automatically merge your output with the preserved code sections\n\n## FOCUS\n- Improve ONLY the `construct_packing()` function and helper functions within the evolve block\n- Functions like `run_packing()` are preserved automatically - do not include them\n\nViolating these requirements will cause the program to fail evaluation.\n\n---\n\n**System Prompt \u2013 Code Evolution for `construct_packing()`**\n\nYou are to modify **only** the code that appears between the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`. **Do not** output the markers themselves, any import statements, or any surrounding scaffolding (e.g., `run_packing`). The surrounding file will be merged automatically.\n\n### Mandatory Output Rules\n1. **Output ONLY** the Python statements that belong between the two markers.  \n2. **Do NOT** include the `# EVOLVE-BLOCK-START` / `# EVOLVE-BLOCK-END` lines.  \n3. **Do NOT** add any extra code outside this region (imports, helper definitions that already exist, or top\u2011level statements).  \n\n### What NOT to Do (previous failures)\n- Do **not** produce code that is syntactically invalid or that raises exceptions on import.  \n- Do **not** make the function overly aggressive (e.g., infinite loops, exhaustive brute\u2011force without pruning).  \n- Do **not** repeat the same mistake that caused consecutive invalid programs (e.g., undefined variables, mismatched return types).  \n- Do **not** modify any code outside the evolve block, including global constants or existing helper functions.  \n\n### Goal\nImprove the `construct_packing()` implementation (and any tiny helper functions inside the evolve block) so that it builds a valid packing plan for the given items and container constraints. The function must:\n\n- Accept the same signature as originally declared.  \n- Return a data structure that the rest of the program expects (typically a list of bins, each containing a list of placed items).  \n- Handle edge cases gracefully (empty item list, items larger than any bin, duplicate items).  \n- Run in reasonable time for typical test sizes (avoid exponential blow\u2011up).  \n\n### Suggested Concrete Strategies\n1. **Pre\u2011process items**:  \n   - Sort items by descending size/weight or by a combined heuristic (e.g., volume\u202f\u00d7\u202fvalue).  \n   - Filter out items that cannot possibly fit into any bin and record them as \u201cunpackable\u201d.\n\n2. **Greedy First\u2011Fit Decreasing (FFD)**:  \n   - Iterate over the sorted items and place each into the first bin that has enough remaining capacity.  \n   - If no existing bin fits, open a new bin (if allowed) and place the item there.\n\n3. **Bin\u2011splitting fallback**:  \n   - When an item cannot fit into any current bin but a new bin is permissible, create a new bin with the minimal required capacity.  \n   - Optionally, try to rebalance by moving a previously placed smaller item to the new bin if it frees enough space for the current large item.\n\n4. **Simple backtracking guard**:  \n   - Limit backtracking depth (e.g., \u2264\u202f3 swaps) to avoid exponential search.  \n   - Only invoke backtracking when the greedy step fails for a high\u2011value item.\n\n5. **Return format compliance**:  \n   - Ensure the returned object matches the expected schema (e.g., `[{ \"bin_id\": ..., \"items\": [...] }, ...]`).  \n   - Preserve any required keys that the outer program reads (e.g., `total_weight`, `remaining_capacity`).\n\n6. **Validation hook**:  \n   - At the end of the function, perform a quick sanity check: sum of item sizes per bin \u2264 bin capacity, no duplicate placements, all items accounted for (or correctly marked as unpackable).  \n   - If the check fails, raise a clear `ValueError` with a concise message; do not silently return a corrupted structure.\n\n### Development Tips\n- Write the new logic in small, composable blocks inside the evolve region; each block should be testable in isolation.  \n- Re\u2011use existing helper functions if they are already defined outside the evolve block; do not duplicate them.  \n- Keep variable names descriptive (`sorted_items`, `bins`, `unpackable`) to aid readability and reduce typo\u2011related errors.  \n- Avoid global state; operate solely on the parameters passed to `construct_packing`.  \n\nFollow the rules above precisely, and produce a clean, syntactically correct implementation that improves packing quality while remaining safe and fast.", "user": "# Current Program Information\n- Fitness: 14.0152\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 14.0152 \u2192 14.0152. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4205, output_length: 91.0000, overall_score: 0.3804, slope_changes: 68.0000, lag_error: 0.9780, avg_error: 1.2635, false_reversals: 57.8000, correlation: 0.3335, noise_reduction: 0.0000, smoothness_score: 0.2273, responsiveness_score: 0.5056, accuracy_score: 0.3335, efficiency_score: 1.0000, execution_time: 0.0015, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4107, output_length: 91.0000, overall_score: 0.3693, slope_changes: 70.2000, lag_error: 1.0018, avg_error: 1.3037, false_reversals: 59.0000, correlation: 0.3035, noise_reduction: 0.0000, smoothness_score: 0.2217, responsiveness_score: 0.4996, accuracy_score: 0.3035, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4001, output_length: 91.0000, overall_score: 0.3625, slope_changes: 80.4000, lag_error: 0.9635, avg_error: 1.2731, false_reversals: 65.8000, correlation: 0.3131, noise_reduction: 0.0000, smoothness_score: 0.1992, responsiveness_score: 0.5093, accuracy_score: 0.3131, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 15.2834)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _prep(x, ws):\n    ws = int(ws)\n    if ws <= 0:\n        raise ValueError(f\"window_size must be positive, got {ws}\")\n    a = np.asarray(x, dtype=float).ravel()\n    if a.size < ws:\n        return np.empty(0, dtype=float), ws\n    return a, ws\n\n@lru_cache(maxsize=64)\ndef _expw(ws):\n    w = np.exp(np.linspace(-2, 0, ws))\n    return w / w.sum()\n\ndef adaptive_filter(x, window_size=20):\n    a, ws = _prep(x, window_size)\n    if a.size == 0:\n        return a\n    c = np.cumsum(np.insert(a, 0, 0.0))\n    return (c[ws:] - c[:-ws]) / ws\n\ndef weighted_filter(x, window_size=20):\n    a, ws = _prep(x, window_size)\n    if a.size == 0:\n        return a\n    return np.convolve(a, _expw(ws), mode=\"valid\")\n\ndef exponential_smoothing(x, window_size=20):\n    a, ws = _prep(x, window_size)\n    if a.size == 0:\n        return a\n    alpha = 2.0 / (ws + 1.0)\n    y = np.empty_like(a)\n    y[0] = a[0]\n    for i in range(1, a.size):\n        y[i] = alpha * a[i] + (1 - alpha) * y[i - 1]\n    return y[ws - 1 :]\n\ndef _resvar(orig, filt):\n    m = min(len(orig), len(filt))\n    if m == 0:\n        return float(\"inf\")\n    d = orig[:m] - filt[:m]\n    return float(np.mean(d * d))\n\ndef _combined(x, ws):\n    a, _ = _prep(x, ws)\n    if a.size == 0:\n        return a\n    # generate candidate filters\n    cand = {\n        \"basic\": adaptive_filter(a, ws),\n        \"weighted\": weighted_filter(a, ws),\n        \"exp\": exponential_smoothing(a, ws),\n    }\n    # compute residual variances, keep only non\u2011empty results\n    vars = {k: _resvar(a, v) for k, v in cand.items() if v.size}\n    if not vars:\n        return np.empty(0, dtype=float)\n    # perfect match shortcut\n    for k, v in vars.items():\n        if v == 0.0:\n            return cand[k][:len(a) - ws + 1]\n    # inverse\u2011variance weighting (deterministic order)\n    keys = sorted(vars)\n    inv = np.array([1.0 / vars[k] for k in keys])\n    wts = inv / inv.sum()\n    min_len = min(len(cand[k]) for k in keys)\n    combined = sum(wts[i] * cand[k][:min_len] for i, k in enumerate(keys))\n    return combined\n\ndef _best(x, ws):\n    return _combined(x, ws)\n\ndef process_signal(sig, window_size=20, algorithm_type=\"enhanced\"):\n    alg = str(algorithm_type).lower()\n    if alg == \"basic\":\n        return adaptive_filter(sig, window_size)\n    if alg == \"enhanced\":\n        return _combined(sig, window_size)\n    if alg == \"exp\":\n        return exponential_smoothing(sig, window_size)\n    return _best(sig, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4001), Performs well on output_length (91.0000), Performs well on overall_score (0.3625), Performs well on slope_changes (80.4000), Performs well on lag_error (0.9635), Performs well on avg_error (1.2731), Performs well on false_reversals (65.8000), Performs well on correlation (0.3131), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1992), Performs well on responsiveness_score (0.5093), Performs well on accuracy_score (0.3131), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 14.2259)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _prepare(x, ws):\n    ws = int(ws)\n    if ws <= 0:\n        raise ValueError(\"window_size must be positive\")\n    arr = np.asarray(x, dtype=float)\n    if arr.ndim != 1:\n        raise ValueError(\"input must be 1\u2011D\")\n    if arr.size < ws:\n        return np.empty(0, dtype=float), ws\n    return arr, ws\n\n@lru_cache(maxsize=64)\ndef _exp_weights(ws):\n    w = np.exp(np.linspace(-2, 0, ws))\n    return w / w.sum()\n\ndef adaptive_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    c = np.cumsum(np.insert(a, 0, 0.0))\n    return (c[w:] - c[:-w]) / w\n\ndef weighted_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    trend = adaptive_filter(a, w)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = a - trend_full\n    return weighted_filter(detrended, w)\n\ndef _hybrid_filter(x, window_size=20):\n    \"\"\"Average of weighted and adaptive filters \u2013 keeps length unchanged.\"\"\"\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    weighted = weighted_filter(a, w)\n    adaptive = adaptive_filter(a, w)\n    # both have identical length (n\u2011w+1)\n    return (weighted + adaptive) / 2.0\n\ndef _residual_variance(orig, filt):\n    m = min(len(orig), len(filt))\n    return float(np.var(orig[:m] - filt[:m])) if m else float(\"inf\")\n\ndef _select_best_filter(x, window_size):\n    cand = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n        \"hybrid\": _hybrid_filter(x, window_size),\n    }\n    return cand[min(cand, key=lambda k: _residual_variance(x, cand[k]))]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    alg = (algorithm_type or \"\").lower()\n    if alg == \"basic\":\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if alg == \"enhanced\":\n        # use hybrid for stronger noise reduction while preserving length\n        return _hybrid_filter(input_signal, window_size)\n    # fallback to auto\u2011selection of the best filter\n    return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4107), Performs well on output_length (91.0000), Performs well on overall_score (0.3693), Performs well on slope_changes (70.2000), Performs well on lag_error (1.0018), Performs well on avg_error (1.3037), Performs well on false_reversals (59.0000), Performs well on correlation (0.3035), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2217), Performs well on responsiveness_score (0.4996), Performs well on accuracy_score (0.3035), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_numpy(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _ma(x, w):\n    \"\"\"Simple moving average (valid convolution).\"\"\"\n    a = _to_numpy(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\n\ndef _ema(x, w):\n    \"\"\"Classic exponential moving average aligned with MA output length.\"\"\"\n    a = _to_numpy(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, len(a)):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef _gaussian(x, w):\n    \"\"\"Gaussian\u2011kernel moving average.\"\"\"\n    a = _to_numpy(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w, dtype=float)\n    kernel = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    kernel /= kernel.sum()\n    return np.convolve(a, kernel, mode=\"valid\")\n\n\ndef _median(x, w):\n    \"\"\"Median filter.\"\"\"\n    a = _to_numpy(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n    stride = a.strides[0]\n    shape = (a.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(a, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef _combined_ma_ema(x, w):\n    \"\"\"Average of MA and EMA (both have the same length).\"\"\"\n    ma = _ma(x, w)\n    ema = _ema(x, w)\n    if ma.size and ema.size:\n        return (ma + ema) / 2.0\n    return ma if ma.size else ema\n\n\ndef _detrended_weighted(x, w):\n    \"\"\"\n    Detrend using a simple moving average, smooth the detrended series\n    with a Gaussian weighted filter, then re\u2011add the trend.\n    \"\"\"\n    a = _to_numpy(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n\n    # Estimate local trend (MA)\n    trend = _ma(a, w)                     # length = n - w + 1\n    # Pad trend to original length by repeating edge values\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n\n    # Detrend\n    detrended = a - trend_full\n\n    # Smooth detrended series with Gaussian kernel\n    smooth = _gaussian(detrended, w)\n\n    # Re\u2011add trend (already aligned with smooth output)\n    return smooth + trend\n\n\ndef _residual_variance(orig, filt):\n    \"\"\"Mean\u2011squared deviation between aligned signals.\"\"\"\n    if filt.size == 0:\n        return float(\"inf\")\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n]))\n\n\ndef _best_filter(x, w):\n    \"\"\"\n    Select the filter with the lowest residual variance.\n    Considers MA, EMA, Gaussian, Median, combined MA/EMA, and detrended weighted.\n    \"\"\"\n    a = _to_numpy(x)\n    candidates = {\n        \"ma\": _ma(a, w),\n        \"ema\": _ema(a, w),\n        \"gaussian\": _gaussian(a, w),\n        \"median\": _median(a, w),\n        \"combined\": _combined_ma_ema(a, w),\n        \"detrended\": _detrended_weighted(a, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.array([], dtype=float)\n    # Return the filter with minimal residual variance\n    best_key = min(candidates, key=lambda k: _residual_variance(a, candidates[k]))\n    return candidates[best_key]\n\n\ndef adaptive_filter(x, w=20):\n    \"\"\"Alias for simple moving\u2011average.\"\"\"\n    return _ma(x, w)\n\n\ndef process_signal(sig, w=20, algorithm_type=\"combined\"):\n    \"\"\"\n    Dispatch to requested filter.\n    Supported types (case\u2011insensitive):\n        basic/ma, ewma/ema, weighted, median, combined/enhanced.\n    Any other value falls back to automatic best\u2011filter selection.\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"basic\", \"ma\"):\n        return _ma(sig, w)\n    if alg in (\"ewma\", \"ema\"):\n        return _ema(sig, w)\n    if alg == \"weighted\":\n        return _gaussian(sig, w)\n    if alg == \"median\":\n        return _median(sig, w)\n    if alg in (\"combined\", \"enhanced\"):\n        return _best_filter(sig, w)\n    # Fallback to automatic selection\n    return _best_filter(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4205), Performs well on output_length (91.0000), Performs well on overall_score (0.3804), Performs well on slope_changes (68.0000), Performs well on lag_error (0.9780), Performs well on avg_error (1.2635), Performs well on false_reversals (57.8000), Performs well on correlation (0.3335), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2273), Performs well on responsiveness_score (0.5056), Performs well on accuracy_score (0.3335), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0015), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_np(x):\n    return np.asarray(x, float).ravel()\n\ndef _valid(a, w):\n    return w > 0 and a.size >= w\n\ndef _conv(a, w, weights=None):\n    if not _valid(a, w):\n        return np.empty(0, float)\n    if weights is None:\n        weights = np.ones(w) / w\n    else:\n        weights = np.asarray(weights, float)\n        if weights.size != w:\n            raise ValueError(\"Weight length must equal window size\")\n        weights = weights / weights.sum()\n    return np.convolve(a, weights, mode=\"valid\")\n\ndef _ma(a, w):\n    return _conv(a, w)\n\ndef _gaussian(a, w):\n    if not _valid(a, w):\n        return np.empty(0, float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w, dtype=float)\n    kernel = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    return _conv(a, w, kernel)\n\ndef _ema(a, w):\n    if not _valid(a, w):\n        return np.empty(0, float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(a)\n    e[0] = a[0]\n    for i in range(1, a.size):\n        e[i] = alpha * a[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\ndef _median(a, w):\n    if not _valid(a, w):\n        return np.empty(0, float)\n    stride = a.strides[0]\n    shape = (a.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(a, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\ndef _combined_ma_ema(a, w):\n    ma = _ma(a, w)\n    ema = _ema(a, w)\n    return (ma + ema) / 2.0 if ma.size and ema.size else (ma if ma.size else ema)\n\ndef _detrended_weighted(a, w):\n    if not _valid(a, w):\n        return np.empty(0, float)\n    trend = _ma(a, w)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = a - trend_full\n    smooth = _gaussian(detrended, w)\n    return smooth + trend\n\ndef _resvar(orig, filt):\n    n = min(orig.size, filt.size)\n    return float(np.var(orig[:n] - filt[:n])) if n else float(\"inf\")\n\ndef _best(a, w):\n    cand = {\n        \"combined\": _combined_ma_ema(a, w),\n        \"detrended\": _detrended_weighted(a, w),\n        \"gauss\": _gaussian(a, w),\n        \"ma\": _ma(a, w),\n        \"median\": _median(a, w),\n        \"ema\": _ema(a, w),\n    }\n    filtered = [(k, v) for k, v in cand.items() if v.size]\n    if not filtered:\n        return np.empty(0, float)\n    best = min((( _resvar(a, v), k, v) for k, v in filtered), key=lambda t: (t[0], t[1]))\n    return best[2]\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    a = _to_np(sig)\n    if not _valid(a, w):\n        return np.empty(0, float)\n    key = (alg or \"\").lower()\n    if key in (\"basic\", \"ma\"):\n        return _ma(a, w)\n    if key in (\"ema\", \"ewma\"):\n        return _ema(a, w)\n    if key in (\"gaussian\", \"weighted\"):\n        return _gaussian(a, w)\n    if key == \"median\":\n        return _median(a, w)\n    if key in (\"combined\", \"average\"):\n        return _combined_ma_ema(a, w)\n    if key in (\"detrended\", \"trend\"):\n        return _detrended_weighted(a, w)\n    return _best(a, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _arr(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(arr, w):\n    \"\"\"Return True if window size is positive and fits the array.\"\"\"\n    return w > 0 and arr.size >= w\n\n\ndef _ma(x, w, wt=None):\n    \"\"\"Simple moving average (uniform or custom weights).\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    if wt is None:\n        wt = np.ones(w) / w\n    else:\n        wt = np.asarray(wt, dtype=float)\n        if wt.size != w:\n            raise ValueError(\"Weight vector length must equal window size\")\n        wt = wt / wt.sum()\n    return np.convolve(a, wt, mode=\"valid\")\n\n\ndef _ema(x, w):\n    \"\"\"Classic exponential moving average (recursive).\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(a)\n    e[0] = a[0]\n    for i in range(1, len(a)):\n        e[i] = alpha * a[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\n\ndef _gaussian(x, w):\n    \"\"\"Gaussian\u2011kernel moving average.\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w, dtype=float)\n    kernel = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    kernel /= kernel.sum()\n    return np.convolve(a, kernel, mode=\"valid\")\n\n\ndef _median(x, w):\n    \"\"\"Median filter.\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    stride = a.strides[0]\n    shape = (a.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(a, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef _combined_ma_ema(x, w):\n    \"\"\"Average of MA and EMA where both are available.\"\"\"\n    ma = _ma(x, w)\n    ema = _ema(x, w)\n    if ma.size and ema.size:\n        return (ma + ema) / 2.0\n    return ma if ma.size else ema\n\n\ndef _detrended_weighted(x, w):\n    \"\"\"\n    Detrend with a simple moving average, smooth the detrended series\n    using a Gaussian kernel, then re\u2011add the trend.\n    \"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n\n    # Estimate trend via MA\n    trend = _ma(a, w)                     # length = n - w + 1\n    # Pad trend to original length (repeat first value for missing prefix)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n\n    # Detrend\n    detrended = a - trend_full\n\n    # Smooth detrended part\n    smooth = _gaussian(detrended, w)\n\n    # Align and add back trend (trend already aligned with smooth output)\n    return smooth + trend\n\n\ndef _resvar(orig, filt):\n    \"\"\"Mean\u2011squared deviation between overlapping portions of two signals.\"\"\"\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n])) if n else float(\"inf\")\n\n\ndef _best(x, w):\n    \"\"\"Select the single filter with the lowest residual variance (deterministic tie\u2011break).\"\"\"\n    a = _arr(x)\n    candidates = {\n        \"ma\": _ma(a, w),\n        \"ema\": _ema(a, w),\n        \"gauss\": _gaussian(a, w),\n        \"median\": _median(a, w),\n        \"combined\": _combined_ma_ema(a, w),\n        \"detrended\": _detrended_weighted(a, w),\n    }\n    filtered = [(name, arr) for name, arr in candidates.items() if arr.size]\n    if not filtered:\n        return np.empty(0, float)\n\n    metrics = [( _resvar(a, arr), name, arr) for name, arr in filtered]\n    _, _, best_arr = min(metrics, key=lambda t: (t[0], t[1]))\n    return best_arr\n\n\ndef _ensemble_best(x, w, top_n=2):\n    \"\"\"\n    Combine the top `top_n` filters (by residual variance) using\n    inverse\u2011variance weighting. Guarantees deterministic output.\n    \"\"\"\n    a = _arr(x)\n    candidates = {\n        \"ma\": _ma(a, w),\n        \"ema\": _ema(a, w),\n        \"gauss\": _gaussian(a, w),\n        \"median\": _median(a, w),\n        \"combined\": _combined_ma_ema(a, w),\n        \"detrended\": _detrended_weighted(a, w),\n    }\n    filtered = [(name, arr) for name, arr in candidates.items() if arr.size]\n    if not filtered:\n        return np.empty(0, float)\n\n    metrics = [( _resvar(a, arr), name, arr) for name, arr in filtered]\n    # Sort by variance then name for deterministic tie\u2011break\n    metrics.sort(key=lambda t: (t[0], t[1]))\n    top = metrics[:min(top_n, len(metrics))]\n\n    variances = np.array([m[0] for m in top], dtype=float)\n    # Guard against zero variance (perfect fit) \u2013 give it full weight\n    if np.any(variances == 0):\n        weights = np.where(variances == 0, 1.0, 0.0)\n    else:\n        inv = 1.0 / variances\n        weights = inv / inv.sum()\n\n    result = sum(wt * arr for wt, (_, _, arr) in zip(weights, top))\n    return result\n\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    w : int, optional\n        Window size (default 20).\n    alg : str, optional\n        Algorithm identifier. Supported (case\u2011insensitive):\n        - \"basic\" / \"ma\"          : simple moving average\n        - \"ema\" / \"ewma\"          : exponential moving average\n        - \"gaussian\" / \"weighted\": Gaussian\u2011kernel smoothing\n        - \"median\"                : median filter\n        - \"combined\" / \"average\"  : average of MA and EMA\n        - \"detrended\" / \"trend\"  : detrended\u2011weighted filter\n        - \"ensemble\"              : weighted ensemble of top filters\n        - any other value         : automatic best\u2011filter selection\n\n    Returns\n    -------\n    ndarray\n        Filtered signal (may be empty if window is invalid).\n    \"\"\"\n    a = _arr(sig)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n\n    key = (alg or \"\").lower()\n    if key in (\"basic\", \"ma\"):\n        return _ma(a, w)\n    if key in (\"ema\", \"ewma\"):\n        return _ema(a, w)\n    if key in (\"gaussian\", \"weighted\"):\n        return _gaussian(a, w)\n    if key == \"median\":\n        return _median(a, w)\n    if key in (\"combined\", \"average\"):\n        return _combined_ma_ema(a, w)\n    if key in (\"detrended\", \"trend\"):\n        return _detrended_weighted(a, w)\n    if key == \"ensemble\":\n        return _ensemble_best(a, w)\n\n    # Fallback: automatic selection of the single best filter\n    return _best(a, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 13.9292, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _validate_window(w):\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window_size must be a positive integer\")\n\ndef _to_array(x):\n    return np.asarray(x, dtype=float).ravel()\n\ndef _ma(x, w):\n    _validate_window(w)\n    x = _to_array(x)\n    if x.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(x, np.ones(w) / w, mode=\"valid\")\n\ndef _ew(x, w):\n    _validate_window(w)\n    x = _to_array(x)\n    if x.size < w:\n        return np.array([], dtype=float)\n    wts = np.exp(np.linspace(-2, 0, w))\n    wts /= wts.sum()\n    return np.convolve(x, wts, mode=\"valid\")\n\ndef _ema(x, w):\n    _validate_window(w)\n    x = _to_array(x)\n    if x.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(x)\n    e[0] = x[0]\n    for i in range(1, len(x)):\n        e[i] = alpha * x[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\ndef _median(x, w):\n    _validate_window(w)\n    x = _to_array(x)\n    if x.size < w:\n        return np.array([], dtype=float)\n    stride = x.strides[0]\n    shape = (x.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(x, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\ndef _enhanced(x, w):\n    trend = _ma(x, w)\n    if trend.size == 0:\n        return np.array([], dtype=float)\n    full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    return _ew(x - full, w)\n\ndef _combined(x, w):\n    trend = _ma(x, w)\n    if trend.size == 0:\n        return np.array([], dtype=float)\n    full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    weighted = _ew(x - full, w)\n    if weighted.size == 0:\n        return np.array([], dtype=float)\n    return _median(weighted, w)\n\ndef _residual_variance(orig, filt):\n    if filt.size == 0:\n        return float(\"inf\")\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(orig[:n] - filt[:n]))\n\ndef _best_filter_name(x, w):\n    candidates = {\n        \"basic\": _ma,\n        \"weighted\": _ew,\n        \"ema\": _ema,\n        \"enhanced\": _enhanced,\n        \"combined\": _combined,\n    }\n    variances = {}\n    for name, func in candidates.items():\n        try:\n            out = func(x, w)\n            variances[name] = _residual_variance(x, out)\n        except Exception:\n            variances[name] = float(\"inf\")\n    order = [\"combined\", \"enhanced\", \"weighted\", \"ema\", \"basic\"]\n    return min(order, key=lambda k: (variances.get(k, float(\"inf\")), order.index(k)))\n\ndef process_signal(sig, window_size=20, algorithm_type=\"enhanced\"):\n    sig = _to_array(sig)\n    _validate_window(window_size)\n    alg = (algorithm_type or \"\").lower()\n    if alg == \"basic\":\n        return _ma(sig, window_size)\n    if alg == \"weighted\":\n        return _ew(sig, window_size)\n    if alg == \"ema\":\n        return _ema(sig, window_size)\n    if alg == \"enhanced\":\n        return _enhanced(sig, window_size)\n    if alg == \"combined\":\n        return _combined(sig, window_size)\n    best = _best_filter_name(sig, window_size)\n    return {\n        \"basic\": _ma(sig, window_size),\n        \"weighted\": _ew(sig, window_size),\n        \"ema\": _ema(sig, window_size),\n        \"enhanced\": _enhanced(sig, window_size),\n        \"combined\": _combined(sig, window_size),\n    }[best]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 2 (Score: 14.0152, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_numpy(x: object) -> np.ndarray:\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(w: int) -> None:\n    \"\"\"Validate that window size is a positive integer.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window size must be a positive integer\")\n\n\ndef _gaussian_weights(w: int) -> np.ndarray:\n    \"\"\"Generate a normalized Gaussian kernel of length ``w``.\"\"\"\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w, dtype=float)\n    weights = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    return weights / weights.sum()\n\n\ndef adaptive_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Simple moving\u2011average filter (valid convolution).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(x_arr, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Gaussian\u2011weighted moving average (valid convolution).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    weights = _gaussian_weights(w)\n    return np.convolve(x_arr, weights, mode=\"valid\")\n\n\ndef ema_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Classic exponential moving average (output length = len(x)\u2011w+1).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(x_arr)\n    ema[0] = x_arr[0]\n    for i in range(1, len(x_arr)):\n        ema[i] = alpha * x_arr[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef median_filter(x: object, w: int = 20) -> np.ndarray:\n    \"\"\"Sliding\u2011window median filter (valid output).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    stride = x_arr.strides[0]\n    shape = (x_arr.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(\n        x_arr, shape=shape, strides=(stride, stride)\n    )\n    return np.median(windows, axis=1)\n\n\ndef _linear_detrend(x: object) -> np.ndarray:\n    \"\"\"Remove a linear trend via least\u2011squares fit.\"\"\"\n    x_arr = _to_numpy(x)\n    n = x_arr.size\n    if n == 0:\n        return x_arr\n    t = np.arange(n, dtype=float)\n    a, b = np.linalg.lstsq(\n        np.vstack([t, np.ones_like(t)]).T, x_arr, rcond=None\n    )[0]\n    return x_arr - (a * t + b)\n\n\ndef enhanced_filter_with_trend_preservation(x: object, w: int) -> np.ndarray:\n    \"\"\"\n    Detrend the signal linearly, then apply a Gaussian\u2011weighted moving average.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    detrended = _linear_detrend(x_arr)\n    return weighted_filter(detrended, w)\n\n\ndef combined_filter(x: object, w: int = 20) -> np.ndarray:\n    \"\"\"\n    Pipeline: linear detrend \u2192 Gaussian weighted average \u2192 median smoothing.\n    Returns an empty array if any stage fails.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n\n    detrended = _linear_detrend(x_arr)\n    weighted = weighted_filter(detrended, w)\n    if weighted.size == 0:\n        return np.array([], dtype=float)\n\n    return median_filter(weighted, w)\n\n\ndef _residual_variance(orig: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"\n    Compute variance of (orig \u2013 filtered) over the overlapping region.\n    Returns ``inf`` for empty overlap to penalise invalid solutions.\n    \"\"\"\n    n = min(len(orig), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(orig[:n] - filtered[:n]))\n\n\ndef _select_best_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"\n    Evaluate all available filters and return the output with the lowest residual variance.\n    Deterministic tie\u2011breaking is performed by alphabetical order of filter names.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    candidates = {\n        \"basic\": adaptive_filter(x_arr, w),\n        \"weighted\": weighted_filter(x_arr, w),\n        \"ema\": ema_filter(x_arr, w),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x_arr, w),\n        \"combined\": combined_filter(x_arr, w),\n    }\n    # Choose the filter with minimal residual variance; break ties alphabetically\n    best_name = min(\n        candidates,\n        key=lambda k: (_residual_variance(x_arr, candidates[k]), k)\n    )\n    return candidates[best_name]\n\n\ndef process_signal(sig: object, w: int = 20, alg: str = \"combined\") -> np.ndarray:\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Supported ``alg`` values:\n        - \"basic\": simple moving average\n        - \"weighted\": Gaussian weighted moving average\n        - \"ema\": classic exponential moving average\n        - \"enhanced\": automatic best\u2011filter selection\n        - \"combined\": linear detrend \u2192 weighted \u2192 median\n        - any other value: automatic selection of the best filter\n    \"\"\"\n    if alg == \"basic\":\n        return adaptive_filter(sig, w)\n    if alg == \"weighted\":\n        return weighted_filter(sig, w)\n    if alg == \"ema\":\n        return ema_filter(sig, w)\n    if alg == \"combined\":\n        return combined_filter(sig, w)\n    if alg == \"enhanced\":\n        # Treat \"enhanced\" as a request for the most effective filter\n        return _select_best_filter(sig, w)\n\n    # Fallback: automatic selection\n    return _select_best_filter(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 3 (Score: 14.0152, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_np(x):\n    return np.asarray(x, dtype=float).ravel()\n\ndef _ma(x, w):\n    a = _to_np(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef process_signal(input_signal, window_size: int = 20, algorithm_type: str = \"combined\") -> np.ndarray:\n    \"\"\"Return a simple moving\u2011average filter regardless of algorithm_type.\"\"\"\n    return _ma(input_signal, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_numpy(x):\n    \"\"\"Convert input to a 1\u2011D float ndarray.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(w):\n    \"\"\"Ensure the window size is a positive integer.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window_size must be a positive integer\")\n\n\ndef _ma(x, w):\n    \"\"\"Simple moving\u2011average filter (valid convolution).\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(arr, np.ones(w) / w, mode=\"valid\")\n\n\ndef _gaussian(x, w):\n    \"\"\"Weighted moving\u2011average with a Gaussian kernel.\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w)\n    weights = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    weights /= weights.sum()\n    return np.convolve(arr, weights, mode=\"valid\")\n\n\ndef _ema(x, w):\n    \"\"\"Exponential moving average aligned to MA length.\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(arr)\n    ema[0] = arr[0]\n    for i in range(1, arr.size):\n        ema[i] = alpha * arr[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef _median(x, w):\n    \"\"\"Median filter over a sliding window.\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    stride = arr.strides[0]\n    shape = (arr.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(arr, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef _residual_variance(orig, filt):\n    \"\"\"Mean variance of the difference between original and filtered signals.\"\"\"\n    if filt.size == 0:\n        return float(\"inf\")\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n]))\n\n\ndef _best_filter(x, w):\n    \"\"\"Select the filter with the lowest residual variance.\"\"\"\n    orig = _to_numpy(x)\n    candidates = {\n        \"ma\": _ma(orig, w),\n        \"gaussian\": _gaussian(orig, w),\n        \"ema\": _ema(orig, w),\n        \"median\": _median(orig, w),\n    }\n    # Prefer the candidate with minimal residual variance; fall back to MA if all fail\n    best = min(candidates.values(), key=lambda f: _residual_variance(orig, f))\n    return best if best.size else _ma(orig, w)\n\n\ndef process_signal(sig, w=20, algorithm_type=\"combined\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        - \"basic\" or \"ma\": simple moving average\n        - \"weighted\": Gaussian weighted average\n        - \"ema\": exponential moving average\n        - \"median\": median filter\n        - \"enhanced\", \"combined\", \"auto\": automatic selection of the best filter\n    Any other value falls back to the automatic selection.\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"basic\", \"ma\"):\n        return _ma(sig, w)\n    if alg == \"weighted\":\n        return _gaussian(sig, w)\n    if alg == \"ema\":\n        return _ema(sig, w)\n    if alg == \"median\":\n        return _median(sig, w)\n    # enhanced / combined / auto / unknown -> best filter\n    return _best_filter(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["import numpy as np\n\ndef _to_numpy(x):\n    \"\"\"Convert input to a 1\u2011D float ndarray.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(w):\n    \"\"\"Ensure the window size is a positive integer.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window_size must be a positive integer\")\n\n\ndef _ma(x, w):\n    \"\"\"Simple moving\u2011average filter (valid convolution).\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(arr, np.ones(w) / w, mode=\"valid\")\n\n\ndef _gaussian(x, w):\n    \"\"\"Weighted moving\u2011average with a Gaussian kernel.\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w)\n    weights = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    weights /= weights.sum()\n    return np.convolve(arr, weights, mode=\"valid\")\n\n\ndef _ema(x, w):\n    \"\"\"Exponential moving average aligned to MA length.\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(arr)\n    ema[0] = arr[0]\n    for i in range(1, arr.size):\n        ema[i] = alpha * arr[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef _median(x, w):\n    \"\"\"Median filter over a sliding window.\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    stride = arr.strides[0]\n    shape = (arr.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(arr, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef _residual_variance(orig, filt):\n    \"\"\"Mean variance of the difference between original and filtered signals.\"\"\"\n    if filt.size == 0:\n        return float(\"inf\")\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n]))\n\n\ndef _best_filter(x, w):\n    \"\"\"\n    Return the single filter with the lowest residual variance.\n    Deterministic tie\u2011breaking uses alphabetical order of filter names.\n    \"\"\"\n    orig = _to_numpy(x)\n    candidates = {\n        \"ma\": _ma(orig, w),\n        \"gaussian\": _gaussian(orig, w),\n        \"ema\": _ema(orig, w),\n        \"median\": _median(orig, w),\n    }\n    # Keep only non\u2011empty results\n    filtered = [(name, arr) for name, arr in candidates.items() if arr.size]\n    if not filtered:\n        return np.array([], dtype=float)\n\n    # Compute variances\n    metrics = [( _residual_variance(orig, arr), name, arr) for name, arr in filtered]\n    # Sort by variance then name for deterministic choice\n    metrics.sort(key=lambda t: (t[0], t[1]))\n    return metrics[0][2]\n\n\ndef _ensemble_best(x, w, top_n=2):\n    \"\"\"\n    Combine the top `top_n` filters (by residual variance) using\n    inverse\u2011variance weighting. Deterministic tie\u2011breaks ensure reproducibility.\n    \"\"\"\n    orig = _to_numpy(x)\n    candidates = {\n        \"ma\": _ma(orig, w),\n        \"gaussian\": _gaussian(orig, w),\n        \"ema\": _ema(orig, w),\n        \"median\": _median(orig, w),\n    }\n    filtered = [(name, arr) for name, arr in candidates.items() if arr.size]\n    if not filtered:\n        return np.array([], dtype=float)\n\n    metrics = [( _residual_variance(orig, arr), name, arr) for name, arr in filtered]\n    metrics.sort(key=lambda t: (t[0], t[1]))\n    top = metrics[:min(top_n, len(metrics))]\n\n    variances = np.array([m[0] for m in top], dtype=float)\n    # If any variance is zero (perfect fit) give it full weight\n    if np.any(variances == 0):\n        weights = np.where(variances == 0, 1.0, 0.0)\n    else:\n        inv = 1.0 / variances\n        weights = inv / inv.sum()\n\n    combined = sum(wt * arr for wt, (_, _, arr) in zip(weights, top))\n    return combined\n\n\ndef process_signal(sig, w=20, algorithm_type=\"combined\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        - \"basic\" or \"ma\": simple moving average\n        - \"weighted\": Gaussian weighted average\n        - \"ema\": exponential moving average\n        - \"median\": median filter\n        - \"best\": automatic selection of the single best filter\n        - \"combined\", \"ensemble\", \"auto\", \"enhanced\": weighted ensemble of top filters\n        - any other value falls back to the ensemble approach.\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"basic\", \"ma\"):\n        return _ma(sig, w)\n    if alg == \"weighted\":\n        return _gaussian(sig, w)\n    if alg == \"ema\":\n        return _ema(sig, w)\n    if alg == \"median\":\n        return _median(sig, w)\n    if alg == \"best\":\n        return _best_filter(sig, w)\n    # combined / ensemble / auto / enhanced / unknown -> ensemble of top filters\n    return _ensemble_best(sig, w)"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}