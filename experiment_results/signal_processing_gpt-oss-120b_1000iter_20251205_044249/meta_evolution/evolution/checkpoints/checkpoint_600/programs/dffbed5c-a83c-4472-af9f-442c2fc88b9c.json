{"id": "dffbed5c-a83c-4472-af9f-442c2fc88b9c", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef _exp_weights(w):\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef _to_arr(x):\n    return np.asarray(x, float)\n\ndef adaptive(x, w=20):\n    a = _to_arr(x)\n    if w <= 0 or a.size < w:\n        return np.empty(0, float)\n    return np.convolve(a, np.ones(w) / w, \"valid\")\n\ndef weighted(x, w=20):\n    a = _to_arr(x)\n    if w <= 0 or a.size < w:\n        return np.empty(0, float)\n    return np.convolve(a, _exp_weights(w), \"valid\")\n\ndef ema(x, w=20):\n    a = _to_arr(x)\n    if w <= 0 or a.size < w:\n        return np.empty(0, float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(a)\n    e[0] = a[0]\n    for i in range(1, len(a)):\n        e[i] = alpha * a[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\ndef enhanced(x, w=20):\n    tr = adaptive(x, w)\n    if tr.size == 0:\n        return np.empty(0, float)\n    tf = np.concatenate((np.full(w - 1, tr[0]), tr))\n    return weighted(x - tf, w)\n\ndef median_filter(x, w=20):\n    a = _to_arr(x)\n    if w <= 0 or a.size < w:\n        return np.empty(0, float)\n    if w % 2 == 0:\n        w += 1\n    shape = (a.size - w + 1, w)\n    strides = (a.strides[0], a.strides[0])\n    win = np.lib.stride_tricks.as_strided(a, shape, strides)\n    return np.median(win, axis=1)\n\ndef fft_denoise(x, keep_ratio=0.1):\n    a = _to_arr(x)\n    n = a.size\n    if n == 0:\n        return np.empty(0, float)\n    coeffs = np.fft.rfft(a)\n    mags = np.abs(coeffs)\n    k = max(1, int(len(mags) * keep_ratio))\n    idx = np.argpartition(mags, -k)[-k:]\n    mask = np.zeros_like(mags, bool)\n    mask[idx] = True\n    filtered = np.where(mask, coeffs, 0)\n    return np.fft.irfft(filtered, n=n)\n\ndef _var(o, f):\n    n = min(len(o), len(f))\n    return float(np.var(o[:n] - f[:n])) if n else float(\"inf\")\n\ndef _corr(o, f):\n    n = min(len(o), len(f))\n    if n < 2:\n        return -np.inf\n    return np.corrcoef(o[:n], f[:n])[0, 1]\n\ndef process_signal(sig, w=20, alg=\"enh\"):\n    a = alg.lower()\n    if a in (\"basic\", \"adaptive\"):\n        return adaptive(sig, w)\n    if a == \"weighted\":\n        return weighted(sig, w)\n    if a in (\"ema\", \"exponential\"):\n        return ema(sig, w)\n    if a in (\"enh\", \"enhanced\"):\n        return enhanced(sig, w)\n    if a in (\"median\", \"med\"):\n        return median_filter(sig, w)\n    if a in (\"fft\", \"spectral\"):\n        return fft_denoise(sig, 0.1)\n    # automatic selection\n    cand = {\n        \"a\": adaptive(sig, w),\n        \"w\": weighted(sig, w),\n        \"e\": ema(sig, w),\n        \"h\": enhanced(sig, w),\n        \"m\": median_filter(sig, w),\n        \"f\": fft_denoise(sig, 0.1),\n    }\n    cand = {k: v for k, v in cand.items() if v.size}\n    if not cand:\n        return np.empty(0, float)\n    best = min(cand, key=lambda k: (_var(sig, cand[k]), -_corr(sig, cand[k])))\n    return cand[best]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "3ee84eaf-d193-4069-a582-d2f1c4cdc53d", "generation": 6, "timestamp": 1764941058.801573, "iteration_found": 572, "metrics": {"runs_successfully": 1.0, "composite_score": 0.4429433309255678, "output_length": 91.0, "overall_score": 0.3624766970140094, "slope_changes": 68.6, "lag_error": 0.4099887786960041, "avg_error": 1.1150775516528053, "false_reversals": 56.6, "correlation": 0.20076318890739916, "noise_reduction": 0.0, "smoothness_score": 0.22573363431151244, "responsiveness_score": 0.709225502436145, "accuracy_score": 0.20076318890739916, "efficiency_score": 1.0, "execution_time": 0.0004943370819091797, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.4429433309255678, "output_length": 91.0, "overall_score": 0.3624766970140094, "slope_changes": 68.6, "lag_error": 0.4099887786960041, "avg_error": 1.1150775516528053, "false_reversals": 56.6, "correlation": 0.20076318890739916, "noise_reduction": 0.0, "smoothness_score": 0.22573363431151244, "responsiveness_score": 0.709225502436145, "accuracy_score": 0.20076318890739916, "efficiency_score": 1.0, "execution_time": 0.0006945133209228516, "success_rate": 1.0}, "island": 4}, "prompts": {"full_rewrite_user": {"system": "## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)\n## OUTPUT FORMAT (CRITICAL)\n- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers\n- Do NOT include the markers themselves in your output\n- Do NOT include any code outside the markers (imports, run_packing, etc.)\n- The system will automatically merge your output with the preserved code sections\n\n## FOCUS\n- Improve ONLY the `construct_packing()` function and helper functions within the evolve block\n- Functions like `run_packing()` are preserved automatically - do not include them\n\nViolating these requirements will cause the program to fail evaluation.\n\n---\n\n**System Message \u2013 Guidance for Evolving `construct_packing()`**\n\nYou are tasked with improving the `construct_packing()` function and any helper functions that reside inside the **evolve block** (the region delimited by `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`). The rest of the program (imports, `run_packing()`, etc.) is preserved automatically and must **not** be altered.\n\n---\n\n### \u2705 What You Must Do\n1. **Output ONLY the code** that belongs between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.  \n   - Do **not** include the marker comments themselves.  \n   - Do **not** output any imports, top\u2011level statements, or code outside the evolve block.\n\n2. **Focus exclusively on `construct_packing()`** and any helper functions it calls that are also inside the evolve block.  \n   - Do not modify other parts of the program.\n\n3. **Maintain the original function signatures** and return types. The surrounding code expects these signatures to remain unchanged.\n\n4. **Write clear, deterministic logic** that:\n   - Validates inputs (e.g., non\u2011empty item list, positive dimensions).  \n   - Handles edge cases gracefully (empty containers, items larger than any container).  \n   - Produces a packing plan that respects container capacity, item orientation constraints, and any weight limits defined elsewhere in the program.  \n   - Returns a data structure consistent with what `run_packing()` expects (e.g., a list of placement tuples or a dictionary).\n\n5. **Add inline comments** that explain the purpose of each major step, but keep the overall code concise.\n\n6. **Avoid any of the following failed approaches** (they caused repeated invalid programs in earlier iterations):\n   - Writing overly aggressive or vague prompts that do not respect the output\u2011format constraints.  \n   - Producing code that references symbols outside the evolve block (e.g., undefined globals, missing imports).  \n   - Introducing syntax errors, mismatched indentation, or incomplete statements.  \n   - Generating code that attempts to rewrite the outer scaffolding (`run_packing()`, imports, etc.).  \n\n---\n\n### \ud83d\udca1 Suggested Strategies to Try\n\n- **Step\u2011wise construction**: Build the packing plan incrementally\u2014first filter out impossible items, then sort items by size/weight, then greedily place them into containers while checking capacity constraints.\n- **Helper decomposition**: If `construct_packing()` becomes large, factor out reusable pieces (e.g., `_can_fit(item, container)`, `_select_container(item, containers)`) **inside** the evolve block. Keep each helper pure and self\u2011contained.\n- **Deterministic tie\u2011breaking**: When multiple containers can hold an item, choose the one with the smallest remaining volume or weight capacity to improve packing density.\n- **Safety checks**: At the start of `construct_packing()`, assert that required keys exist in the input dictionaries; raise a clear `ValueError` if not.\n- **Return format validation**: Before returning, optionally perform a lightweight sanity check (e.g., ensure no item is assigned to more than one container, total weight per container does not exceed limits). This helps catch logical bugs without affecting external code.\n\n---\n\n### \ud83d\udccf Output Formatting Reminder (Critical)\n\nYour response **must** consist solely of the revised Python code that belongs inside the evolve block:\n\n```python\n# EVOLVE-BLOCK-START\n<your updated code here>\n# EVOLVE-BLOCK-END\n```\n\nDo **not** include the `# EVOLVE-BLOCK-START` or `# EVOLVE-BLOCK-END` lines themselves, and do not add any additional text, explanations, or markdown formatting. The system will insert your code back into the original file automatically.", "user": "# Current Program Information\n- Fitness: 13.9292\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 14.0152 \u2192 13.9292. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4205, output_length: 91.0000, overall_score: 0.3804, slope_changes: 68.0000, lag_error: 0.9780, avg_error: 1.2635, false_reversals: 57.8000, correlation: 0.3335, noise_reduction: 0.0000, smoothness_score: 0.2273, responsiveness_score: 0.5056, accuracy_score: 0.3335, efficiency_score: 1.0000, execution_time: 0.0004, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4205, output_length: 91.0000, overall_score: 0.3804, slope_changes: 68.0000, lag_error: 0.9780, avg_error: 1.2635, false_reversals: 57.8000, correlation: 0.3335, noise_reduction: 0.0000, smoothness_score: 0.2273, responsiveness_score: 0.5056, accuracy_score: 0.3335, efficiency_score: 1.0000, execution_time: 0.0005, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4205, output_length: 91.0000, overall_score: 0.3804, slope_changes: 68.0000, lag_error: 0.9780, avg_error: 1.2635, false_reversals: 57.8000, correlation: 0.3335, noise_reduction: 0.0000, smoothness_score: 0.2273, responsiveness_score: 0.5056, accuracy_score: 0.3335, efficiency_score: 1.0000, execution_time: 0.0005, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_array(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _valid(arr, w):\n    \"\"\"Return True if window size is positive and fits the array.\"\"\"\n    return w > 0 and arr.size >= w\n\n\ndef adaptive(x, w=20):\n    \"\"\"Simple moving\u2011average filter (valid convolution).\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted(x, w=20):\n    \"\"\"Exponential\u2011weighted moving average.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    wts = np.exp(np.linspace(-2, 0, w))\n    wts /= wts.sum()\n    return np.convolve(a, wts, mode=\"valid\")\n\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Supported ``alg`` values (case\u2011insensitive):\n        - \"basic\" / \"adaptive\"\n        - \"weighted\"\n        - \"auto\" \u2013 automatic selection based on signal variance\n    Unknown values fall back to the adaptive filter.\n    \"\"\"\n    key = str(alg).lower()\n    if key in (\"basic\", \"adaptive\"):\n        return adaptive(sig, w)\n    if key == \"weighted\":\n        return weighted(sig, w)\n    if key == \"auto\":\n        a = _to_array(sig)\n        if not _valid(a, w):\n            return np.empty(0, dtype=float)\n        # Heuristic: use weighted filter for higher\u2011variance signals\n        return weighted(sig, w) if np.var(a) > 1.0 else adaptive(sig, w)\n\n    # Fallback to adaptive for any unrecognised algorithm name\n    return adaptive(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4205), Performs well on output_length (91.0000), Performs well on overall_score (0.3804), Performs well on slope_changes (68.0000), Performs well on lag_error (0.9780), Performs well on avg_error (1.2635), Performs well on false_reversals (57.8000), Performs well on correlation (0.3335), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2273), Performs well on responsiveness_score (0.5056), Performs well on accuracy_score (0.3335), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0005), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _arr(x):\n    return np.asarray(x, float).ravel()\n\ndef _ok(a, w):\n    return w > 0 and a.size >= w\n\ndef _simple(x, w):\n    a = _arr(x)\n    return np.convolve(a, np.ones(w) / w, \"valid\") if _ok(a, w) else np.empty(0)\n\ndef _weighted(x, w):\n    a = _arr(x)\n    if not _ok(a, w):\n        return np.empty(0)\n    wts = np.exp(np.linspace(-2, 0, w))\n    wts /= wts.sum()\n    return np.convolve(a, wts, \"valid\")\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    k = str(alg).lower()\n    return _weighted(sig, w) if k == \"weighted\" else _simple(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4205), Performs well on output_length (91.0000), Performs well on overall_score (0.3804), Performs well on slope_changes (68.0000), Performs well on lag_error (0.9780), Performs well on avg_error (1.2635), Performs well on false_reversals (57.8000), Performs well on correlation (0.3335), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2273), Performs well on responsiveness_score (0.5056), Performs well on accuracy_score (0.3335), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0005), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _arr(x):\n    return np.asarray(x, float).ravel()\n\ndef _valid(a, w):\n    return w > 0 and a.size >= w\n\ndef adaptive(x, w=20):\n    a = _arr(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted(x, w=20):\n    a = _arr(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    wts = np.exp(np.linspace(-2, 0, w))\n    wts /= wts.sum()\n    return np.convolve(a, wts, mode=\"valid\")\n\ndef _auto(sig, w):\n    a = _arr(sig)\n    return weighted if np.var(a) > 1 else adaptive\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    key = str(alg).lower()\n    if key == \"auto\":\n        return _auto(sig, w)(sig, w)\n    if key in (\"adaptive\", \"enhanced\"):\n        return adaptive(sig, w)\n    if key == \"weighted\":\n        return weighted(sig, w)\n    raise ValueError(f\"Unsupported algorithm_type: {alg}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4205), Performs well on output_length (91.0000), Performs well on overall_score (0.3804), Performs well on slope_changes (68.0000), Performs well on lag_error (0.9780), Performs well on avg_error (1.2635), Performs well on false_reversals (57.8000), Performs well on correlation (0.3335), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2273), Performs well on responsiveness_score (0.5056), Performs well on accuracy_score (0.3335), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0004), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 13.9626)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _to_array(x, w):\n    \"\"\"Convert input to 1\u2011D float array; return empty if window invalid.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        return np.empty(0, dtype=float)\n    a = np.asarray(x, float).ravel()\n    return a if a.size >= w else np.empty(0, dtype=float)\n\n@lru_cache(None)\ndef _exp_weights(w):\n    \"\"\"Exponential weights that sum to 1 (right\u2011biased).\"\"\"\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef adaptive(x, w=20):\n    \"\"\"Simple moving\u2011average filter.\"\"\"\n    a = _to_array(x, w)\n    if a.size == 0:\n        return a\n    return a.copy() if w == 1 else np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted(x, w=20):\n    \"\"\"Exponential\u2011weighted moving average.\"\"\"\n    a = _to_array(x, w)\n    if a.size == 0:\n        return a\n    return a.copy() if w == 1 else np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef enhanced_blend(x, w=20):\n    \"\"\"Blend simple and exponential weighted averages.\"\"\"\n    a = _to_array(x, w)\n    if a.size == 0:\n        return a\n    if w == 1:\n        return a.copy()\n    e = np.convolve(a, _exp_weights(w)[::-1], mode=\"valid\")\n    m = np.convolve(a, np.ones(w) / w, mode=\"valid\")\n    return (e + m) / 2.0\n\ndef median(x, w=21):\n    \"\"\"Median filter (odd window).\"\"\"\n    if w % 2 == 0:\n        w += 1\n    a = _to_array(x, w)\n    if a.size == 0:\n        return a\n    if w == 1:\n        return a.copy()\n    s = a.strides[0]\n    win = np.lib.stride_tricks.as_strided(a, (a.size - w + 1, w), (s, s))\n    return np.median(win, axis=1)\n\ndef hybrid(x, w=20):\n    \"\"\"Median filter followed by blended enhanced smoothing.\"\"\"\n    med = median(x, w if w % 2 else w + 1)\n    return enhanced_blend(med, w)\n\ndef _residual_variance(original, filtered):\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return np.inf\n    return float(np.var(original[:n] - filtered[:n]))\n\ndef process_signal(sig, w=20, alg=\"auto\"):\n    \"\"\"Dispatch to the requested filtering algorithm.\"\"\"\n    key = str(alg).lower()\n    if key == \"adaptive\":\n        return adaptive(sig, w)\n    if key == \"weighted\":\n        return weighted(sig, w)\n    if key in (\"enhanced\", \"blend\"):\n        return enhanced_blend(sig, w)\n    if key == \"median\":\n        return median(sig, w)\n    if key == \"hybrid\":\n        return hybrid(sig, w)\n\n    # auto\u2011selection based on residual variance\n    candidates = {\n        \"adaptive\": adaptive(sig, w),\n        \"weighted\": weighted(sig, w),\n        \"enhanced\": enhanced_blend(sig, w),\n        \"median\": median(sig, w),\n        \"hybrid\": hybrid(sig, w),\n    }\n    # keep only non\u2011empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best = min(candidates, key=lambda k: _residual_variance(sig, candidates[k]))\n    return candidates[best]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 13.9626)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _as_arr(x, w):\n    a = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be >0\")\n    if a.ndim != 1:\n        raise ValueError(\"1\u2011D array required\")\n    if a.size < w:\n        raise ValueError(\"signal shorter than window\")\n    return a\n\n@lru_cache(None)\ndef _exp_weights(w):\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef adaptive(x, w=20):\n    a = _as_arr(x, w)\n    return a.copy() if w == 1 else np.convolve(a, np.ones(w) / w, \"valid\")\n\ndef enhanced(x, w=20):\n    a = _as_arr(x, w)\n    return a.copy() if w == 1 else np.convolve(a, _exp_weights(w)[::-1], \"valid\")\n\ndef enhanced_blend(x, w=20):\n    \"\"\"Blend simple and exponential weighted averages.\"\"\"\n    a = _as_arr(x, w)\n    if w == 1:\n        return a.copy()\n    e = np.convolve(a, _exp_weights(w)[::-1], \"valid\")\n    m = np.convolve(a, np.ones(w) / w, \"valid\")\n    # both outputs have same length (len(a)-w+1)\n    return (e + m) / 2.0\n\ndef median(x, w=21):\n    if w % 2 == 0:\n        w += 1\n    a = _as_arr(x, w)\n    if w == 1:\n        return a.copy()\n    s = a.strides[0]\n    win = np.lib.stride_tricks.as_strided(a, (a.size - w + 1, w), (s, s))\n    return np.median(win, axis=1)\n\ndef hybrid(x, w=20):\n    \"\"\"Median filter followed by blended enhanced smoothing.\"\"\"\n    med = median(x, w if w % 2 else w + 1)\n    return enhanced_blend(med, w)\n\ndef _residual_variance(original, filtered):\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return np.inf\n    return float(np.var(original[:n] - filtered[:n]))\n\ndef process_signal(sig, w=20, alg=\"auto\"):\n    a = alg.lower()\n    if a == \"adaptive\":\n        return adaptive(sig, w)\n    if a == \"enhanced\":\n        return enhanced_blend(sig, w)\n    if a == \"median\":\n        return median(sig, w)\n    if a == \"hybrid\":\n        return hybrid(sig, w)\n\n    # auto\u2011selection: evaluate candidates and pick lowest residual variance\n    candidates = {\n        \"adaptive\": adaptive(sig, w),\n        \"enhanced\": enhanced_blend(sig, w),\n        \"median\": median(sig, w),\n        \"hybrid\": hybrid(sig, w),\n    }\n    # discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best = min(candidates, key=lambda k: _residual_variance(sig, candidates[k]))\n    return candidates[best]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 13.9292, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_array(x):\n    \"\"\"Convert input to a NumPy float array.\"\"\"\n    return np.asarray(x, dtype=float)\n\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"\n    Simple moving\u2011average filter.\n    Returns an empty array if the window does not fit.\n    \"\"\"\n    x = _to_array(x)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.empty(0, dtype=float)\n    kernel = np.ones(window_size) / window_size\n    return np.convolve(x, kernel, mode=\"valid\")\n\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"\n    Exponential weighted moving\u2011average filter.\n    Returns an empty array if the window does not fit.\n    \"\"\"\n    x = _to_array(x)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.empty(0, dtype=float)\n    weights = np.exp(np.linspace(-2, 0, window_size))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema_filter(x, window_size=20):\n    \"\"\"\n    Classic exponential moving average (EMA).\n    Returns an empty array if the window does not fit.\n    \"\"\"\n    x = _to_array(x)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.empty(0, dtype=float)\n    alpha = 2.0 / (window_size + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[window_size - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"\n    Detrend with a simple moving average, then apply a weighted filter.\n    Returns an empty array if the window does not fit.\n    \"\"\"\n    x = _to_array(x)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.empty(0, dtype=float)\n    trend = adaptive_filter(x, window_size)\n    trend_full = np.concatenate((np.full(window_size - 1, trend[0]), trend))\n    detrended = x - trend_full\n    return weighted_filter(detrended, window_size)\n\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"\n    Variance of the residual (original - filtered) over the overlapping region.\n    Returns a large number if there is no overlap.\n    \"\"\"\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(original[:n] - filtered[:n]))\n\n\ndef _select_best_filter(x, window_size):\n    \"\"\"\n    Evaluate all filters and return the one with the smallest residual variance.\n    \"\"\"\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n    }\n    raw = _to_array(x)\n    best_name = min(candidates, key=lambda k: _residual_variance(raw, candidates[k]))\n    return candidates[best_name]\n\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"auto\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n    Supported types:\n        - \"basic\": simple moving average\n        - \"weighted\": exponential weighted moving average\n        - \"ema\": classic exponential moving average\n        - \"enhanced\": detrended weighted filter\n        - any other value (including \"auto\"): automatic selection of the best filter\n    \"\"\"\n    if algorithm_type == \"basic\":\n        return adaptive_filter(input_signal, window_size)\n    if algorithm_type == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if algorithm_type == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if algorithm_type == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(input_signal, window_size)\n\n    # Fallback: automatic selection based on residual variance\n    return _select_best_filter(input_signal, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 2 (Score: 13.6541, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_array(x):\n    \"\"\"Convert input to 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _valid(arr, w):\n    \"\"\"Check that window size is positive and fits the array.\"\"\"\n    return w > 0 and arr.size >= w\n\n\ndef _pad_result(res, w, orig_len):\n    \"\"\"Pad the beginning of a shortened result so it matches the original length.\"\"\"\n    if res.size == 0:\n        return res\n    if res.size < orig_len:\n        pad_len = orig_len - res.size\n        pad = np.full(pad_len, res[0], dtype=res.dtype)\n        return np.concatenate((pad, res))\n    return res\n\n\ndef _conv_adaptive(x, w):\n    \"\"\"Raw moving\u2011average convolution (valid output).\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\n\ndef adaptive(x, w=20):\n    \"\"\"Simple moving\u2011average filter with start\u2011padding.\"\"\"\n    a = _to_array(x)\n    orig_len = a.size\n    res = _conv_adaptive(a, w)\n    return _pad_result(res, w, orig_len)\n\n\ndef _conv_weighted(x, w):\n    \"\"\"Raw exponential\u2011weighted convolution (valid output).\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    wts = np.exp(np.linspace(-2, 0, w))\n    wts /= wts.sum()\n    return np.convolve(a, wts, mode=\"valid\")\n\n\ndef weighted(x, w=20):\n    \"\"\"Exponential weighted moving average with start\u2011padding.\"\"\"\n    a = _to_array(x)\n    orig_len = a.size\n    res = _conv_weighted(a, w)\n    return _pad_result(res, w, orig_len)\n\n\ndef ema(x, w=20):\n    \"\"\"Classic exponential moving average with start\u2011padding.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(a)\n    e[0] = a[0]\n    for i in range(1, len(a)):\n        e[i] = alpha * a[i] + (1 - alpha) * e[i - 1]\n    res = e[w - 1 :]\n    return _pad_result(res, w, a.size)\n\n\ndef enhanced(x, w=20):\n    \"\"\"Detrend with simple moving average then apply weighted smoothing (padded).\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    # raw trend (valid length)\n    trend = _conv_adaptive(a, w)\n    if trend.size == 0:\n        return np.empty(0, dtype=float)\n    # extend trend to full length by repeating its first value\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    # apply weighted filter to detrended signal\n    res = _conv_weighted(a - trend_full, w)\n    return _pad_result(res, w, a.size)\n\n\ndef fft_denoise(x, keep_ratio=0.1):\n    \"\"\"Spectral denoising via FFT with start\u2011padding.\"\"\"\n    a = _to_array(x)\n    n = a.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n\n    coeffs = np.fft.rfft(a)\n    mags = np.abs(coeffs)\n    k = max(1, int(len(mags) * keep_ratio))\n    idx = np.argpartition(mags, -k)[-k:]\n    mask = np.zeros_like(mags, dtype=bool)\n    mask[idx] = True\n    filtered = np.where(mask, coeffs, 0)\n    return np.fft.irfft(filtered, n=n)\n\n\ndef median_filter(x, w=20):\n    \"\"\"Median filter with start\u2011padding.\"\"\"\n    a = _to_array(x)\n    orig_len = a.size\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w % 2 == 0:\n        w += 1\n    shape = (a.size - w + 1, w)\n    strides = (a.strides[0], a.strides[0])\n    win = np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)\n    res = np.median(win, axis=1)\n    return _pad_result(res, w, orig_len)\n\n\ndef hybrid(x, w=20):\n    \"\"\"Weighted filter followed by median filter (both padded).\"\"\"\n    return median_filter(weighted(x, w), w)\n\n\ndef _residual_variance(orig, filt):\n    \"\"\"Variance of the residual over the overlapping region.\"\"\"\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(orig[:n] - filt[:n]))\n\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    w : int, optional\n        Window size for window\u2011based filters (default 20).\n    alg : str, optional\n        Algorithm identifier:\n        - \"adaptive\"\n        - \"weighted\"\n        - \"ema\"\n        - \"enhanced\"\n        - \"median\"\n        - \"hybrid\"\n        - \"fft\"\n        - \"auto\" \u2013 automatic selection based on residual variance\n        - any unknown value falls back to automatic selection.\n    \"\"\"\n    a = str(alg).lower()\n    if a == \"auto\":\n        # automatic selection\n        candidates = {\n            \"adaptive\": adaptive(sig, w),\n            \"weighted\": weighted(sig, w),\n            \"ema\": ema(sig, w),\n            \"enhanced\": enhanced(sig, w),\n            \"median\": median_filter(sig, w),\n            \"hybrid\": hybrid(sig, w),\n            \"fft\": fft_denoise(sig, keep_ratio=0.1),\n        }\n        candidates = {k: v for k, v in candidates.items() if v.size}\n        if not candidates:\n            return np.empty(0, dtype=float)\n        best = min(candidates, key=lambda k: _residual_variance(sig, candidates[k]))\n        return candidates[best]\n\n    # direct mapping\n    if a in (\"basic\", \"adaptive\"):\n        return adaptive(sig, w)\n    if a == \"weighted\":\n        return weighted(sig, w)\n    if a in (\"ema\", \"exponential\"):\n        return ema(sig, w)\n    if a in (\"enh\", \"enhanced\"):\n        return enhanced(sig, w)\n    if a in (\"median\", \"med\"):\n        return median_filter(sig, w)\n    if a == \"hybrid\":\n        return hybrid(sig, w)\n    if a in (\"fft\", \"spectral\"):\n        return fft_denoise(sig, keep_ratio=0.1)\n\n    # unknown identifier \u2013 fall back to auto\u2011selection\n    return process_signal(sig, w, alg=\"auto\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 3 (Score: 13.7886, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_array(x):\n    \"\"\"Convert input to 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(w):\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n\n\ndef adaptive_filter(x, w=20):\n    \"\"\"Simple moving\u2011average (valid convolution).\"\"\"\n    _validate_window(w)\n    a = _to_array(x)\n    if a.size < w:\n        return np.empty(0, dtype=float)\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted_filter(x, w=20):\n    \"\"\"Exponential\u2011weighted moving average.\"\"\"\n    _validate_window(w)\n    a = _to_array(x)\n    if a.size < w:\n        return np.empty(0, dtype=float)\n    wt = np.exp(np.linspace(-2, 0, w))\n    wt /= wt.sum()\n    return np.convolve(a, wt, mode=\"valid\")\n\n\ndef ema_filter(x, w=20):\n    \"\"\"Classic exponential moving average (EMA).\"\"\"\n    _validate_window(w)\n    a = _to_array(x)\n    if a.size < w:\n        return np.empty(0, dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef median_filter(x, w=20):\n    \"\"\"Median filter using a sliding window (odd size).\"\"\"\n    _validate_window(w)\n    a = _to_array(x)\n    if a.size < w:\n        return np.empty(0, dtype=float)\n    if w % 2 == 0:  # enforce odd window for symmetric median\n        w += 1\n    shape = (a.size - w + 1, w)\n    strides = (a.strides[0], a.strides[0])\n    windows = np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)\n    return np.median(windows, axis=1)\n\n\ndef enhanced_filter_with_trend_preservation(x, w=20):\n    \"\"\"\n    Detrend using a simple moving average, smooth the detrended signal,\n    then re\u2011add the aligned trend segment.\n    \"\"\"\n    _validate_window(w)\n    a = _to_array(x)\n    if a.size < w:\n        return np.empty(0, dtype=float)\n\n    # Estimate local trend\n    trend = adaptive_filter(a, w)\n    if trend.size == 0:\n        return np.empty(0, dtype=float)\n\n    # Pad trend to original length (repeat edge values)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n\n    # Remove trend, smooth residual, and add back aligned trend\n    detrended = a - trend_full\n    smoothed = weighted_filter(detrended, w)\n    # Align trend segment with smoothed output\n    aligned_trend = trend_full[w - 1 :]\n    return smoothed + aligned_trend\n\n\ndef _correlation_score(orig, filt):\n    \"\"\"Absolute Pearson correlation over the overlapping region.\"\"\"\n    n = min(len(orig), len(filt))\n    if n < 2:\n        return -np.inf\n    corr = np.corrcoef(orig[:n], filt[:n])[0, 1]\n    return abs(corr)\n\n\ndef _select_best_filter(x, w):\n    \"\"\"\n    Evaluate all available filters and return the one with the highest\n    absolute correlation to the original signal.\n    \"\"\"\n    a = _to_array(x)\n    candidates = {\n        \"basic\": adaptive_filter(a, w),\n        \"weighted\": weighted_filter(a, w),\n        \"ema\": ema_filter(a, w),\n        \"enhanced\": enhanced_filter_with_trend_preservation(a, w),\n        \"median\": median_filter(a, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n\n    best_key = max(candidates, key=lambda k: _correlation_score(a, candidates[k]))\n    return candidates[best_key]\n\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n    Supported algorithms:\n        - \"basic\"\n        - \"weighted\"\n        - \"ema\"\n        - \"enhanced\"\n        - \"median\"\n        - any other value \u2192 automatic selection based on correlation.\n    \"\"\"\n    alg = alg.lower()\n    if alg == \"basic\":\n        return adaptive_filter(sig, w)\n    if alg == \"weighted\":\n        return weighted_filter(sig, w)\n    if alg == \"ema\":\n        return ema_filter(sig, w)\n    if alg == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(sig, w)\n    if alg == \"median\":\n        return median_filter(sig, w)\n    # fallback to automatic selection\n    return _select_best_filter(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef adaptive(x, w=20):\n    x = np.asarray(x, float)\n    if w <= 0 or x.size < w:\n        return np.empty(0, dtype=float)\n    return np.convolve(x, np.ones(w) / w, \"valid\")\n\n\ndef weighted(x, w=20):\n    x = np.asarray(x, float)\n    if w <= 0 or x.size < w:\n        return np.empty(0, dtype=float)\n    wt = np.exp(np.linspace(-2, 0, w))\n    wt /= wt.sum()\n    return np.convolve(x, wt, \"valid\")\n\n\ndef ema(x, w=20):\n    x = np.asarray(x, float)\n    if w <= 0 or x.size < w:\n        return np.empty(0, dtype=float)\n    a = 2.0 / (w + 1)\n    e = np.empty_like(x)\n    e[0] = x[0]\n    for i in range(1, len(x)):\n        e[i] = a * x[i] + (1 - a) * e[i - 1]\n    return e[w - 1 :]\n\n\ndef enhanced(x, w=20):\n    tr = adaptive(x, w)\n    if tr.size == 0:\n        return np.empty(0, dtype=float)\n    tf = np.concatenate((np.full(w - 1, tr[0]), tr))\n    return weighted(x - tf, w)\n\n\ndef median_filter(x, w=20):\n    a = np.asarray(x, float)\n    if w <= 0 or a.size < w:\n        return np.empty(0, dtype=float)\n    if w % 2 == 0:\n        w += 1\n    shape = (a.size - w + 1, w)\n    strides = (a.strides[0], a.strides[0])\n    win = np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)\n    return np.median(win, axis=1)\n\n\ndef fft_denoise(x, keep_ratio=0.1):\n    x = np.asarray(x, float)\n    n = x.size\n    if n == 0:\n        return np.empty(0, dtype=float)\n    coeffs = np.fft.rfft(x)\n    mags = np.abs(coeffs)\n    k = max(1, int(len(mags) * keep_ratio))\n    idx = np.argpartition(mags, -k)[-k:]\n    mask = np.zeros_like(mags, dtype=bool)\n    mask[idx] = True\n    filtered = np.where(mask, coeffs, 0)\n    return np.fft.irfft(filtered, n=n)\n\n\ndef _var(o, f):\n    n = min(len(o), len(f))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(o[:n] - f[:n]))\n\n\ndef process_signal(sig, w=20, alg=\"enh\"):\n    alg = alg.lower()\n    if alg in (\"basic\", \"adaptive\"):\n        return adaptive(sig, w)\n    if alg == \"weighted\":\n        return weighted(sig, w)\n    if alg in (\"ema\", \"exponential\"):\n        return ema(sig, w)\n    if alg in (\"enh\", \"enhanced\"):\n        return enhanced(sig, w)\n    if alg in (\"median\", \"med\"):\n        return median_filter(sig, w)\n    if alg in (\"fft\", \"spectral\"):\n        return fft_denoise(sig, keep_ratio=0.1)\n\n    # automatic selection\n    cand = {\n        \"a\": adaptive(sig, w),\n        \"w\": weighted(sig, w),\n        \"e\": ema(sig, w),\n        \"h\": enhanced(sig, w),\n        \"m\": median_filter(sig, w),\n        \"f\": fft_denoise(sig, keep_ratio=0.1),\n    }\n    cand = {k: v for k, v in cand.items() if v.size}\n    if not cand:\n        return np.empty(0, dtype=float)\n    best = min(cand, key=lambda k: _var(sig, cand[k]))\n    return cand[best]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["import numpy as np\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef _exp_weights(w):\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef _to_arr(x):\n    return np.asarray(x, float)\n\ndef adaptive(x, w=20):\n    a = _to_arr(x)\n    if w <= 0 or a.size < w:\n        return np.empty(0, float)\n    return np.convolve(a, np.ones(w) / w, \"valid\")\n\ndef weighted(x, w=20):\n    a = _to_arr(x)\n    if w <= 0 or a.size < w:\n        return np.empty(0, float)\n    return np.convolve(a, _exp_weights(w), \"valid\")\n\ndef ema(x, w=20):\n    a = _to_arr(x)\n    if w <= 0 or a.size < w:\n        return np.empty(0, float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(a)\n    e[0] = a[0]\n    for i in range(1, len(a)):\n        e[i] = alpha * a[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\ndef enhanced(x, w=20):\n    tr = adaptive(x, w)\n    if tr.size == 0:\n        return np.empty(0, float)\n    tf = np.concatenate((np.full(w - 1, tr[0]), tr))\n    return weighted(x - tf, w)\n\ndef median_filter(x, w=20):\n    a = _to_arr(x)\n    if w <= 0 or a.size < w:\n        return np.empty(0, float)\n    if w % 2 == 0:\n        w += 1\n    shape = (a.size - w + 1, w)\n    strides = (a.strides[0], a.strides[0])\n    win = np.lib.stride_tricks.as_strided(a, shape, strides)\n    return np.median(win, axis=1)\n\ndef fft_denoise(x, keep_ratio=0.1):\n    a = _to_arr(x)\n    n = a.size\n    if n == 0:\n        return np.empty(0, float)\n    coeffs = np.fft.rfft(a)\n    mags = np.abs(coeffs)\n    k = max(1, int(len(mags) * keep_ratio))\n    idx = np.argpartition(mags, -k)[-k:]\n    mask = np.zeros_like(mags, bool)\n    mask[idx] = True\n    filtered = np.where(mask, coeffs, 0)\n    return np.fft.irfft(filtered, n=n)\n\ndef _var(o, f):\n    n = min(len(o), len(f))\n    return float(np.var(o[:n] - f[:n])) if n else float(\"inf\")\n\ndef _corr(o, f):\n    n = min(len(o), len(f))\n    if n < 2:\n        return -np.inf\n    return np.corrcoef(o[:n], f[:n])[0, 1]\n\ndef process_signal(sig, w=20, alg=\"enh\"):\n    a = alg.lower()\n    if a in (\"basic\", \"adaptive\"):\n        return adaptive(sig, w)\n    if a == \"weighted\":\n        return weighted(sig, w)\n    if a in (\"ema\", \"exponential\"):\n        return ema(sig, w)\n    if a in (\"enh\", \"enhanced\"):\n        return enhanced(sig, w)\n    if a in (\"median\", \"med\"):\n        return median_filter(sig, w)\n    if a in (\"fft\", \"spectral\"):\n        return fft_denoise(sig, 0.1)\n    # automatic selection\n    cand = {\n        \"a\": adaptive(sig, w),\n        \"w\": weighted(sig, w),\n        \"e\": ema(sig, w),\n        \"h\": enhanced(sig, w),\n        \"m\": median_filter(sig, w),\n        \"f\": fft_denoise(sig, 0.1),\n    }\n    cand = {k: v for k, v in cand.items() if v.size}\n    if not cand:\n        return np.empty(0, float)\n    best = min(cand, key=lambda k: (_var(sig, cand[k]), -_corr(sig, cand[k])))\n    return cand[best]"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}