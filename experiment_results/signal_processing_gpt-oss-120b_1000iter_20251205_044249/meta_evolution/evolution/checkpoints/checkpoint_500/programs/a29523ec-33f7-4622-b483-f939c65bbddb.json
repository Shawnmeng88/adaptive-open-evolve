{"id": "a29523ec-33f7-4622-b483-f939c65bbddb", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\n\n# Cache for combined kernels to avoid recomputation\n_kernel_cache = {}\n\ndef _validate_signal(x, window_size):\n    \"\"\"Convert input to 1\u2011D float array and ensure it is long enough.\"\"\"\n    if window_size <= 0:\n        raise ValueError(f\"window_size must be positive, got {window_size}\")\n    arr = np.asarray(x, dtype=float).ravel()\n    if arr.size == 0 or arr.size < window_size:\n        # Return an empty array instead of raising \u2013 callers treat this as \u201cno output\u201d\n        return np.empty(0, dtype=float)\n    return arr\n\ndef _combined_kernel(window_size):\n    \"\"\"Gaussian\u202f\u00d7\u202fexponential kernel, cached and normalised.\"\"\"\n    if window_size in _kernel_cache:\n        return _kernel_cache[window_size]\n    idx = np.arange(window_size)\n    mid = (window_size - 1) / 2.0\n    sigma = max(window_size / 6.0, 1e-8)\n    g = np.exp(-0.5 * ((idx - mid) / sigma) ** 2)          # symmetric Gaussian\n    e = np.exp(-0.6 * (window_size - 1 - idx))           # right\u2011biased exponential\n    kernel = g * e\n    kernel /= kernel.sum()\n    _kernel_cache[window_size] = kernel\n    return kernel\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Uniform moving\u2011average filter (valid convolution).\"\"\"\n    arr = _validate_signal(x, window_size)\n    if arr.size == 0:\n        return arr\n    if window_size == 1:\n        return arr.copy()\n    return np.convolve(arr, np.ones(window_size) / window_size, mode=\"valid\")\n\ndef _simple_trend(arr, window_size):\n    \"\"\"Moving\u2011average trend padded to original length.\"\"\"\n    if window_size == 1:\n        return arr.copy()\n    trend = np.convolve(arr, np.ones(window_size) / window_size, mode=\"valid\")\n    # Pad the beginning with the first trend value to align lengths\n    pad = np.full(window_size - 1, trend[0], dtype=arr.dtype)\n    return np.concatenate((pad, trend))\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"\n    Detrend using a simple moving average, then apply the combined\n    Gaussian\u2011exponential kernel to the residual.\n    \"\"\"\n    arr = _validate_signal(x, window_size)\n    if arr.size == 0:\n        return arr\n    if window_size == 1:\n        return arr.copy()\n    # 1. Estimate trend and detrend\n    trend = _simple_trend(arr, window_size)\n    detrended = arr - trend\n    # 2. Smooth the detrended signal with the combined kernel\n    return np.convolve(detrended, _combined_kernel(window_size), mode=\"valid\")\n\ndef _median_filter(arr, window_size):\n    \"\"\"Median filter using stride tricks (requires odd window).\"\"\"\n    if window_size % 2 == 0:\n        window_size += 1\n    if not (window_size > 0 and arr.size >= window_size):\n        return np.empty(0, dtype=float)\n    if window_size == 1:\n        return arr.copy()\n    stride = arr.strides[0]\n    shape = (arr.size - window_size + 1, window_size)\n    windows = np.lib.stride_tricks.as_strided(arr, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"Variance of the residual (original\u2011filtered) over the overlapping region.\"\"\"\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(original[:n] - filtered[:n]))\n\ndef _auto_select(x, window_size):\n    \"\"\"Pick the filter (adaptive, enhanced, or median) with the smallest residual variance.\"\"\"\n    a = adaptive_filter(x, window_size)\n    e = enhanced_filter_with_trend_preservation(x, window_size)\n    m = _median_filter(_validate_signal(x, window_size), window_size)\n    # Discard empty results\n    candidates = {k: v for k, v in {\"adaptive\": a, \"enhanced\": e, \"median\": m}.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    orig = _validate_signal(x, window_size)\n    best_key = min(candidates, key=lambda k: _residual_variance(orig, candidates[k]))\n    return candidates[best_key]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"Dispatch to the requested filtering algorithm.\"\"\"\n    algo = str(algorithm_type).lower()\n    if algo == \"adaptive\":\n        return adaptive_filter(input_signal, window_size)\n    if algo == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(input_signal, window_size)\n    if algo == \"median\":\n        return _median_filter(_validate_signal(input_signal, window_size), window_size)\n    if algo == \"auto\":\n        return _auto_select(input_signal, window_size)\n    raise ValueError(f\"Unsupported algorithm_type: {algorithm_type}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "29253d3a-861a-4029-8baf-2f330589b9e3", "generation": 7, "timestamp": 1764940166.06016, "iteration_found": 468, "metrics": {"runs_successfully": 1.0, "composite_score": 0.474285091679895, "output_length": 91.0, "overall_score": 0.3781074773914067, "slope_changes": 46.2, "lag_error": 0.6600366683238371, "avg_error": 1.3151964033380428, "false_reversals": 38.4, "correlation": 0.13985239997186588, "noise_reduction": 0.0, "smoothness_score": 0.3021148036253776, "responsiveness_score": 0.6023963320097708, "accuracy_score": 0.13985239997186588, "efficiency_score": 1.0, "execution_time": 0.0004729747772216797, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.4393403701135009, "output_length": 91.0, "overall_score": 0.3730008071059442, "slope_changes": 50.2, "lag_error": 1.0494489275134469, "avg_error": 1.5326831875854867, "false_reversals": 43.8, "correlation": 0.20142301040243415, "noise_reduction": 0.0, "smoothness_score": 0.2849002849002849, "responsiveness_score": 0.4879360429895069, "accuracy_score": 0.20142301040243415, "efficiency_score": 1.0, "execution_time": 0.0003710269927978516, "success_rate": 1.0}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)\n## OUTPUT FORMAT (CRITICAL)\n- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers\n- Do NOT include the markers themselves in your output\n- Do NOT include any code outside the markers (imports, run_packing, etc.)\n- The system will automatically merge your output with the preserved code sections\n\n## FOCUS\n- Improve ONLY the `construct_packing()` function and helper functions within the evolve block\n- Functions like `run_packing()` are preserved automatically - do not include them\n\nViolating these requirements will cause the program to fail evaluation.\n\n---\n\nYou are an expert code\u2011evolution assistant tasked with improving the **`construct_packing()`** function (and any helper functions defined inside the evolve block) while preserving the surrounding infrastructure (imports, `run_packing()`, etc.).  \n\n**Output Rules (strictly enforce):**  \n- **Only** output the Python statements that belong **between** the markers `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  \n- Do **not** include the markers themselves.  \n- Do **not** output any code outside this region (e.g., imports, the `run_packing()` wrapper, or other unchanged sections).  \n\n**What NOT to do (these caused repeated failures):**  \n- Do not make sweeping, untested rewrites that change the function signature, required return type, or global variable names.  \n- Do not delete the entire block and replace it with a placeholder; the system expects a syntactically valid implementation.  \n- Do not introduce syntax errors, undefined names, or missing imports inside the block.  \n- Do not apply overly aggressive \u201cone\u2011line\u201d hacks that bypass logical steps; such changes have led to 100\u202f% invalid programs in prior iterations.  \n\n**Guidelines for a successful evolution:**  \n\n1. **Preserve the existing API**  \n   - `construct_packing()` must accept the same parameters as originally defined and return a packing object compatible with the rest of the program.  \n\n2. **Incremental improvement**  \n   - Identify a single concrete weakness (e.g., inefficient item ordering, missing handling of oversized items, lack of fallback strategy).  \n   - Modify or add helper functions **only** to address that weakness. Keep the overall structure recognizable.  \n\n3. **Safety checks**  \n   - Before returning, ensure the packing object is non\u2011empty and that every placed item respects the container\u2019s dimensions.  \n   - If a placement fails, fall back to a simple \u201cfirst\u2011fit\u201d strategy rather than raising an exception.  \n\n4. **Use existing utilities**  \n   - Re\u2011use any already\u2011imported modules (e.g., `math`, `itertools`) rather than adding new imports.  \n   - If a new helper is needed, define it **inside** the evolve block and give it a descriptive name that does not clash with existing identifiers.  \n\n5. **Performance\u2011aware tweaks**  \n   - Prefer sorting items by decreasing volume or surface area before packing.  \n   - When trying multiple orientations, limit the number of attempts (e.g., max 3) to avoid combinatorial explosion.  \n\n6. **Testing mindset**  \n   - Imagine a small test case: a container of size (10,10,10) and a list of three boxes. Your revised code should correctly place all boxes or gracefully report inability.  \n\n**Final instruction:** Write the revised code **exactly** as it should appear between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers, adhering to all the rules above. No additional commentary, markers, or external code may be included.", "user": "# Current Program Information\n- Fitness: 12.0357\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 14.0152 \u2192 12.0357. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4205, output_length: 91.0000, overall_score: 0.3804, slope_changes: 68.0000, lag_error: 0.9780, avg_error: 1.2635, false_reversals: 57.8000, correlation: 0.3335, noise_reduction: 0.0000, smoothness_score: 0.2273, responsiveness_score: 0.5056, accuracy_score: 0.3335, efficiency_score: 1.0000, execution_time: 0.0005, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4107, output_length: 91.0000, overall_score: 0.3693, slope_changes: 70.2000, lag_error: 1.0018, avg_error: 1.3037, false_reversals: 59.0000, correlation: 0.3035, noise_reduction: 0.0000, smoothness_score: 0.2217, responsiveness_score: 0.4996, accuracy_score: 0.3035, efficiency_score: 1.0000, execution_time: 0.0005, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4107, output_length: 91.0000, overall_score: 0.3693, slope_changes: 70.2000, lag_error: 1.0018, avg_error: 1.3037, false_reversals: 59.0000, correlation: 0.3035, noise_reduction: 0.0000, smoothness_score: 0.2217, responsiveness_score: 0.4996, accuracy_score: 0.3035, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 14.2259)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _prepare(x, ws):\n    ws = int(ws)\n    if ws <= 0:\n        raise ValueError(\"window_size must be positive\")\n    arr = np.asarray(x, dtype=float)\n    if arr.ndim != 1:\n        raise ValueError(\"input must be 1\u2011D\")\n    if arr.size < ws:\n        return np.empty(0, dtype=float), ws\n    return arr, ws\n\n@lru_cache(maxsize=64)\ndef _exp_weights(ws):\n    w = np.exp(np.linspace(-2, 0, ws))\n    return w / w.sum()\n\ndef adaptive_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    c = np.cumsum(np.insert(a, 0, 0.0))\n    return (c[w:] - c[:-w]) / w\n\ndef weighted_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    trend = adaptive_filter(a, w)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = a - trend_full\n    return weighted_filter(detrended, w)\n\ndef _hybrid_filter(x, window_size=20):\n    \"\"\"Average of weighted and adaptive filters \u2013 keeps length unchanged.\"\"\"\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    weighted = weighted_filter(a, w)\n    adaptive = adaptive_filter(a, w)\n    # both have identical length (n\u2011w+1)\n    return (weighted + adaptive) / 2.0\n\ndef _residual_variance(orig, filt):\n    m = min(len(orig), len(filt))\n    return float(np.var(orig[:m] - filt[:m])) if m else float(\"inf\")\n\ndef _select_best_filter(x, window_size):\n    cand = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n        \"hybrid\": _hybrid_filter(x, window_size),\n    }\n    return cand[min(cand, key=lambda k: _residual_variance(x, cand[k]))]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    alg = (algorithm_type or \"\").lower()\n    if alg == \"basic\":\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if alg == \"enhanced\":\n        # use hybrid for stronger noise reduction while preserving length\n        return _hybrid_filter(input_signal, window_size)\n    # fallback to auto\u2011selection of the best filter\n    return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4107), Performs well on output_length (91.0000), Performs well on overall_score (0.3693), Performs well on slope_changes (70.2000), Performs well on lag_error (1.0018), Performs well on avg_error (1.3037), Performs well on false_reversals (59.0000), Performs well on correlation (0.3035), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2217), Performs well on responsiveness_score (0.4996), Performs well on accuracy_score (0.3035), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 14.2259)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _prepare(x, ws):\n    ws = int(ws)\n    if ws <= 0:\n        raise ValueError(\"window_size must be positive\")\n    arr = np.asarray(x, dtype=float).ravel()\n    if arr.size < ws:\n        return np.empty(0, dtype=float), ws\n    return arr, ws\n\n@lru_cache(maxsize=64)\ndef _exp_weights(ws):\n    w = np.exp(np.linspace(-2, 0, ws))\n    return w / w.sum()\n\ndef adaptive_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    if w == 1:\n        return a.copy()\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\ndef _hybrid_filter(x, window_size=20):\n    \"\"\"Average of weighted and adaptive filters \u2013 keeps length unchanged.\"\"\"\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    weighted = weighted_filter(a, w)\n    adaptive = adaptive_filter(a, w)\n    # both have identical length (n\u2011w+1)\n    return (weighted + adaptive) / 2.0\n\ndef _residual_variance(orig, filt):\n    m = min(len(orig), len(filt))\n    if m == 0:\n        return float(\"inf\")\n    return float(np.var(orig[:m] - filt[:m]))\n\ndef _select_best_filter(x, window_size):\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": _hybrid_filter(x, window_size),\n    }\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best_key = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_key]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    alg = (algorithm_type or \"enhanced\").lower()\n    if alg == \"basic\" or alg == \"adaptive\":\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if alg == \"enhanced\":\n        return _hybrid_filter(input_signal, window_size)\n    # fallback: automatic selection based on residual variance\n    return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4107), Performs well on output_length (91.0000), Performs well on overall_score (0.3693), Performs well on slope_changes (70.2000), Performs well on lag_error (1.0018), Performs well on avg_error (1.3037), Performs well on false_reversals (59.0000), Performs well on correlation (0.3035), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2217), Performs well on responsiveness_score (0.4996), Performs well on accuracy_score (0.3035), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0005), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _arr(x):\n    return np.asarray(x, float).ravel()\n\ndef _ok(a, w):\n    return w > 0 and a.size >= w\n\ndef _simple(x, w):\n    a = _arr(x)\n    return np.convolve(a, np.ones(w) / w, \"valid\") if _ok(a, w) else np.empty(0)\n\ndef _weighted(x, w):\n    a = _arr(x)\n    if not _ok(a, w):\n        return np.empty(0)\n    wts = np.exp(np.linspace(-2, 0, w))\n    wts /= wts.sum()\n    return np.convolve(a, wts, \"valid\")\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    k = str(alg).lower()\n    return _weighted(sig, w) if k == \"weighted\" else _simple(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4205), Performs well on output_length (91.0000), Performs well on overall_score (0.3804), Performs well on slope_changes (68.0000), Performs well on lag_error (0.9780), Performs well on avg_error (1.2635), Performs well on false_reversals (57.8000), Performs well on correlation (0.3335), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2273), Performs well on responsiveness_score (0.5056), Performs well on accuracy_score (0.3335), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0005), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _to_array(x):\n    \"\"\"Convert input to a 1\u2011D float ndarray.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(a, w):\n    \"\"\"Return True if window size is positive and fits the array.\"\"\"\n    return w > 0 and a.size >= w\n\n@lru_cache(maxsize=64)\ndef _exp_weights(w):\n    \"\"\"Cached exponential weights that sum to 1.\"\"\"\n    wts = np.exp(np.linspace(-2, 0, w))\n    return wts / wts.sum()\n\ndef _simple_filter(a, w):\n    \"\"\"Uniform moving\u2011average (simple) filter.\"\"\"\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    kernel = np.full(w, 1.0 / w, dtype=float)\n    return np.convolve(a, kernel, mode=\"valid\")\n\ndef _weighted_filter(a, w):\n    \"\"\"Exponentially weighted moving\u2011average filter.\"\"\"\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, _exp_weights(w)[::-1], mode=\"valid\")\n\ndef _residual_variance(orig, filt):\n    \"\"\"Mean squared error between original (truncated) and filtered signal.\"\"\"\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return np.inf\n    return float(np.var(orig[:n] - filt[:n]))\n\ndef process_signal(sig, w=20, alg=\"auto\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    w : int, optional\n        Window size (default 20). Must be > 0.\n    alg : str, optional\n        Algorithm selector (case\u2011insensitive):\n        - \"simple\"   : uniform moving average\n        - \"weighted\" : exponential weighted average\n        - \"auto\" or any other value : automatically pick the better of the two\n          based on residual variance with the original signal.\n\n    Returns\n    -------\n    np.ndarray\n        Filtered signal (may be empty if input is invalid).\n    \"\"\"\n    a = _to_array(sig)\n    key = str(alg).lower()\n\n    if key == \"simple\":\n        return _simple_filter(a, w)\n    if key == \"weighted\":\n        return _weighted_filter(a, w)\n\n    # Auto\u2011selection: evaluate both candidates and choose the one with lower\n    # residual variance against the original (pre\u2011filter) signal.\n    simple_res = _simple_filter(a, w)\n    weighted_res = _weighted_filter(a, w)\n\n    # Discard empty results\n    candidates = {}\n    if simple_res.size:\n        candidates[\"simple\"] = simple_res\n    if weighted_res.size:\n        candidates[\"weighted\"] = weighted_res\n\n    if not candidates:\n        return np.empty(0, dtype=float)\n\n    best_key = min(candidates, key=lambda k: _residual_variance(a, candidates[k]))\n    return candidates[best_key]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _arr(x):\n    return np.asarray(x, float).ravel()\n\ndef _valid(a, w):\n    return w > 0 and a.size >= w\n\ndef adaptive(x, w=20):\n    a = _arr(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted(x, w=20):\n    a = _arr(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    wts = np.exp(np.linspace(-2, 0, w))\n    wts /= wts.sum()\n    return np.convolve(a, wts, mode=\"valid\")\n\ndef _auto(sig, w):\n    a = _arr(sig)\n    return weighted if np.var(a) > 1 else adaptive\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    key = str(alg).lower()\n    if key == \"auto\":\n        return _auto(sig, w)(sig, w)\n    if key in (\"adaptive\", \"enhanced\"):\n        return adaptive(sig, w)\n    if key == \"weighted\":\n        return weighted(sig, w)\n    raise ValueError(f\"Unsupported algorithm_type: {alg}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 13.4251, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _to_array(x):\n    \"\"\"Convert input to 1\u2011D float ndarray.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(arr, w):\n    \"\"\"Check that window size is positive and fits the array.\"\"\"\n    return w > 0 and arr.size >= w\n\n@lru_cache(maxsize=None)\ndef _exp_weights(w: int) -> np.ndarray:\n    \"\"\"Right\u2011biased exponential weights that sum to 1.\"\"\"\n    wts = np.exp(np.linspace(-2, 0, w))\n    return wts / wts.sum()\n\n@lru_cache(maxsize=None)\ndef _gaussian_weights(w: int) -> np.ndarray:\n    \"\"\"Zero\u2011phase Gaussian weights.\"\"\"\n    idx = np.arange(w)\n    mid = (w - 1) / 2.0\n    sigma = max(w / 6.0, 1e-8)\n    g = np.exp(-0.5 * ((idx - mid) / sigma) ** 2)\n    return g / g.sum()\n\ndef _simple(x, w):\n    \"\"\"Simple moving\u2011average (causal).\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef _weighted(x, w):\n    \"\"\"Exponential\u2011weighted moving average.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, _exp_weights(w)[::-1], mode=\"valid\")\n\ndef _ema(x, w):\n    \"\"\"Classic EMA (output length matches other filters).\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(a)\n    e[0] = a[0]\n    for i in range(1, len(a)):\n        e[i] = alpha * a[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\ndef _gaussian(x, w):\n    \"\"\"Zero\u2011phase Gaussian weighted moving average.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, _gaussian_weights(w)[::-1], mode=\"valid\")\n\ndef _median(x, w):\n    \"\"\"Median filter (odd window enforced).\"\"\"\n    if w % 2 == 0:\n        w += 1\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    shape = (a.size - w + 1, w)\n    strides = (a.strides[0], a.strides[0])\n    windows = np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)\n    return np.median(windows, axis=1)\n\ndef _hybrid(x, w):\n    \"\"\"Median followed by exponential\u2011weighted smoothing.\"\"\"\n    return _weighted(_median(x, w), w)\n\ndef _enhanced(x, w):\n    \"\"\"Detrend with simple MA then apply exponential\u2011weighted filter.\"\"\"\n    trend = _simple(x, w)\n    if trend.size == 0:\n        return np.empty(0, dtype=float)\n    # Pad trend to original length (edge repeat)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = _to_array(x) - trend_full\n    return _weighted(detrended, w)\n\ndef _residual_variance(orig, filt):\n    \"\"\"Variance of residual over the overlapping region.\"\"\"\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return np.inf\n    return float(np.var(orig[:n] - filt[:n]))\n\ndef _select_best(x, w):\n    \"\"\"Choose filter with minimal residual variance.\"\"\"\n    a = _to_array(x)\n    candidates = {\n        \"simple\": _simple(a, w),\n        \"weighted\": _weighted(a, w),\n        \"ema\": _ema(a, w),\n        \"gaussian\": _gaussian(a, w),\n        \"median\": _median(a, w),\n        \"hybrid\": _hybrid(a, w),\n        \"enhanced\": _enhanced(a, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best_key = min(candidates, key=lambda k: _residual_variance(a, candidates[k]))\n    return candidates[best_key]\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    w : int, optional\n        Window size (default 20).\n    alg : str, optional\n        Algorithm name. Supported names:\n        \"adaptive\", \"weighted\", \"ema\", \"gaussian\",\n        \"median\", \"hybrid\", \"enhanced\", \"auto\".\n        Unknown names fall back to auto\u2011selection.\n    \"\"\"\n    key = str(alg).lower()\n    a = _to_array(sig)\n\n    if key == \"adaptive\":\n        return _simple(a, w)\n    if key == \"weighted\":\n        return _weighted(a, w)\n    if key == \"ema\":\n        return _ema(a, w)\n    if key == \"gaussian\":\n        return _gaussian(a, w)\n    if key == \"median\":\n        return _median(a, w)\n    if key == \"hybrid\":\n        return _hybrid(a, w)\n    if key == \"enhanced\":\n        return _enhanced(a, w)\n    # \"auto\" or any unsupported name\n    return _select_best(a, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 2 (Score: 13.4402, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _to_array(x):\n    \"\"\"Convert input to 1\u2011D float array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(arr, w):\n    \"\"\"Validate window size against array.\"\"\"\n    return isinstance(w, int) and w > 0 and arr.size >= w\n\n@lru_cache(maxsize=None)\ndef _exp_weights(w):\n    \"\"\"Exponential weights that sum to 1 (right\u2011biased).\"\"\"\n    w = int(w)\n    e = np.exp(np.linspace(-2, 0, w))\n    return e / e.sum()\n\ndef adaptive(x, w=20):\n    \"\"\"Simple moving\u2011average filter.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted(x, w=20):\n    \"\"\"Exponential\u2011weighted moving average.\"\"\"\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    wts = _exp_weights(w)\n    return np.convolve(a, wts, mode=\"valid\")\n\ndef median(x, w=21):\n    \"\"\"Median filter (odd window size).\"\"\"\n    a = _to_array(x)\n    if w % 2 == 0:\n        w += 1\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    stride = a.strides[0]\n    windows = np.lib.stride_tricks.as_strided(\n        a, shape=(a.size - w + 1, w), strides=(stride, stride)\n    )\n    return np.median(windows, axis=1)\n\ndef _residual_variance(orig, filt):\n    \"\"\"Variance of the residual (orig\u2011filt) over overlapping region.\"\"\"\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return np.inf\n    return float(np.var(orig[:n] - filt[:n]))\n\ndef _select_best(x, w):\n    \"\"\"Choose the filter with the smallest residual variance.\"\"\"\n    candidates = {\n        \"adaptive\": adaptive(x, w),\n        \"weighted\": weighted(x, w),\n        \"median\": median(x, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best_key = min(candidates, key=lambda k: _residual_variance(_to_array(x), candidates[k]))\n    return candidates[best_key]\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Supported ``alg`` values (case\u2011insensitive):\n        - \"adaptive\"\n        - \"weighted\" / \"enhanced\"\n        - \"median\"\n        - \"auto\" \u2013 automatically select the best filter.\n    \"\"\"\n    key = str(alg).lower()\n    if key == \"auto\":\n        return _select_best(sig, w)\n    if key == \"adaptive\":\n        return adaptive(sig, w)\n    if key in (\"weighted\", \"enhanced\"):\n        return weighted(sig, w)\n    if key == \"median\":\n        return median(sig, w)\n    raise ValueError(f\"Unsupported algorithm_type: {alg}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 3 (Score: 13.9292, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _to_array(x):\n    return np.asarray(x, dtype=float).ravel()\n\ndef _valid(a, w):\n    return w > 0 and a.size >= w\n\n@lru_cache(maxsize=64)\ndef _exp_weights(w):\n    wts = np.exp(np.linspace(-2, 0, w))\n    return wts / wts.sum()\n\ndef adaptive(x, w=20):\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\ndef weighted(x, w=20):\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef enhanced(x, w=20):\n    a = _to_array(x)\n    if not _valid(a, w):\n        return np.empty(0, dtype=float)\n    if w == 1:\n        return a.copy()\n    trend = adaptive(a, w)\n    full_trend = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = a - full_trend\n    return weighted(detrended, w)\n\ndef _residual_variance(orig, filt):\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return np.inf\n    return float(np.var(orig[:n] - filt[:n]))\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    key = str(alg).lower()\n    if key == \"adaptive\":\n        return adaptive(sig, w)\n    if key == \"weighted\":\n        return weighted(sig, w)\n    if key == \"enhanced\":\n        return enhanced(sig, w)\n    if key == \"auto\":\n        a = _to_array(sig)\n        candidates = {}\n        for name, func in ((\"adaptive\", adaptive), (\"weighted\", weighted), (\"enhanced\", enhanced)):\n            res = func(a, w)\n            if res.size:\n                candidates[name] = res\n        if not candidates:\n            return np.empty(0, dtype=float)\n        best = min(candidates, key=lambda k: _residual_variance(a, candidates[k]))\n        return candidates[best]\n    raise ValueError(f\"Unsupported algorithm_type: {alg}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\n# Cache for combined kernels to avoid recomputation\n_kernel_cache = {}\n\ndef _validate_signal(x, window_size):\n    \"\"\"Convert input to 1\u2011D float array and ensure it is long enough.\"\"\"\n    if window_size <= 0:\n        raise ValueError(f\"window_size must be positive, got {window_size}\")\n    arr = np.asarray(x, dtype=float).ravel()\n    if arr.size == 0 or arr.size < window_size:\n        # Return an empty array instead of raising \u2013 callers treat this as \u201cno output\u201d\n        return np.empty(0, dtype=float)\n    return arr\n\ndef _combined_kernel(window_size):\n    \"\"\"Gaussian\u202f\u00d7\u202fexponential kernel, cached and normalised.\"\"\"\n    if window_size in _kernel_cache:\n        return _kernel_cache[window_size]\n    idx = np.arange(window_size)\n    mid = (window_size - 1) / 2.0\n    sigma = max(window_size / 6.0, 1e-8)\n    g = np.exp(-0.5 * ((idx - mid) / sigma) ** 2)          # symmetric Gaussian\n    e = np.exp(-0.6 * (window_size - 1 - idx))           # right\u2011biased exponential\n    kernel = (g * e)\n    kernel /= kernel.sum()\n    _kernel_cache[window_size] = kernel\n    return kernel\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Uniform moving\u2011average filter (valid convolution).\"\"\"\n    arr = _validate_signal(x, window_size)\n    if arr.size == 0:\n        return arr\n    if window_size == 1:\n        return arr.copy()\n    return np.convolve(arr, np.ones(window_size) / window_size, mode=\"valid\")\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"Weighted average using the combined Gaussian\u2011exponential kernel.\"\"\"\n    arr = _validate_signal(x, window_size)\n    if arr.size == 0:\n        return arr\n    if window_size == 1:\n        return arr.copy()\n    return np.convolve(arr, _combined_kernel(window_size), mode=\"valid\")\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"Variance of the residual (original\u2011filtered) over the overlapping region.\"\"\"\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(original[:n] - filtered[:n]))\n\ndef _auto_select(x, window_size):\n    \"\"\"Pick the filter (adaptive or enhanced) that yields the smallest residual variance.\"\"\"\n    a = adaptive_filter(x, window_size)\n    e = enhanced_filter_with_trend_preservation(x, window_size)\n    # Discard empty results\n    candidates = {k: v for k, v in {\"adaptive\": a, \"enhanced\": e}.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best_key = min(candidates, key=lambda k: _residual_variance(np.asarray(x, dtype=float).ravel(), candidates[k]))\n    return candidates[best_key]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"Dispatch to the requested filtering algorithm.\"\"\"\n    algo = str(algorithm_type).lower()\n    if algo == \"adaptive\":\n        return adaptive_filter(input_signal, window_size)\n    if algo == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(input_signal, window_size)\n    if algo == \"auto\":\n        return _auto_select(input_signal, window_size)\n    raise ValueError(f\"Unsupported algorithm_type: {algorithm_type}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["import numpy as np\n\n# Cache for combined kernels to avoid recomputation\n_kernel_cache = {}\n\ndef _validate_signal(x, window_size):\n    \"\"\"Convert input to 1\u2011D float array and ensure it is long enough.\"\"\"\n    if window_size <= 0:\n        raise ValueError(f\"window_size must be positive, got {window_size}\")\n    arr = np.asarray(x, dtype=float).ravel()\n    if arr.size == 0 or arr.size < window_size:\n        # Return an empty array instead of raising \u2013 callers treat this as \u201cno output\u201d\n        return np.empty(0, dtype=float)\n    return arr\n\ndef _combined_kernel(window_size):\n    \"\"\"Gaussian\u202f\u00d7\u202fexponential kernel, cached and normalised.\"\"\"\n    if window_size in _kernel_cache:\n        return _kernel_cache[window_size]\n    idx = np.arange(window_size)\n    mid = (window_size - 1) / 2.0\n    sigma = max(window_size / 6.0, 1e-8)\n    g = np.exp(-0.5 * ((idx - mid) / sigma) ** 2)          # symmetric Gaussian\n    e = np.exp(-0.6 * (window_size - 1 - idx))           # right\u2011biased exponential\n    kernel = g * e\n    kernel /= kernel.sum()\n    _kernel_cache[window_size] = kernel\n    return kernel\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Uniform moving\u2011average filter (valid convolution).\"\"\"\n    arr = _validate_signal(x, window_size)\n    if arr.size == 0:\n        return arr\n    if window_size == 1:\n        return arr.copy()\n    return np.convolve(arr, np.ones(window_size) / window_size, mode=\"valid\")\n\ndef _simple_trend(arr, window_size):\n    \"\"\"Moving\u2011average trend padded to original length.\"\"\"\n    if window_size == 1:\n        return arr.copy()\n    trend = np.convolve(arr, np.ones(window_size) / window_size, mode=\"valid\")\n    # Pad the beginning with the first trend value to align lengths\n    pad = np.full(window_size - 1, trend[0], dtype=arr.dtype)\n    return np.concatenate((pad, trend))\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"\n    Detrend using a simple moving average, then apply the combined\n    Gaussian\u2011exponential kernel to the residual.\n    \"\"\"\n    arr = _validate_signal(x, window_size)\n    if arr.size == 0:\n        return arr\n    if window_size == 1:\n        return arr.copy()\n    # 1. Estimate trend and detrend\n    trend = _simple_trend(arr, window_size)\n    detrended = arr - trend\n    # 2. Smooth the detrended signal with the combined kernel\n    return np.convolve(detrended, _combined_kernel(window_size), mode=\"valid\")\n\ndef _median_filter(arr, window_size):\n    \"\"\"Median filter using stride tricks (requires odd window).\"\"\"\n    if window_size % 2 == 0:\n        window_size += 1\n    if not (window_size > 0 and arr.size >= window_size):\n        return np.empty(0, dtype=float)\n    if window_size == 1:\n        return arr.copy()\n    stride = arr.strides[0]\n    shape = (arr.size - window_size + 1, window_size)\n    windows = np.lib.stride_tricks.as_strided(arr, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"Variance of the residual (original\u2011filtered) over the overlapping region.\"\"\"\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(original[:n] - filtered[:n]))\n\ndef _auto_select(x, window_size):\n    \"\"\"Pick the filter (adaptive, enhanced, or median) with the smallest residual variance.\"\"\"\n    a = adaptive_filter(x, window_size)\n    e = enhanced_filter_with_trend_preservation(x, window_size)\n    m = _median_filter(_validate_signal(x, window_size), window_size)\n    # Discard empty results\n    candidates = {k: v for k, v in {\"adaptive\": a, \"enhanced\": e, \"median\": m}.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    orig = _validate_signal(x, window_size)\n    best_key = min(candidates, key=lambda k: _residual_variance(orig, candidates[k]))\n    return candidates[best_key]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"Dispatch to the requested filtering algorithm.\"\"\"\n    algo = str(algorithm_type).lower()\n    if algo == \"adaptive\":\n        return adaptive_filter(input_signal, window_size)\n    if algo == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(input_signal, window_size)\n    if algo == \"median\":\n        return _median_filter(_validate_signal(input_signal, window_size), window_size)\n    if algo == \"auto\":\n        return _auto_select(input_signal, window_size)\n    raise ValueError(f\"Unsupported algorithm_type: {algorithm_type}\")"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}