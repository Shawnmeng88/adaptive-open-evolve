{"id": "f58f2a0e-c9c2-4bb8-803b-aacce89d3083", "code": "# EVOLVE-BLOCK-START\ndef advanced_filter(x, window_size=20):\n    \"\"\"\n    Multi\u2011stage enhanced filter:\n    1. Detrended weighted smoothing (same as ``enhanced_filter_with_trend_preservation``).\n    2. Median filter to suppress spikes/outliers.\n    3. Light uniform smoothing with a smaller window (\u2248 half size).\n    \"\"\"\n    # stage 1 \u2013 detrended weighted\n    first = enhanced_filter_with_trend_preservation(x, window_size)\n    if first.size == 0:\n        return np.empty(0, float)\n\n    # stage 2 \u2013 median to remove occasional spikes\n    medianed = median_ma(first, window_size)\n    if medianed.size == 0:\n        return np.empty(0, float)\n\n    # stage 3 \u2013 final light smoothing\n    second_w = max(1, window_size // 2)\n    return adaptive_filter(medianed, second_w)\n\n\ndef _select_best_filter(x: np.ndarray, window_size: int) -> np.ndarray:\n    \"\"\"Pick the filter with the lowest residual variance, now also considering ``advanced_filter``.\"\"\"\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n        \"gaussian\": gaussian_ma(x, window_size),\n        \"median\": median_ma(x, window_size),\n        \"double\": double_enhanced(x, window_size),\n        \"advanced\": advanced_filter(x, window_size),\n    }\n    best_key = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_key]\n\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n    Supported ``algorithm_type`` values:\n        - \"basic\"\n        - \"weighted\"\n        - \"ema\"\n        - \"enhanced\"\n        - \"gaussian\"\n        - \"median\"\n        - \"double\"\n        - \"advanced\"\n        - any other value \u2192 automatic selection of the best filter.\n    \"\"\"\n    dispatch = {\n        \"basic\": adaptive_filter,\n        \"weighted\": weighted_filter,\n        \"ema\": ema_filter,\n        \"enhanced\": enhanced_filter_with_trend_preservation,\n        \"gaussian\": gaussian_ma,\n        \"median\": median_ma,\n        \"double\": double_enhanced,\n        \"advanced\": advanced_filter,\n    }\n    if algorithm_type in dispatch:\n        return dispatch[algorithm_type](input_signal, window_size)\n    # Fallback \u2013 choose the most effective filter automatically\n    return _select_best_filter(np.asarray(input_signal, float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "9077f231-f1b7-4cea-89f4-117facfb7363", "generation": 6, "timestamp": 1764937925.019072, "iteration_found": 184, "metrics": {"runs_successfully": 0.0, "error": "Stage 1 failed: name 'np' is not defined"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.4429433309255678, "output_length": 91.0, "overall_score": 0.3624766970140094, "slope_changes": 68.6, "lag_error": 0.4099887786960041, "avg_error": 1.1150775516528053, "false_reversals": 56.6, "correlation": 0.20076318890739916, "noise_reduction": 0.0, "smoothness_score": 0.22573363431151244, "responsiveness_score": 0.709225502436145, "accuracy_score": 0.20076318890739916, "efficiency_score": 1.0, "execution_time": 0.0005405426025390625, "success_rate": 1.0}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)\n## OUTPUT FORMAT (CRITICAL)\n- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers\n- Do NOT include the markers themselves in your output\n- Do NOT include any code outside the markers (imports, run_packing, etc.)\n- The system will automatically merge your output with the preserved code sections\n\n## FOCUS\n- Improve ONLY the `construct_packing()` function and helper functions within the evolve block\n- Functions like `run_packing()` are preserved automatically - do not include them\n\nViolating these requirements will cause the program to fail evaluation.\n\n---\n\nYou are a code\u2011evolution assistant tasked with improving **only** the `construct_packing()` function and any helper functions that appear **inside** the `# EVOLVE-BLOCK-START \u2026 # EVOLVE-BLOCK-END` region.  \n\n**Output Rules (must be obeyed exactly)**  \n- **Output ONLY the Python code that belongs between the markers.**  \n- **Do NOT include the `# EVOLVE-BLOCK-START` or `# EVOLVE-BLOCK-END` lines themselves.**  \n- **Do NOT add any imports, top\u2011level statements, or code outside the marked region.**  \n- The surrounding driver (e.g., `run_packing()`) will be merged automatically; you must not modify it.\n\n**What NOT to do (avoid the patterns that caused previous failures)**  \n- Do not write an overly aggressive prompt that leaves the LLM guessing the required signatures, data structures, or return types.  \n- Do not omit explicit type hints, parameter names, or expected return values \u2013 the function must be *self\u2011contained and runnable*.  \n- Do not produce code that relies on undefined globals or external modules not already imported in the outer file.  \n- Do not repeat the same logic that previously generated syntax errors or runtime exceptions (e.g., undefined variables, mismatched brackets, missing commas).  \n\n**Concrete guidance for improving `construct_packing()`**\n\n1. **Clarify the contract**  \n   - The function receives a list of `Item` objects (each with `weight`, `volume`, `value`) and a `Container` specification (`max_weight`, `max_volume`).  \n   - It must return a list of lists, where each inner list is a collection of `Item` indices that fit within a single container respecting both weight and volume limits.  \n\n2. **Adopt a deterministic, testable algorithm**  \n   - Implement a **first\u2011fit decreasing** heuristic:  \n     a. Sort items by a combined density metric, e.g., `value / (weight + volume)`.  \n     b. Iterate through sorted items, placing each into the first container that can accommodate it; if none exists, open a new container.  \n   - This algorithm is simple, avoids recursion depth issues, and always produces a valid packing (though not necessarily optimal).  \n\n3. **Provide clear helper utilities**  \n   - Write a small `_can_add(item, container_state)` helper that checks weight\u202f\u2264\u202f`max_weight` **and** volume\u202f\u2264\u202f`max_volume`.  \n   - Write a `_add_item(item, container_state)` helper that updates the running totals.  \n\n4. **Maintain immutability of input**  \n   - Do **not** modify the original `items` list; work on a copy or on indices only.  \n\n5. **Edge\u2011case handling**  \n   - If an individual item exceeds either limit, skip it and record its index in a `skipped` list (optional, but must not raise).  \n   - If the input list is empty, return an empty list `[]`.  \n\n6. **Return format**  \n   - Return a list of containers, each represented as a list of the original item indices (preserving the order in which they were placed).  \n\n7. **Testing sanity**  \n   - After constructing the packing, include an internal sanity check (as a comment) that verifies all containers respect the limits; this helps future reviewers but must not execute code outside the block.  \n\n**Example skeleton you may adapt (replace placeholder logic with the concrete steps above):**\n\n```python\ndef construct_packing(items, container):\n    \"\"\"\n    Pack `items` into the minimum number of `container`s using a first\u2011fit decreasing heuristic.\n    Returns a list of lists of item indices.\n    \"\"\"\n    # 1. Compute density and sort indices\n    sorted_idx = sorted(\n        range(len(items)),\n        key=lambda i: items[i].value / (items[i].weight + items[i].volume),\n        reverse=True,\n    )\n\n    containers = []          # list of lists of indices\n    states = []              # parallel list of (used_weight, used_volume)\n\n    for idx in sorted_idx:\n        item = items[idx]\n\n        # 2. Skip impossible items\n        if item.weight > container.max_weight or item.volume > container.max_volume:\n            # optional: could collect skipped items here\n            continue\n\n        # 3. Try to fit into existing containers\n        placed = False\n        for c_idx, (used_w, used_v) in enumerate(states):\n            if used_w + item.weight <= container.max_weight and \\\n               used_v + item.volume <= container.max_volume:\n                containers[c_idx].append(idx)\n                states[c_idx] = (used_w + item.weight, used_v + item.volume)\n                placed = True\n                break\n\n        # 4. Open a new container if needed\n        if not placed:\n            containers.append([idx])\n            states.append((item.weight, item.volume))\n\n    # 5. (Optional sanity check \u2013 comment only)\n    # for c, (w, v) in zip(containers, states):\n    #     assert w <= container.max_weight and v <= container.max_volume\n\n    return containers\n```\n\nUse the above structure as a guide, but feel free to refactor, rename variables, or introduce additional small helpers as long as the **contract, return type, and output rules** are respected. Remember: **only the code inside the markers will be kept**.", "user": "# Current Program Information\n- Fitness: 13.9292\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness improved: 13.9292 \u2192 13.9292\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4429, output_length: 91.0000, overall_score: 0.3625, slope_changes: 68.6000, lag_error: 0.4100, avg_error: 1.1151, false_reversals: 56.6000, correlation: 0.2008, noise_reduction: 0.0000, smoothness_score: 0.2257, responsiveness_score: 0.7092, accuracy_score: 0.2008, efficiency_score: 1.0000, execution_time: 0.0005, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4429, output_length: 91.0000, overall_score: 0.3625, slope_changes: 68.6000, lag_error: 0.4100, avg_error: 1.1151, false_reversals: 56.6000, correlation: 0.2008, noise_reduction: 0.0000, smoothness_score: 0.2257, responsiveness_score: 0.7092, accuracy_score: 0.2008, efficiency_score: 1.0000, execution_time: 0.0005, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4429, output_length: 91.0000, overall_score: 0.3625, slope_changes: 68.6000, lag_error: 0.4100, avg_error: 1.1151, false_reversals: 56.6000, correlation: 0.2008, noise_reduction: 0.0000, smoothness_score: 0.2257, responsiveness_score: 0.7092, accuracy_score: 0.2008, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"\n    Simple moving average filter using convolution.\n    Returns the filtered signal with length len(x) - window_size + 1.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        # Not enough data \u2013 return empty array for consistency\n        return np.array([], dtype=float)\n    return np.convolve(x, np.ones(window_size) / window_size, mode=\"valid\")\n\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"\n    Exponential weighted moving average.\n    Emphasises recent samples while preserving overall trend.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    weights = np.exp(np.linspace(-2, 0, window_size))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema_filter(x, window_size=20):\n    \"\"\"\n    Classic exponential moving average (EMA).\n    Output length matches other filters (len(x) - window_size + 1).\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (window_size + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[window_size - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"\n    Detrends the signal using a simple moving average, then applies\n    a weighted moving average to the detrended series.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    # Estimate local trend\n    trend = adaptive_filter(x, window_size)\n    # Pad trend to original length (repeat edge values)\n    trend_full = np.concatenate((np.full(window_size - 1, trend[0]), trend))\n    detrended = x - trend_full\n    return weighted_filter(detrended, window_size)\n\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"\n    Compute variance of the residual (original - filtered).\n    Signals are aligned to the shortest length.\n    \"\"\"\n    min_len = min(len(original), len(filtered))\n    if min_len == 0:\n        return np.inf\n    residual = original[:min_len] - filtered[:min_len]\n    return float(np.var(residual))\n\n\ndef _select_best_filter(x: np.ndarray, window_size: int) -> np.ndarray:\n    \"\"\"\n    Evaluate all available filters and return the one that yields the lowest\n    residual variance (i.e., highest estimated noise reduction).\n    \"\"\"\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n    }\n    # Choose filter with minimal residual variance relative to the raw signal\n    best_name = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_name]\n\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatches to the requested filtering algorithm.\n    Supported types:\n        - \"basic\": simple moving average (adaptive_filter)\n        - \"weighted\": exponential weighted moving average (weighted_filter)\n        - \"ema\": classic exponential moving average (ema_filter)\n        - \"enhanced\": detrended weighted filter (enhanced_filter_with_trend_preservation)\n        - any other value: automatic selection of the best filter based on residual variance.\n    \"\"\"\n    if algorithm_type == \"basic\":\n        return adaptive_filter(input_signal, window_size)\n    if algorithm_type == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if algorithm_type == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if algorithm_type == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(input_signal, window_size)\n\n    # Fallback: automatic selection\n    return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4429), Performs well on output_length (91.0000), Performs well on overall_score (0.3625), Performs well on slope_changes (68.6000), Performs well on lag_error (0.4100), Performs well on avg_error (1.1151), Performs well on false_reversals (56.6000), Performs well on correlation (0.2008), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2257), Performs well on responsiveness_score (0.7092), Performs well on accuracy_score (0.2008), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _ma(x: np.ndarray, w: int, wt: np.ndarray) -> np.ndarray:\n    \"\"\"Convolution helper for moving\u2011average\u2011style filters.\"\"\"\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    return np.convolve(x, wt, mode=\"valid\")\n\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Uniform moving average (basic filter).\"\"\"\n    return _ma(x, window_size, np.ones(window_size) / window_size)\n\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"Exponentially weighted moving average.\"\"\"\n    wt = np.exp(np.linspace(-2, 0, window_size))\n    wt /= wt.sum()\n    return _ma(x, window_size, wt)\n\n\ndef ema_filter(x, window_size=20):\n    \"\"\"Classic exponential moving average (recursive).\"\"\"\n    x = np.asarray(x, float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.empty(0, float)\n    alpha = 2.0 / (window_size + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[window_size - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"Detrend with a simple MA then apply a weighted MA.\"\"\"\n    trend = adaptive_filter(x, window_size)\n    if trend.size == 0:\n        return np.empty(0, float)\n    trend_full = np.concatenate((np.full(window_size - 1, trend[0]), trend))\n    detrended = np.asarray(x, float) - trend_full\n    return weighted_filter(detrended, window_size)\n\n\ndef gaussian_ma(x, window_size=20):\n    \"\"\"Moving average with Gaussian kernel (smooth, bell\u2011shaped weighting).\"\"\"\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    sigma = max(window_size / 6.0, 0.1)\n    centre = (window_size - 1) / 2.0\n    i = np.arange(window_size, dtype=float)\n    wt = np.exp(-0.5 * ((i - centre) / sigma) ** 2)\n    wt /= wt.sum()\n    return _ma(x, window_size, wt)\n\n\ndef median_ma(x, window_size=20):\n    \"\"\"Median filter \u2013 robust to spikes/outliers.\"\"\"\n    x = np.asarray(x, float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.empty(0, float)\n    out_len = x.size - window_size + 1\n    out = np.empty(out_len, float)\n    for i in range(out_len):\n        out[i] = np.median(x[i : i + window_size])\n    return out\n\n\ndef double_enhanced(x, window_size=20):\n    \"\"\"\n    Two\u2011stage enhancement:\n    1. Detrended weighted smoothing (enhanced_filter_with_trend_preservation).\n    2. Light uniform smoothing with a smaller window (\u2248 half size).\n    \"\"\"\n    first = enhanced_filter_with_trend_preservation(x, window_size)\n    if first.size == 0:\n        return np.empty(0, float)\n    second_w = max(1, window_size // 2)\n    return adaptive_filter(first, second_w)\n\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"Mean\u2011squared residual between original and filtered signals.\"\"\"\n    m = min(len(original), len(filtered))\n    if m == 0:\n        return np.inf\n    return float(np.var(original[:m] - filtered[:m]))\n\n\ndef _select_best_filter(x: np.ndarray, window_size: int) -> np.ndarray:\n    \"\"\"Pick the filter with the lowest residual variance.\"\"\"\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n        \"gaussian\": gaussian_ma(x, window_size),\n        \"median\": median_ma(x, window_size),\n        \"double\": double_enhanced(x, window_size),\n    }\n    best_key = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_key]\n\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n    Supported ``algorithm_type`` values:\n        - \"basic\"\n        - \"weighted\"\n        - \"ema\"\n        - \"enhanced\"\n        - \"gaussian\"\n        - \"median\"\n        - \"double\"\n        - any other value \u2192 automatic selection of the best filter.\n    \"\"\"\n    dispatch = {\n        \"basic\": adaptive_filter,\n        \"weighted\": weighted_filter,\n        \"ema\": ema_filter,\n        \"enhanced\": enhanced_filter_with_trend_preservation,\n        \"gaussian\": gaussian_ma,\n        \"median\": median_ma,\n        \"double\": double_enhanced,\n    }\n    if algorithm_type in dispatch:\n        return dispatch[algorithm_type](input_signal, window_size)\n    # Fallback \u2013 choose the most effective filter automatically\n    return _select_best_filter(np.asarray(input_signal, float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4429), Performs well on output_length (91.0000), Performs well on overall_score (0.3625), Performs well on slope_changes (68.6000), Performs well on lag_error (0.4100), Performs well on avg_error (1.1151), Performs well on false_reversals (56.6000), Performs well on correlation (0.2008), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2257), Performs well on responsiveness_score (0.7092), Performs well on accuracy_score (0.2008), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0005), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\ndef _m(x,n,w):\n x=np.asarray(x,float)\n if n<=0:raise ValueError\n if x.size<n:return np.empty(0,float)\n return np.convolve(x,w,mode='valid')\ndef _f(x,n,t):\n if t=='b':return _m(x,n,np.ones(n)/n)\n if t=='w':\n  wt=np.exp(np.linspace(-2,0,n));wt/=wt.sum()\n  return _m(x,n,wt)\n if t=='e':\n  x=np.asarray(x,float)\n  if n<=0:raise ValueError\n  if x.size<n:return np.empty(0,float)\n  a=2.0/(n+1);y=np.empty_like(x);y[0]=x[0]\n  for i in range(1,len(x)):y[i]=a*x[i]+(1-a)*y[i-1]\n  return y[n-1:]\n if t=='h':\n  tr=_f(x,n,'b')\n  if tr.size==0:return np.empty(0,float)\n  tf=np.concatenate((np.full(n-1,tr[0]),tr))\n  return _f(x-tf,n,'w')\n if t=='d':\n  f=_f(x,n,'h')\n  if f.size==0:return np.empty(0,float)\n  m=n//2 or 1\n  return _f(f,m,'b')\ndef _rv(o,f):\n m=min(len(o),len(f))\n return float('inf') if m==0 else np.var(o[:m]-f[:m])\ndef process_signal(s,n=20,a='enhanced'):\n if a in('basic','weighted','ema','enhanced','double'):\n  t={'basic':'b','weighted':'w','ema':'e','enhanced':'h','double':'d'}[a]\n  return _f(s,n,t)\n c=[_f(s,n,t) for t in('b','w','e','h','d')]\n return min(c,key=lambda y:_rv(s,y))\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4429), Performs well on output_length (91.0000), Performs well on overall_score (0.3625), Performs well on slope_changes (68.6000), Performs well on lag_error (0.4100), Performs well on avg_error (1.1151), Performs well on false_reversals (56.6000), Performs well on correlation (0.2008), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2257), Performs well on responsiveness_score (0.7092), Performs well on accuracy_score (0.2008), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0005), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _ma(x, w, wt):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be >0\")\n    if x.size < w:\n        return np.empty(0, float)\n    return np.convolve(x, wt, mode=\"valid\")\n\ndef simple_ma(x, w):\n    return _ma(x, w, np.ones(w) / w)\n\ndef weighted_ma(x, w):\n    wt = np.exp(np.linspace(-2, 0, w))\n    wt /= wt.sum()\n    return _ma(x, w, wt)\n\ndef ema(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be >0\")\n    if x.size < w:\n        return np.empty(0, float)\n    a = 2.0 / (w + 1)\n    out = np.empty_like(x)\n    out[0] = x[0]\n    for i in range(1, len(x)):\n        out[i] = a * x[i] + (1 - a) * out[i - 1]\n    return out[w - 1 :]\n\ndef detrended_weighted(x, w):\n    tr = simple_ma(x, w)\n    tr_full = np.concatenate((np.full(w - 1, tr[0]), tr))\n    return weighted_ma(x - tr_full, w)\n\ndef double_enhanced(x, w):\n    first = detrended_weighted(x, w)\n    second_w = max(1, w // 2)\n    return simple_ma(first, second_w)\n\ndef process_signal(sig, w=20, algo=\"enhanced\"):\n    funcs = {\n        \"basic\": simple_ma,\n        \"weighted\": weighted_ma,\n        \"ema\": ema,\n        \"enhanced\": detrended_weighted,\n        \"double\": double_enhanced,\n    }\n    return funcs.get(algo, double_enhanced)(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _conv(x, w, wt):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    return np.convolve(x, wt, mode=\"valid\")\n\ndef basic(x, w):\n    return _conv(x, w, np.ones(w) / w)\n\ndef weighted(x, w):\n    wt = np.exp(np.linspace(-2, 0, w))\n    wt /= wt.sum()\n    return _conv(x, w, wt)\n\ndef ema(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    a = 2.0 / (w + 1)\n    out = np.empty_like(x)\n    out[0] = x[0]\n    for i in range(1, len(x)):\n        out[i] = a * x[i] + (1 - a) * out[i - 1]\n    return out[w - 1 :]\n\ndef gaussian(x, w):\n    sigma = max(w / 6.0, 0.1)\n    c = (w - 1) / 2.0\n    i = np.arange(w, dtype=float)\n    wt = np.exp(-0.5 * ((i - c) / sigma) ** 2)\n    wt /= wt.sum()\n    return _conv(x, w, wt)\n\ndef median(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    out_len = x.size - w + 1\n    out = np.empty(out_len, float)\n    for i in range(out_len):\n        out[i] = np.median(x[i:i + w])\n    return out\n\ndef detrended(x, w):\n    tr = basic(x, w)\n    if tr.size == 0:\n        return np.empty(0, float)\n    full = np.concatenate((np.full(w - 1, tr[0]), tr))\n    return weighted(x - full, w)\n\ndef double_enhanced(x, w):\n    first = detrended(x, w)\n    if first.size == 0:\n        return np.empty(0, float)\n    half = max(1, w // 2)\n    return basic(first, half)\n\ndef _rv(orig, filt):\n    m = min(len(orig), len(filt))\n    return np.inf if m == 0 else float(np.var(orig[:m] - filt[:m]))\n\ndef _best(x, w):\n    cand = {\n        \"basic\": basic(x, w),\n        \"weighted\": weighted(x, w),\n        \"ema\": ema(x, w),\n        \"enhanced\": detrended(x, w),\n        \"gaussian\": gaussian(x, w),\n        \"median\": median(x, w),\n        \"double\": double_enhanced(x, w),\n    }\n    return min(cand.values(), key=lambda y: _rv(x, y))\n\ndef process_signal(sig, w=20, algo=\"enhanced\"):\n    dispatch = {\n        \"basic\": basic,\n        \"weighted\": weighted,\n        \"ema\": ema,\n        \"enhanced\": detrended,\n        \"gaussian\": gaussian,\n        \"median\": median,\n        \"double\": double_enhanced,\n    }\n    if algo in dispatch:\n        return dispatch[algo](sig, w)\n    return _best(np.asarray(sig, float), w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 13.9292, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef simple_ma(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    return np.convolve(x, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted_ma(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    weights = np.exp(np.linspace(-2, 0, w))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    a = 2.0 / (w + 1)\n    out = np.empty_like(x)\n    out[0] = x[0]\n    for i in range(1, len(x)):\n        out[i] = a * x[i] + (1 - a) * out[i - 1]\n    return out[w - 1 :]\n\n\ndef detrended_weighted(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    trend = simple_ma(x, w)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = x - trend_full\n    return weighted_ma(detrended, w)\n\n\ndef gaussian_ma(x, w):\n    \"\"\"Moving average with Gaussian weights.\"\"\"\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    sigma = max(w / 6.0, 0.1)\n    center = (w - 1) / 2.0\n    i = np.arange(w, dtype=float)\n    weights = np.exp(-0.5 * ((i - center) / sigma) ** 2)\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef median_ma(x, w):\n    \"\"\"Median filter (robust to spikes).\"\"\"\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    out_len = x.size - w + 1\n    out = np.empty(out_len, float)\n    for i in range(out_len):\n        out[i] = np.median(x[i : i + w])\n    return out\n\n\ndef _residual_variance(orig, filt):\n    m = min(len(orig), len(filt))\n    if m == 0:\n        return np.inf\n    return float(np.var(orig[:m] - filt[:m]))\n\n\ndef _select_best(x, w):\n    candidates = {\n        \"basic\": simple_ma(x, w),\n        \"weighted\": weighted_ma(x, w),\n        \"ema\": ema(x, w),\n        \"enhanced\": detrended_weighted(x, w),\n        \"gaussian\": gaussian_ma(x, w),\n        \"median\": median_ma(x, w),\n    }\n    best_key = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_key]\n\n\ndef process_signal(sig, w=20, algo=\"enhanced\"):\n    if algo == \"basic\":\n        return simple_ma(sig, w)\n    if algo == \"weighted\":\n        return weighted_ma(sig, w)\n    if algo == \"ema\":\n        return ema(sig, w)\n    if algo == \"enhanced\":\n        return detrended_weighted(sig, w)\n    if algo == \"gaussian\":\n        return gaussian_ma(sig, w)\n    if algo == \"median\":\n        return median_ma(sig, w)\n    # Fallback to automatic selection\n    return _select_best(np.asarray(sig, float), w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 2 (Score: 13.9292, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _conv(x, w, wt):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    return np.convolve(x, wt, mode=\"valid\")\n\ndef basic(x, w):\n    return _conv(x, w, np.ones(w) / w)\n\ndef weighted(x, w):\n    wt = np.exp(np.linspace(-2, 0, w))\n    wt /= wt.sum()\n    return _conv(x, w, wt)\n\ndef ema(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    a = 2.0 / (w + 1)\n    out = np.empty_like(x)\n    out[0] = x[0]\n    for i in range(1, len(x)):\n        out[i] = a * x[i] + (1 - a) * out[i - 1]\n    return out[w - 1 :]\n\ndef gaussian(x, w):\n    sigma = max(w / 6.0, 0.1)\n    c = (w - 1) / 2.0\n    i = np.arange(w, dtype=float)\n    wt = np.exp(-0.5 * ((i - c) / sigma) ** 2)\n    wt /= wt.sum()\n    return _conv(x, w, wt)\n\ndef median(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    out_len = x.size - w + 1\n    out = np.empty(out_len, float)\n    for i in range(out_len):\n        out[i] = np.median(x[i:i + w])\n    return out\n\ndef detrended(x, w):\n    tr = basic(x, w)\n    if tr.size == 0:\n        return np.empty(0, float)\n    full = np.concatenate((np.full(w - 1, tr[0]), tr))\n    return weighted(x - full, w)\n\ndef double_enhanced(x, w):\n    first = detrended(x, w)\n    if first.size == 0:\n        return np.empty(0, float)\n    half = max(1, w // 2)\n    return basic(first, half)\n\ndef _rv(orig, filt):\n    m = min(len(orig), len(filt))\n    return np.inf if m == 0 else float(np.var(orig[:m] - filt[:m]))\n\ndef _best(x, w):\n    cand = {\n        \"basic\": basic(x, w),\n        \"weighted\": weighted(x, w),\n        \"ema\": ema(x, w),\n        \"enhanced\": detrended(x, w),\n        \"gaussian\": gaussian(x, w),\n        \"median\": median(x, w),\n        \"double\": double_enhanced(x, w),\n    }\n    return min(cand.values(), key=lambda y: _rv(x, y))\n\ndef process_signal(sig, w=20, algo=\"enhanced\"):\n    dispatch = {\n        \"basic\": basic,\n        \"weighted\": weighted,\n        \"ema\": ema,\n        \"enhanced\": detrended,\n        \"gaussian\": gaussian,\n        \"median\": median,\n        \"double\": double_enhanced,\n    }\n    if algo in dispatch:\n        return dispatch[algo](sig, w)\n    return _best(np.asarray(sig, float), w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 3 (Score: 13.9292, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\ndef _m(x,n,w):\n x=np.asarray(x,float)\n if n<=0:raise ValueError\n if x.size<n:return np.empty(0,float)\n return np.convolve(x,w,mode='valid')\ndef _f(x,n,t):\n if t=='b':return _m(x,n,np.ones(n)/n)\n if t=='w':\n  wt=np.exp(np.linspace(-2,0,n));wt/=wt.sum()\n  return _m(x,n,wt)\n if t=='e':\n  x=np.asarray(x,float)\n  if n<=0:raise ValueError\n  if x.size<n:return np.empty(0,float)\n  a=2.0/(n+1);y=np.empty_like(x);y[0]=x[0]\n  for i in range(1,len(x)):y[i]=a*x[i]+(1-a)*y[i-1]\n  return y[n-1:]\n if t=='h':\n  tr=_f(x,n,'b')\n  if tr.size==0:return np.empty(0,float)\n  tf=np.concatenate((np.full(n-1,tr[0]),tr))\n  return _f(x-tf,n,'w')\n if t=='d':\n  f=_f(x,n,'h')\n  if f.size==0:return np.empty(0,float)\n  m=n//2 or 1\n  return _f(f,m,'b')\ndef _rv(o,f):\n m=min(len(o),len(f))\n return float('inf') if m==0 else np.var(o[:m]-f[:m])\ndef process_signal(s,n=20,a='enhanced'):\n if a in('basic','weighted','ema','enhanced','double'):\n  t={'basic':'b','weighted':'w','ema':'e','enhanced':'h','double':'d'}[a]\n  return _f(s,n,t)\n c=[_f(s,n,t) for t in('b','w','e','h','d')]\n return min(c,key=lambda y:_rv(s,y))\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _ma(x: np.ndarray, w: int, wt: np.ndarray) -> np.ndarray:\n    \"\"\"Convolution helper for moving\u2011average\u2011style filters.\"\"\"\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    return np.convolve(x, wt, mode=\"valid\")\n\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"Uniform moving average (basic filter).\"\"\"\n    return _ma(x, window_size, np.ones(window_size) / window_size)\n\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"Exponentially weighted moving average.\"\"\"\n    wt = np.exp(np.linspace(-2, 0, window_size))\n    wt /= wt.sum()\n    return _ma(x, window_size, wt)\n\n\ndef ema_filter(x, window_size=20):\n    \"\"\"Classic exponential moving average (recursive).\"\"\"\n    x = np.asarray(x, float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.empty(0, float)\n    alpha = 2.0 / (window_size + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[window_size - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"Detrend with a simple MA then apply a weighted MA.\"\"\"\n    trend = adaptive_filter(x, window_size)\n    if trend.size == 0:\n        return np.empty(0, float)\n    trend_full = np.concatenate((np.full(window_size - 1, trend[0]), trend))\n    detrended = np.asarray(x, float) - trend_full\n    return weighted_filter(detrended, window_size)\n\n\ndef gaussian_ma(x, window_size=20):\n    \"\"\"Moving average with Gaussian kernel (smooth, bell\u2011shaped weighting).\"\"\"\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    sigma = max(window_size / 6.0, 0.1)\n    centre = (window_size - 1) / 2.0\n    i = np.arange(window_size, dtype=float)\n    wt = np.exp(-0.5 * ((i - centre) / sigma) ** 2)\n    wt /= wt.sum()\n    return _ma(x, window_size, wt)\n\n\ndef median_ma(x, window_size=20):\n    \"\"\"Median filter \u2013 robust to spikes/outliers.\"\"\"\n    x = np.asarray(x, float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.empty(0, float)\n    out_len = x.size - window_size + 1\n    out = np.empty(out_len, float)\n    for i in range(out_len):\n        out[i] = np.median(x[i : i + window_size])\n    return out\n\n\ndef double_enhanced(x, window_size=20):\n    \"\"\"\n    Two\u2011stage enhancement:\n    1. Detrended weighted smoothing (enhanced_filter_with_trend_preservation).\n    2. Light uniform smoothing with a smaller window (\u2248 half size).\n    \"\"\"\n    first = enhanced_filter_with_trend_preservation(x, window_size)\n    if first.size == 0:\n        return np.empty(0, float)\n    second_w = max(1, window_size // 2)\n    return adaptive_filter(first, second_w)\n\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"Mean\u2011squared residual between original and filtered signals.\"\"\"\n    m = min(len(original), len(filtered))\n    if m == 0:\n        return np.inf\n    return float(np.var(original[:m] - filtered[:m]))\n\n\ndef _select_best_filter(x: np.ndarray, window_size: int) -> np.ndarray:\n    \"\"\"Pick the filter with the lowest residual variance.\"\"\"\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n        \"gaussian\": gaussian_ma(x, window_size),\n        \"median\": median_ma(x, window_size),\n        \"double\": double_enhanced(x, window_size),\n    }\n    best_key = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_key]\n\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n    Supported ``algorithm_type`` values:\n        - \"basic\"\n        - \"weighted\"\n        - \"ema\"\n        - \"enhanced\"\n        - \"gaussian\"\n        - \"median\"\n        - \"double\"\n        - any other value \u2192 automatic selection of the best filter.\n    \"\"\"\n    dispatch = {\n        \"basic\": adaptive_filter,\n        \"weighted\": weighted_filter,\n        \"ema\": ema_filter,\n        \"enhanced\": enhanced_filter_with_trend_preservation,\n        \"gaussian\": gaussian_ma,\n        \"median\": median_ma,\n        \"double\": double_enhanced,\n    }\n    if algorithm_type in dispatch:\n        return dispatch[algorithm_type](input_signal, window_size)\n    # Fallback \u2013 choose the most effective filter automatically\n    return _select_best_filter(np.asarray(input_signal, float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["def advanced_filter(x, window_size=20):\n    \"\"\"\n    Multi\u2011stage enhanced filter:\n    1. Detrended weighted smoothing (same as ``enhanced_filter_with_trend_preservation``).\n    2. Median filter to suppress spikes/outliers.\n    3. Light uniform smoothing with a smaller window (\u2248 half size).\n    \"\"\"\n    # stage 1 \u2013 detrended weighted\n    first = enhanced_filter_with_trend_preservation(x, window_size)\n    if first.size == 0:\n        return np.empty(0, float)\n\n    # stage 2 \u2013 median to remove occasional spikes\n    medianed = median_ma(first, window_size)\n    if medianed.size == 0:\n        return np.empty(0, float)\n\n    # stage 3 \u2013 final light smoothing\n    second_w = max(1, window_size // 2)\n    return adaptive_filter(medianed, second_w)\n\n\ndef _select_best_filter(x: np.ndarray, window_size: int) -> np.ndarray:\n    \"\"\"Pick the filter with the lowest residual variance, now also considering ``advanced_filter``.\"\"\"\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n        \"gaussian\": gaussian_ma(x, window_size),\n        \"median\": median_ma(x, window_size),\n        \"double\": double_enhanced(x, window_size),\n        \"advanced\": advanced_filter(x, window_size),\n    }\n    best_key = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_key]\n\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n    Supported ``algorithm_type`` values:\n        - \"basic\"\n        - \"weighted\"\n        - \"ema\"\n        - \"enhanced\"\n        - \"gaussian\"\n        - \"median\"\n        - \"double\"\n        - \"advanced\"\n        - any other value \u2192 automatic selection of the best filter.\n    \"\"\"\n    dispatch = {\n        \"basic\": adaptive_filter,\n        \"weighted\": weighted_filter,\n        \"ema\": ema_filter,\n        \"enhanced\": enhanced_filter_with_trend_preservation,\n        \"gaussian\": gaussian_ma,\n        \"median\": median_ma,\n        \"double\": double_enhanced,\n        \"advanced\": advanced_filter,\n    }\n    if algorithm_type in dispatch:\n        return dispatch[algorithm_type](input_signal, window_size)\n    # Fallback \u2013 choose the most effective filter automatically\n    return _select_best_filter(np.asarray(input_signal, float), window_size)"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}