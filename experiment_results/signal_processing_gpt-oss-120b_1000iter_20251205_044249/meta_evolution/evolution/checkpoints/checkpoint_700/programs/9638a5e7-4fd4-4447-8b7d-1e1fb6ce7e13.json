{"id": "9638a5e7-4fd4-4447-8b7d-1e1fb6ce7e13", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_numpy(x: object) -> np.ndarray:\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(w: int) -> None:\n    \"\"\"Validate that window size is a positive integer.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window size must be a positive integer\")\n\n\ndef _gaussian_weights(w: int) -> np.ndarray:\n    \"\"\"Generate a normalized Gaussian kernel of length ``w``.\"\"\"\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w, dtype=float)\n    weights = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    return weights / weights.sum()\n\n\ndef adaptive_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Simple moving\u2011average filter (valid convolution).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(x_arr, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Gaussian\u2011weighted moving average (valid convolution).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    weights = _gaussian_weights(w)\n    return np.convolve(x_arr, weights, mode=\"valid\")\n\n\ndef ema_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Classic exponential moving average (output length = len(x)\u2011w+1).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(x_arr)\n    ema[0] = x_arr[0]\n    for i in range(1, len(x_arr)):\n        ema[i] = alpha * x_arr[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef median_filter(x: object, w: int = 20) -> np.ndarray:\n    \"\"\"Sliding\u2011window median filter (valid output).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    stride = x_arr.strides[0]\n    shape = (x_arr.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(\n        x_arr, shape=shape, strides=(stride, stride)\n    )\n    return np.median(windows, axis=1)\n\n\ndef _linear_detrend(x: object) -> np.ndarray:\n    \"\"\"Remove a linear trend via least\u2011squares fit.\"\"\"\n    x_arr = _to_numpy(x)\n    n = x_arr.size\n    if n == 0:\n        return x_arr\n    t = np.arange(n, dtype=float)\n    a, b = np.linalg.lstsq(\n        np.vstack([t, np.ones_like(t)]).T, x_arr, rcond=None\n    )[0]\n    return x_arr - (a * t + b)\n\n\ndef enhanced_filter_with_trend_preservation(x: object, w: int) -> np.ndarray:\n    \"\"\"\n    Detrend the signal linearly, then apply a Gaussian\u2011weighted moving average.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    detrended = _linear_detrend(x_arr)\n    return weighted_filter(detrended, w)\n\n\ndef combined_filter(x: object, w: int = 20) -> np.ndarray:\n    \"\"\"\n    Pipeline: linear detrend \u2192 Gaussian weighted average \u2192 median smoothing.\n    Returns an empty array if any stage fails.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n\n    detrended = _linear_detrend(x_arr)\n    weighted = weighted_filter(detrended, w)\n    if weighted.size == 0:\n        return np.array([], dtype=float)\n\n    return median_filter(weighted, w)\n\n\ndef _residual_variance(orig: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"\n    Compute variance of (orig \u2013 filtered) over the overlapping region.\n    Returns ``inf`` for empty overlap to penalise invalid solutions.\n    \"\"\"\n    n = min(len(orig), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(orig[:n] - filtered[:n]))\n\n\ndef _select_best_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"\n    Evaluate all available filters and return the output with the lowest residual variance.\n    Deterministic tie\u2011breaking is performed by alphabetical order of filter names.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    candidates = {\n        \"basic\": adaptive_filter(x_arr, w),\n        \"weighted\": weighted_filter(x_arr, w),\n        \"ema\": ema_filter(x_arr, w),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x_arr, w),\n        \"combined\": combined_filter(x_arr, w),\n    }\n    # Choose the filter with minimal residual variance; break ties alphabetically\n    best_name = min(\n        candidates,\n        key=lambda k: (_residual_variance(x_arr, candidates[k]), k)\n    )\n    return candidates[best_name]\n\n\ndef process_signal(sig: object, w: int = 20, alg: str = \"combined\") -> np.ndarray:\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Supported ``alg`` values:\n        - \"basic\": simple moving average\n        - \"weighted\": Gaussian weighted moving average\n        - \"ema\": classic exponential moving average\n        - \"enhanced\": automatic best\u2011filter selection\n        - \"combined\": linear detrend \u2192 weighted \u2192 median\n        - any other value: automatic selection of the best filter\n    \"\"\"\n    if alg == \"basic\":\n        return adaptive_filter(sig, w)\n    if alg == \"weighted\":\n        return weighted_filter(sig, w)\n    if alg == \"ema\":\n        return ema_filter(sig, w)\n    if alg == \"combined\":\n        return combined_filter(sig, w)\n    if alg == \"enhanced\":\n        # Treat \"enhanced\" as a request for the most effective filter\n        return _select_best_filter(sig, w)\n\n    # Fallback: automatic selection\n    return _select_best_filter(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "90a0cffe-5f10-4c05-8ea8-0ea2ded9c908", "generation": 10, "timestamp": 1764941761.2760372, "iteration_found": 657, "metrics": {"runs_successfully": 1.0, "composite_score": 0.4205150578718804, "output_length": 91.0, "overall_score": 0.38035985150742135, "slope_changes": 68.0, "lag_error": 0.9780360456577568, "avg_error": 1.2635358917076887, "false_reversals": 57.8, "correlation": 0.3334964145206185, "noise_reduction": 0.0, "smoothness_score": 0.22727272727272727, "responsiveness_score": 0.5055519600844633, "accuracy_score": 0.3334964145206185, "efficiency_score": 1.0, "execution_time": 0.0009633064270019531, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.3958493784730336, "output_length": 91.0, "overall_score": 0.36006395314799333, "slope_changes": 64.6, "lag_error": 1.6017393170552072, "avg_error": 1.3861988156801675, "false_reversals": 52.6, "correlation": 0.27221438940855636, "noise_reduction": 0.0, "smoothness_score": 0.23640661938534283, "responsiveness_score": 0.38435826120037864, "accuracy_score": 0.27221438940855636, "efficiency_score": 1.0, "execution_time": 0.0006167888641357422, "success_rate": 1.0}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)\n## OUTPUT FORMAT (CRITICAL)\n- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers\n- Do NOT include the markers themselves in your output\n- Do NOT include any code outside the markers (imports, run_packing, etc.)\n- The system will automatically merge your output with the preserved code sections\n\n## FOCUS\n- Improve ONLY the `construct_packing()` function and helper functions within the evolve block\n- Functions like `run_packing()` are preserved automatically - do not include them\n\nViolating these requirements will cause the program to fail evaluation.\n\n---\n\nYou are tasked with improving only the code that resides between the markers `# EVOLVE\u2011BLOCK\u2011START` and `# EVOLVE\u2011BLOCK\u2011END`. **Your entire response must consist solely of the revised code for that block \u2013 do not include the markers themselves, any surrounding imports, the `run_packing()` driver, or any other text.**  \n\n### Core Requirements\n1. **Output Format** \u2013 Exactly the code that belongs inside the evolve block, nothing else.  \n2. **Scope** \u2013 Modify only the `construct_packing()` function and any helper functions defined inside the block. Do not add, remove, or rename variables that are referenced outside the block.  \n3. **Correctness** \u2013 The updated functions must:\n   - Return a list of packing instructions that satisfies all constraints of the problem (e.g., no overlap, respects container dimensions, respects item orientations).  \n   - Handle edge\u2011cases gracefully (empty input, items larger than the container, duplicate items).  \n   - Be deterministic: given the same input, always produce the same output.  \n4. **Performance** \u2013 Aim for a simple, linear\u2011or\u2011near\u2011linear algorithm (e.g., first\u2011fit decreasing, shelf\u2011packing) rather than exponential backtracking or deep recursion.  \n5. **Readability** \u2013 Use clear variable names, short helper functions, and inline comments that explain *why* a step is taken, not just *what* is done.  \n\n### Forbidden Approaches (must be avoided)\n- **Aggressive heuristics that cause frequent invalid programs** \u2013 e.g., random placement, uncontrolled recursion depth, or unchecked use of `eval/exec`.  \n- **Over\u2011complicated logic** that leads to syntax or runtime errors (missing parentheses, mismatched indentation, undefined variables).  \n- **Repeated failures** \u2013 do not submit code that is likely to be syntactically invalid or that violates the output format.  \n- **Changing the public interface** of `construct_packing()` (its name, parameters, or return type).  \n\n### Suggested Strategies (choose one or combine)\n- **First\u2011Fit Decreasing (FFD)**:  \n  1. Sort items by descending volume or longest side.  \n  2. Iterate through sorted items, placing each at the lowest\u2011possible Y coordinate, then the lowest X, then the lowest Z that fits without overlap.  \n  3. Keep a simple list of already\u2011placed boxes and check for intersection using axis\u2011aligned bounding\u2011box overlap tests.  \n\n- **Shelf/Layer Packing**:  \n  1. Create horizontal \u201cshelves\u201d on the floor of the container; each shelf height equals the tallest item placed on it.  \n  2. Fill a shelf left\u2011to\u2011right until width is exhausted, then start a new shelf above.  \n  3. When vertical space runs out, start a new \u201clayer\u201d (increase Z).  \n\n- **Greedy Space Subdivision**:  \n  1. Maintain a list of free rectangular spaces.  \n  2. For each item, pick the smallest free space that fits (first\u2011fit).  \n  3. Split the chosen space into up to three new free spaces (right, front, above).  \n\n- **Safety Checks**:  \n  * After each placement, verify that the new box does not intersect any previously placed box.  \n  * Verify that the box stays inside container bounds.  \n  * If a box cannot be placed, skip it and continue; the function should still return a valid packing for the subset.  \n\n### Implementation Tips\n- Write a small helper `fits(box, space)` that returns `True` if `box` fits entirely within `space`.  \n- Write a helper `overlaps(box1, box2)` that checks axis\u2011aligned overlap.  \n- Keep the main loop simple: `for item in sorted_items:` \u2192 attempt placement \u2192 if successful, `placements.append(placement)`.  \n- Return `placements` (a list of dictionaries or tuples) exactly as the original function expects.  \n\nRemember: **Only the revised code inside the evolve block will be merged with the surrounding scaffold**. Ensure the code is syntactically correct, respects the required function signatures, and follows the constraints above.", "user": "# Current Program Information\n- Fitness: 13.5069\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 14.0152 \u2192 13.5069. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4205, output_length: 91.0000, overall_score: 0.3804, slope_changes: 68.0000, lag_error: 0.9780, avg_error: 1.2635, false_reversals: 57.8000, correlation: 0.3335, noise_reduction: 0.0000, smoothness_score: 0.2273, responsiveness_score: 0.5056, accuracy_score: 0.3335, efficiency_score: 1.0000, execution_time: 0.0015, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4107, output_length: 91.0000, overall_score: 0.3693, slope_changes: 70.2000, lag_error: 1.0018, avg_error: 1.3037, false_reversals: 59.0000, correlation: 0.3035, noise_reduction: 0.0000, smoothness_score: 0.2217, responsiveness_score: 0.4996, accuracy_score: 0.3035, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4001, output_length: 91.0000, overall_score: 0.3625, slope_changes: 80.4000, lag_error: 0.9635, avg_error: 1.2731, false_reversals: 65.8000, correlation: 0.3131, noise_reduction: 0.0000, smoothness_score: 0.1992, responsiveness_score: 0.5093, accuracy_score: 0.3131, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 15.2834)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _prep(x, ws):\n    ws = int(ws)\n    if ws <= 0:\n        raise ValueError(f\"window_size must be positive, got {ws}\")\n    a = np.asarray(x, dtype=float).ravel()\n    if a.size < ws:\n        return np.empty(0, dtype=float), ws\n    return a, ws\n\n@lru_cache(maxsize=64)\ndef _expw(ws):\n    w = np.exp(np.linspace(-2, 0, ws))\n    return w / w.sum()\n\ndef adaptive_filter(x, window_size=20):\n    a, ws = _prep(x, window_size)\n    if a.size == 0:\n        return a\n    c = np.cumsum(np.insert(a, 0, 0.0))\n    return (c[ws:] - c[:-ws]) / ws\n\ndef weighted_filter(x, window_size=20):\n    a, ws = _prep(x, window_size)\n    if a.size == 0:\n        return a\n    return np.convolve(a, _expw(ws), mode=\"valid\")\n\ndef exponential_smoothing(x, window_size=20):\n    a, ws = _prep(x, window_size)\n    if a.size == 0:\n        return a\n    alpha = 2.0 / (ws + 1.0)\n    y = np.empty_like(a)\n    y[0] = a[0]\n    for i in range(1, a.size):\n        y[i] = alpha * a[i] + (1 - alpha) * y[i - 1]\n    return y[ws - 1 :]\n\ndef _resvar(orig, filt):\n    m = min(len(orig), len(filt))\n    if m == 0:\n        return float(\"inf\")\n    d = orig[:m] - filt[:m]\n    return float(np.mean(d * d))\n\ndef _combined(x, ws):\n    a, _ = _prep(x, ws)\n    if a.size == 0:\n        return a\n    # generate candidate filters\n    cand = {\n        \"basic\": adaptive_filter(a, ws),\n        \"weighted\": weighted_filter(a, ws),\n        \"exp\": exponential_smoothing(a, ws),\n    }\n    # compute residual variances, keep only non\u2011empty results\n    vars = {k: _resvar(a, v) for k, v in cand.items() if v.size}\n    if not vars:\n        return np.empty(0, dtype=float)\n    # perfect match shortcut\n    for k, v in vars.items():\n        if v == 0.0:\n            return cand[k][:len(a) - ws + 1]\n    # inverse\u2011variance weighting (deterministic order)\n    keys = sorted(vars)\n    inv = np.array([1.0 / vars[k] for k in keys])\n    wts = inv / inv.sum()\n    min_len = min(len(cand[k]) for k in keys)\n    combined = sum(wts[i] * cand[k][:min_len] for i, k in enumerate(keys))\n    return combined\n\ndef _best(x, ws):\n    return _combined(x, ws)\n\ndef process_signal(sig, window_size=20, algorithm_type=\"enhanced\"):\n    alg = str(algorithm_type).lower()\n    if alg == \"basic\":\n        return adaptive_filter(sig, window_size)\n    if alg == \"enhanced\":\n        return _combined(sig, window_size)\n    if alg == \"exp\":\n        return exponential_smoothing(sig, window_size)\n    return _best(sig, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4001), Performs well on output_length (91.0000), Performs well on overall_score (0.3625), Performs well on slope_changes (80.4000), Performs well on lag_error (0.9635), Performs well on avg_error (1.2731), Performs well on false_reversals (65.8000), Performs well on correlation (0.3131), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1992), Performs well on responsiveness_score (0.5093), Performs well on accuracy_score (0.3131), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 14.2259)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _prepare(x, ws):\n    ws = int(ws)\n    if ws <= 0:\n        raise ValueError(\"window_size must be positive\")\n    arr = np.asarray(x, dtype=float)\n    if arr.ndim != 1:\n        raise ValueError(\"input must be 1\u2011D\")\n    if arr.size < ws:\n        return np.empty(0, dtype=float), ws\n    return arr, ws\n\n@lru_cache(maxsize=64)\ndef _exp_weights(ws):\n    w = np.exp(np.linspace(-2, 0, ws))\n    return w / w.sum()\n\ndef adaptive_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    c = np.cumsum(np.insert(a, 0, 0.0))\n    return (c[w:] - c[:-w]) / w\n\ndef weighted_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    return np.convolve(a, _exp_weights(w), mode=\"valid\")\n\ndef ema_filter(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    trend = adaptive_filter(a, w)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = a - trend_full\n    return weighted_filter(detrended, w)\n\ndef _hybrid_filter(x, window_size=20):\n    \"\"\"Average of weighted and adaptive filters \u2013 keeps length unchanged.\"\"\"\n    a, w = _prepare(x, window_size)\n    if a.size == 0:\n        return a\n    weighted = weighted_filter(a, w)\n    adaptive = adaptive_filter(a, w)\n    # both have identical length (n\u2011w+1)\n    return (weighted + adaptive) / 2.0\n\ndef _residual_variance(orig, filt):\n    m = min(len(orig), len(filt))\n    return float(np.var(orig[:m] - filt[:m])) if m else float(\"inf\")\n\ndef _select_best_filter(x, window_size):\n    cand = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n        \"hybrid\": _hybrid_filter(x, window_size),\n    }\n    return cand[min(cand, key=lambda k: _residual_variance(x, cand[k]))]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    alg = (algorithm_type or \"\").lower()\n    if alg == \"basic\":\n        return adaptive_filter(input_signal, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if alg == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if alg == \"enhanced\":\n        # use hybrid for stronger noise reduction while preserving length\n        return _hybrid_filter(input_signal, window_size)\n    # fallback to auto\u2011selection of the best filter\n    return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4107), Performs well on output_length (91.0000), Performs well on overall_score (0.3693), Performs well on slope_changes (70.2000), Performs well on lag_error (1.0018), Performs well on avg_error (1.3037), Performs well on false_reversals (59.0000), Performs well on correlation (0.3035), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2217), Performs well on responsiveness_score (0.4996), Performs well on accuracy_score (0.3035), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_numpy(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _ma(x, w):\n    \"\"\"Simple moving average (valid convolution).\"\"\"\n    a = _to_numpy(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\n\ndef _ema(x, w):\n    \"\"\"Classic exponential moving average aligned with MA output length.\"\"\"\n    a = _to_numpy(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, len(a)):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef _gaussian(x, w):\n    \"\"\"Gaussian\u2011kernel moving average.\"\"\"\n    a = _to_numpy(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w, dtype=float)\n    kernel = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    kernel /= kernel.sum()\n    return np.convolve(a, kernel, mode=\"valid\")\n\n\ndef _median(x, w):\n    \"\"\"Median filter.\"\"\"\n    a = _to_numpy(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n    stride = a.strides[0]\n    shape = (a.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(a, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef _combined_ma_ema(x, w):\n    \"\"\"Average of MA and EMA (both have the same length).\"\"\"\n    ma = _ma(x, w)\n    ema = _ema(x, w)\n    if ma.size and ema.size:\n        return (ma + ema) / 2.0\n    return ma if ma.size else ema\n\n\ndef _detrended_weighted(x, w):\n    \"\"\"\n    Detrend using a simple moving average, smooth the detrended series\n    with a Gaussian weighted filter, then re\u2011add the trend.\n    \"\"\"\n    a = _to_numpy(x)\n    if w <= 0 or a.size < w:\n        return np.array([], dtype=float)\n\n    # Estimate local trend (MA)\n    trend = _ma(a, w)                     # length = n - w + 1\n    # Pad trend to original length by repeating edge values\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n\n    # Detrend\n    detrended = a - trend_full\n\n    # Smooth detrended series with Gaussian kernel\n    smooth = _gaussian(detrended, w)\n\n    # Re\u2011add trend (already aligned with smooth output)\n    return smooth + trend\n\n\ndef _residual_variance(orig, filt):\n    \"\"\"Mean\u2011squared deviation between aligned signals.\"\"\"\n    if filt.size == 0:\n        return float(\"inf\")\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n]))\n\n\ndef _best_filter(x, w):\n    \"\"\"\n    Select the filter with the lowest residual variance.\n    Considers MA, EMA, Gaussian, Median, combined MA/EMA, and detrended weighted.\n    \"\"\"\n    a = _to_numpy(x)\n    candidates = {\n        \"ma\": _ma(a, w),\n        \"ema\": _ema(a, w),\n        \"gaussian\": _gaussian(a, w),\n        \"median\": _median(a, w),\n        \"combined\": _combined_ma_ema(a, w),\n        \"detrended\": _detrended_weighted(a, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.array([], dtype=float)\n    # Return the filter with minimal residual variance\n    best_key = min(candidates, key=lambda k: _residual_variance(a, candidates[k]))\n    return candidates[best_key]\n\n\ndef adaptive_filter(x, w=20):\n    \"\"\"Alias for simple moving\u2011average.\"\"\"\n    return _ma(x, w)\n\n\ndef process_signal(sig, w=20, algorithm_type=\"combined\"):\n    \"\"\"\n    Dispatch to requested filter.\n    Supported types (case\u2011insensitive):\n        basic/ma, ewma/ema, weighted, median, combined/enhanced.\n    Any other value falls back to automatic best\u2011filter selection.\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"basic\", \"ma\"):\n        return _ma(sig, w)\n    if alg in (\"ewma\", \"ema\"):\n        return _ema(sig, w)\n    if alg == \"weighted\":\n        return _gaussian(sig, w)\n    if alg == \"median\":\n        return _median(sig, w)\n    if alg in (\"combined\", \"enhanced\"):\n        return _best_filter(sig, w)\n    # Fallback to automatic selection\n    return _best_filter(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4205), Performs well on output_length (91.0000), Performs well on overall_score (0.3804), Performs well on slope_changes (68.0000), Performs well on lag_error (0.9780), Performs well on avg_error (1.2635), Performs well on false_reversals (57.8000), Performs well on correlation (0.3335), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2273), Performs well on responsiveness_score (0.5056), Performs well on accuracy_score (0.3335), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0015), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _arr(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(arr, w):\n    \"\"\"Return True if window size is positive and fits the array.\"\"\"\n    return w > 0 and arr.size >= w\n\n\ndef _ma(x, w, wt=None):\n    \"\"\"Simple moving average (uniform or custom weights).\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    if wt is None:\n        wt = np.ones(w) / w\n    else:\n        wt = np.asarray(wt, dtype=float)\n        if wt.size != w:\n            raise ValueError(\"Weight vector length must equal window size\")\n        wt = wt / wt.sum()\n    return np.convolve(a, wt, mode=\"valid\")\n\n\ndef _ema(x, w):\n    \"\"\"Classic exponential moving average (recursive).\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(a)\n    e[0] = a[0]\n    for i in range(1, len(a)):\n        e[i] = alpha * a[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\n\ndef _gaussian(x, w):\n    \"\"\"Gaussian\u2011kernel moving average.\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w, dtype=float)\n    kernel = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    kernel /= kernel.sum()\n    return np.convolve(a, kernel, mode=\"valid\")\n\n\ndef _median(x, w):\n    \"\"\"Median filter.\"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n    stride = a.strides[0]\n    shape = (a.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(a, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef _combined_ma_ema(x, w):\n    \"\"\"Average of MA and EMA where both are available.\"\"\"\n    ma = _ma(x, w)\n    ema = _ema(x, w)\n    if ma.size and ema.size:\n        return (ma + ema) / 2.0\n    return ma if ma.size else ema\n\n\ndef _detrended_weighted(x, w):\n    \"\"\"\n    Detrend with a simple moving average, smooth the detrended series\n    using a Gaussian kernel, then re\u2011add the trend.\n    \"\"\"\n    a = _arr(x)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n\n    # Estimate trend via MA\n    trend = _ma(a, w)                     # length = n - w + 1\n    # Pad trend to original length (repeat first value for missing prefix)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n\n    # Detrend\n    detrended = a - trend_full\n\n    # Smooth detrended part\n    smooth = _gaussian(detrended, w)\n\n    # Align and add back trend (trend already aligned with smooth output)\n    return smooth + trend\n\n\ndef _resvar(orig, filt):\n    \"\"\"Mean\u2011squared deviation between overlapping portions of two signals.\"\"\"\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n])) if n else float(\"inf\")\n\n\ndef _best(x, w):\n    \"\"\"Select the filter with the lowest residual variance (deterministic tie\u2011break).\"\"\"\n    a = _arr(x)\n    candidates = {\n        \"ma\": _ma(a, w),\n        \"ema\": _ema(a, w),\n        \"gauss\": _gaussian(a, w),\n        \"median\": _median(a, w),\n        \"combined\": _combined_ma_ema(a, w),\n        \"detrended\": _detrended_weighted(a, w),\n    }\n    # Discard empty results\n    filtered = [(name, arr) for name, arr in candidates.items() if arr.size]\n    if not filtered:\n        return np.empty(0, float)\n\n    # Compute residual variance for each candidate\n    metrics = [( _resvar(a, arr), name, arr) for name, arr in filtered]\n    # Deterministic: smallest variance, then alphabetical name\n    _, _, best_arr = min(metrics, key=lambda t: (t[0], t[1]))\n    return best_arr\n\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    w : int, optional\n        Window size (default 20).\n    alg : str, optional\n        Algorithm identifier. Supported (case\u2011insensitive):\n        - \"basic\" / \"ma\"          : simple moving average\n        - \"ema\" / \"ewma\"          : exponential moving average\n        - \"gaussian\" / \"weighted\": Gaussian\u2011kernel smoothing\n        - \"median\"                : median filter\n        - \"combined\" / \"average\"  : average of MA and EMA\n        - \"detrended\" / \"trend\"  : detrended\u2011weighted filter\n        - any other value         : automatic best\u2011filter selection\n\n    Returns\n    -------\n    ndarray\n        Filtered signal (may be empty if window is invalid).\n    \"\"\"\n    a = _arr(sig)\n    if not _validate_window(a, w):\n        return np.empty(0, float)\n\n    key = (alg or \"\").lower()\n    if key in (\"basic\", \"ma\"):\n        return _ma(a, w)\n    if key in (\"ema\", \"ewma\"):\n        return _ema(a, w)\n    if key in (\"gaussian\", \"weighted\"):\n        return _gaussian(a, w)\n    if key == \"median\":\n        return _median(a, w)\n    if key in (\"combined\", \"average\"):\n        return _combined_ma_ema(a, w)\n    if key in (\"detrended\", \"trend\"):\n        return _detrended_weighted(a, w)\n\n    # Fallback: automatic selection of the best filter\n    return _best(a, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_np(x):\n    \"\"\"Convert input to 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _gaussian_weights(w):\n    \"\"\"Generate normalized Gaussian kernel of length w.\"\"\"\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w)\n    weights = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    return weights / weights.sum()\n\n\ndef adaptive_filter(x, w=20):\n    \"\"\"Simple moving\u2011average (valid convolution).\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(x, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted_filter(x, w=20):\n    \"\"\"Gaussian\u2011weighted moving average.\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    weights = _gaussian_weights(w)\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema_filter(x, w=20):\n    \"\"\"Classic exponential moving average (EMA) aligned with MA length.\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(x, w=20):\n    \"\"\"\n    Detrend with a simple moving average, then apply a Gaussian weighted filter.\n    Returns empty array if detrending fails.\n    \"\"\"\n    trend = adaptive_filter(x, w)\n    if trend.size == 0:\n        return np.array([], dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = _to_np(x) - trend_full\n    return weighted_filter(detrended, w)\n\n\ndef median_filter(x, w=20):\n    \"\"\"Sliding\u2011window median filter.\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    stride = x.strides[0]\n    shape = (x.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(x, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef combined_filter(x, w=20):\n    \"\"\"\n    Detrend \u2192 Gaussian weighted moving average \u2192 median smoothing.\n    Returns empty array if any stage fails.\n    \"\"\"\n    trend = adaptive_filter(x, w)\n    if trend.size == 0:\n        return np.array([], dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = _to_np(x) - trend_full\n\n    weighted = weighted_filter(detrended, w)\n    if weighted.size == 0:\n        return np.array([], dtype=float)\n\n    return median_filter(weighted, w)\n\n\ndef _residual_variance(original, filtered):\n    \"\"\"Variance of (original \u2013 filtered) after aligning lengths.\"\"\"\n    if filtered.size == 0:\n        return float(\"inf\")\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(original[:n] - filtered[:n]))\n\n\ndef _select_best_filter(x, w):\n    \"\"\"Choose the filter with the lowest residual variance.\"\"\"\n    x_np = _to_np(x)\n    candidates = {\n        \"basic\": adaptive_filter(x_np, w),\n        \"weighted\": weighted_filter(x_np, w),\n        \"ema\": ema_filter(x_np, w),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x_np, w),\n        \"combined\": combined_filter(x_np, w),\n        \"median\": median_filter(x_np, w),\n    }\n    best_key = min(candidates, key=lambda k: _residual_variance(x_np, candidates[k]))\n    return candidates[best_key]\n\n\ndef process_signal(sig, window_size=20, algorithm_type=\"basic\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Supported algorithm_type values (case\u2011insensitive):\n        - \"basic\"   : simple moving average\n        - \"weighted\": Gaussian weighted average\n        - \"ema\"     : classic EMA\n        - \"enhanced\": detrended weighted filter (now auto\u2011selected for best result)\n        - \"combined\": detrend \u2192 weighted \u2192 median\n        - \"median\"  : median filter\n        - any other value falls back to automatic selection.\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    x = _to_np(sig)\n\n    if alg == \"basic\":\n        return adaptive_filter(x, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(x, window_size)\n    if alg == \"ema\":\n        return ema_filter(x, window_size)\n    if alg == \"combined\":\n        return combined_filter(x, window_size)\n    if alg == \"median\":\n        return median_filter(x, window_size)\n    # Treat \"enhanced\" as a request for the best available filter\n    if alg == \"enhanced\":\n        return _select_best_filter(x, window_size)\n\n    # Fallback: auto\u2011select best filter\n    return _select_best_filter(x, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 14.0152, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_arr(x):\n    \"\"\"Convert input to 1\u2011D float ndarray.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _check_window(w):\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window_size must be a positive integer\")\n\n\ndef _ma(a, w):\n    \"\"\"Simple moving average (valid convolution).\"\"\"\n    _check_window(w)\n    if a.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(a, np.ones(w) / w, mode=\"valid\")\n\n\ndef _gauss(a, w):\n    \"\"\"Gaussian weighted average.\"\"\"\n    _check_window(w)\n    if a.size < w:\n        return np.array([], dtype=float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w)\n    wts = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    wts /= wts.sum()\n    return np.convolve(a, wts, mode=\"valid\")\n\n\ndef _ema(a, w):\n    \"\"\"Exponential moving average aligned to MA length.\"\"\"\n    _check_window(w)\n    if a.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef _median(a, w):\n    \"\"\"Median filter (valid length).\"\"\"\n    _check_window(w)\n    if a.size < w:\n        return np.array([], dtype=float)\n    stride = a.strides[0]\n    shape = (a.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(a, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef _hann(a, w):\n    \"\"\"Hann\u2011window low\u2011pass filter.\"\"\"\n    _check_window(w)\n    if a.size < w:\n        return np.array([], dtype=float)\n    win = np.hanning(w)\n    win /= win.sum()\n    return np.convolve(a, win, mode=\"valid\")\n\n\ndef _residual_variance(orig, filt):\n    \"\"\"Variance of original\u2011filtered over overlapping region.\"\"\"\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n])) if n else float(\"inf\")\n\n\ndef _best_filter(x, w):\n    \"\"\"Pick filter with smallest residual variance.\"\"\"\n    a = _to_arr(x)\n    candidates = {\n        \"ma\": _ma(a, w),\n        \"gauss\": _gauss(a, w),\n        \"ema\": _ema(a, w),\n        \"median\": _median(a, w),\n        \"hann\": _hann(a, w),\n    }\n    # filter out empty results; fallback to MA\n    nonempty = {k: v for k, v in candidates.items() if v.size}\n    if not nonempty:\n        return _ma(a, w)\n    best_key = min(nonempty, key=lambda k: _residual_variance(a, nonempty[k]))\n    return nonempty[best_key]\n\n\ndef adaptive_filter(x: np.ndarray, window_size: int = 20) -> np.ndarray:\n    \"\"\"Alias for simple moving average.\"\"\"\n    return _ma(_to_arr(x), window_size)\n\n\ndef process_signal(\n    input_signal: np.ndarray,\n    window_size: int = 20,\n    algorithm_type: str = \"combined\",\n) -> np.ndarray:\n    \"\"\"Dispatch to the requested filtering algorithm.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        - \"basic\" / \"ma\": simple moving average\n        - \"weighted\": Gaussian weighted average\n        - \"ema\": exponential moving average\n        - \"median\": median filter\n        - \"hann\": Hann\u2011window low\u2011pass filter\n        - \"enhanced\", \"combined\", \"auto\": automatic best\u2011filter selection\n    Any other value falls back to the automatic selection.\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    a = _to_arr(input_signal)\n\n    if alg in (\"basic\", \"ma\"):\n        return _ma(a, window_size)\n    if alg == \"weighted\":\n        return _gauss(a, window_size)\n    if alg == \"ema\":\n        return _ema(a, window_size)\n    if alg == \"median\":\n        return _median(a, window_size)\n    if alg == \"hann\":\n        return _hann(a, window_size)\n    if alg in (\"enhanced\", \"combined\", \"auto\"):\n        return _best_filter(a, window_size)\n\n    # Unknown algorithm \u2013 fall back to automatic selection\n    return _best_filter(a, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 2 (Score: 13.4402, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef adaptive_filter(x: np.ndarray, window_size: int = 20) -> np.ndarray:\n    \"\"\"\n    Simple moving average filter using convolution.\n    Returns an array of length len(x) - window_size + 1.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    return np.convolve(x, np.ones(window_size) / window_size, mode=\"valid\")\n\n\ndef weighted_filter(x: np.ndarray, window_size: int = 20) -> np.ndarray:\n    \"\"\"\n    Exponential weighted moving average.\n    Emphasises recent samples while preserving overall trend.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    # exponential weights that increase towards the newest sample\n    weights = np.exp(np.linspace(-2, 0, window_size))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema_filter(x: np.ndarray, window_size: int = 20) -> np.ndarray:\n    \"\"\"\n    Classic exponential moving average (EMA).\n    Output length matches other filters (len(x) - window_size + 1).\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (window_size + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[window_size - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(\n    x: np.ndarray, window_size: int = 20\n) -> np.ndarray:\n    \"\"\"\n    Detrends the signal using a simple moving average, then applies\n    a weighted moving average to the detrended series.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n\n    # Estimate local trend\n    trend = adaptive_filter(x, window_size)\n    # Pad trend to original length (repeat edge values)\n    trend_full = np.concatenate((np.full(window_size - 1, trend[0]), trend))\n    detrended = x - trend_full\n    return weighted_filter(detrended, window_size)\n\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"\n    Compute variance of the residual (original - filtered).\n    Signals are aligned to the shortest length.\n    \"\"\"\n    min_len = min(len(original), len(filtered))\n    if min_len == 0:\n        return np.inf\n    residual = original[:min_len] - filtered[:min_len]\n    return float(np.var(residual))\n\n\ndef _select_best_filter(x: np.ndarray, window_size: int) -> np.ndarray:\n    \"\"\"\n    Evaluate all available filters and return the one that yields the lowest\n    residual variance (i.e., highest estimated noise reduction).\n    \"\"\"\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n        \"combined\": combined_filter(x, window_size),\n    }\n    best_name = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_name]\n\n\ndef median_filter(x: np.ndarray, window_size: int = 20) -> np.ndarray:\n    \"\"\"\n    Sliding window median filter.\n    Returns an array of length len(x) - window_size + 1.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n\n    stride = x.strides[0]\n    shape = (x.size - window_size + 1, window_size)\n    windows = np.lib.stride_tricks.as_strided(\n        x, shape=shape, strides=(stride, stride)\n    )\n    return np.median(windows, axis=1)\n\n\ndef combined_filter(x: np.ndarray, window_size: int = 20) -> np.ndarray:\n    \"\"\"\n    Detrend \u2192 weighted moving average \u2192 median smoothing.\n    This chain reduces trend, smooths with exponential weights,\n    and finally removes outliers via median filtering.\n    \"\"\"\n    # Detrend using simple moving average\n    trend = adaptive_filter(x, window_size)\n    if trend.size == 0:\n        return np.array([], dtype=float)\n    trend_full = np.concatenate((np.full(window_size - 1, trend[0]), trend))\n    detrended = x - trend_full\n\n    # Weighted moving average on detrended signal\n    weighted = weighted_filter(detrended, window_size)\n    if weighted.size == 0:\n        return np.array([], dtype=float)\n\n    # Median smoothing on the weighted result\n    return median_filter(weighted, window_size)\n\n\ndef process_signal(\n    input_signal: np.ndarray,\n    window_size: int = 20,\n    algorithm_type: str = \"combined\",\n) -> np.ndarray:\n    \"\"\"\n    Dispatches to the requested filtering algorithm.\n    Supported types:\n        - \"basic\": simple moving average (adaptive_filter)\n        - \"weighted\": exponential weighted moving average (weighted_filter)\n        - \"ema\": classic exponential moving average (ema_filter)\n        - \"enhanced\": **replaced with the best auto\u2011selected filter** for higher quality output\n        - \"combined\": detrend \u2192 weighted \u2192 median (combined_filter)\n        - any other value: automatic selection of the best filter based on residual variance.\n    \"\"\"\n    if algorithm_type == \"basic\":\n        return adaptive_filter(input_signal, window_size)\n    if algorithm_type == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if algorithm_type == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if algorithm_type == \"enhanced\":\n        # Use the auto\u2011selection mechanism to pick the most effective filter\n        return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n    if algorithm_type == \"combined\":\n        return combined_filter(input_signal, window_size)\n\n    # Fallback: automatic selection\n    return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 3 (Score: 14.0152, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_np(x):\n    \"\"\"Convert input to 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _gaussian_weights(w):\n    \"\"\"Generate normalized Gaussian kernel of length w.\"\"\"\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w)\n    weights = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    return weights / weights.sum()\n\n\ndef adaptive_filter(x, w=20):\n    \"\"\"Simple moving\u2011average (valid convolution).\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(x, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted_filter(x, w=20):\n    \"\"\"Gaussian\u2011weighted moving average.\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    weights = _gaussian_weights(w)\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema_filter(x, w=20):\n    \"\"\"Classic exponential moving average (EMA) aligned with MA length.\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(x, w=20):\n    \"\"\"\n    Detrend with a simple moving average, then apply a Gaussian weighted filter.\n    Returns empty array if detrending fails.\n    \"\"\"\n    trend = adaptive_filter(x, w)\n    if trend.size == 0:\n        return np.array([], dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = _to_np(x) - trend_full\n    return weighted_filter(detrended, w)\n\n\ndef median_filter(x, w=20):\n    \"\"\"Sliding\u2011window median filter.\"\"\"\n    x = _to_np(x)\n    if w <= 0 or x.size < w:\n        return np.array([], dtype=float)\n    stride = x.strides[0]\n    shape = (x.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(x, shape=shape, strides=(stride, stride))\n    return np.median(windows, axis=1)\n\n\ndef combined_filter(x, w=20):\n    \"\"\"\n    Detrend \u2192 Gaussian weighted moving average \u2192 median smoothing.\n    Returns empty array if any stage fails.\n    \"\"\"\n    trend = adaptive_filter(x, w)\n    if trend.size == 0:\n        return np.array([], dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = _to_np(x) - trend_full\n\n    weighted = weighted_filter(detrended, w)\n    if weighted.size == 0:\n        return np.array([], dtype=float)\n\n    return median_filter(weighted, w)\n\n\ndef _residual_variance(original, filtered):\n    \"\"\"Variance of (original \u2013 filtered) after aligning lengths.\"\"\"\n    if filtered.size == 0:\n        return float(\"inf\")\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(original[:n] - filtered[:n]))\n\n\ndef _select_best_filter(x, w):\n    \"\"\"Choose the filter with the lowest residual variance.\"\"\"\n    x_np = _to_np(x)\n    candidates = {\n        \"basic\": adaptive_filter(x_np, w),\n        \"weighted\": weighted_filter(x_np, w),\n        \"ema\": ema_filter(x_np, w),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x_np, w),\n        \"combined\": combined_filter(x_np, w),\n        \"median\": median_filter(x_np, w),\n    }\n    best_key = min(candidates, key=lambda k: _residual_variance(x_np, candidates[k]))\n    return candidates[best_key]\n\n\ndef process_signal(sig, window_size=20, algorithm_type=\"basic\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Supported algorithm_type values (case\u2011insensitive):\n        - \"basic\"   : simple moving average\n        - \"weighted\": Gaussian weighted average\n        - \"ema\"     : classic EMA\n        - \"enhanced\": detrended weighted filter (now auto\u2011selected for best result)\n        - \"combined\": detrend \u2192 weighted \u2192 median\n        - \"median\"  : median filter\n        - any other value falls back to automatic selection.\n    \"\"\"\n    alg = (algorithm_type or \"\").lower()\n    x = _to_np(sig)\n\n    if alg == \"basic\":\n        return adaptive_filter(x, window_size)\n    if alg == \"weighted\":\n        return weighted_filter(x, window_size)\n    if alg == \"ema\":\n        return ema_filter(x, window_size)\n    if alg == \"combined\":\n        return combined_filter(x, window_size)\n    if alg == \"median\":\n        return median_filter(x, window_size)\n    # Treat \"enhanced\" as a request for the best available filter\n    if alg == \"enhanced\":\n        return _select_best_filter(x, window_size)\n\n    # Fallback: auto\u2011select best filter\n    return _select_best_filter(x, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _to_numpy(x: object) -> np.ndarray:\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(w: int) -> None:\n    \"\"\"Validate that window size is a positive integer.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window size must be a positive integer\")\n\n\ndef adaptive_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Simple moving\u2011average filter (valid convolution).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(x_arr, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Exponential\u2011weighted moving average (valid convolution).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    weights = np.exp(np.linspace(-2, 0, w))\n    weights /= weights.sum()\n    return np.convolve(x_arr, weights, mode=\"valid\")\n\n\ndef ema_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Classic exponential moving average (output length = len(x)\u2011w+1).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(x_arr)\n    ema[0] = x_arr[0]\n    for i in range(1, len(x_arr)):\n        ema[i] = alpha * x_arr[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef median_filter(x: object, w: int = 20) -> np.ndarray:\n    \"\"\"Sliding\u2011window median filter (valid output).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    stride = x_arr.strides[0]\n    shape = (x_arr.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(\n        x_arr, shape=shape, strides=(stride, stride)\n    )\n    return np.median(windows, axis=1)\n\n\ndef _linear_detrend(x: object) -> np.ndarray:\n    \"\"\"Remove a linear trend via least\u2011squares fit.\"\"\"\n    x_arr = _to_numpy(x)\n    n = x_arr.size\n    if n == 0:\n        return x_arr\n    t = np.arange(n, dtype=float)\n    a, b = np.linalg.lstsq(\n        np.vstack([t, np.ones_like(t)]).T, x_arr, rcond=None\n    )[0]\n    return x_arr - (a * t + b)\n\n\ndef enhanced_filter_with_trend_preservation(x: object, w: int) -> np.ndarray:\n    \"\"\"\n    Detrend the signal linearly, then apply an exponential\u2011weighted moving average.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    detrended = _linear_detrend(x_arr)\n    return weighted_filter(detrended, w)\n\n\ndef combined_filter(x: object, w: int = 20) -> np.ndarray:\n    \"\"\"\n    Pipeline: linear detrend \u2192 weighted moving average \u2192 median smoothing.\n    Returns an empty array if any stage fails.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n\n    detrended = _linear_detrend(x_arr)\n    weighted = weighted_filter(detrended, w)\n    if weighted.size == 0:\n        return np.array([], dtype=float)\n\n    return median_filter(weighted, w)\n\n\ndef _residual_variance(orig: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"\n    Compute variance of (orig \u2013 filtered) over the overlapping region.\n    Returns ``inf`` for empty overlap to penalise invalid solutions.\n    \"\"\"\n    n = min(len(orig), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(orig[:n] - filtered[:n]))\n\n\ndef _select_best_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"\n    Evaluate all available filters and return the output with the lowest residual variance.\n    Deterministic tie\u2011breaking is performed by alphabetical order of filter names.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    candidates = {\n        \"basic\": adaptive_filter(x_arr, w),\n        \"weighted\": weighted_filter(x_arr, w),\n        \"ema\": ema_filter(x_arr, w),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x_arr, w),\n        \"combined\": combined_filter(x_arr, w),\n    }\n    best_name = min(\n        candidates,\n        key=lambda k: (_residual_variance(x_arr, candidates[k]), k)\n    )\n    return candidates[best_name]\n\n\ndef process_signal(sig: object, w: int = 20, alg: str = \"combined\") -> np.ndarray:\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Supported ``alg`` values:\n        - \"basic\": simple moving average\n        - \"weighted\": exponential weighted moving average\n        - \"ema\": classic exponential moving average\n        - \"enhanced\": linear detrend + weighted filter\n        - \"combined\": linear detrend \u2192 weighted \u2192 median\n        - any other value: automatic selection of the best filter\n    \"\"\"\n    if alg == \"basic\":\n        return adaptive_filter(sig, w)\n    if alg == \"weighted\":\n        return weighted_filter(sig, w)\n    if alg == \"ema\":\n        return ema_filter(sig, w)\n    if alg == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(sig, w)\n    if alg == \"combined\":\n        return combined_filter(sig, w)\n\n    # Fallback: automatic selection\n    return _select_best_filter(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["import numpy as np\n\ndef _to_numpy(x: object) -> np.ndarray:\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(w: int) -> None:\n    \"\"\"Validate that window size is a positive integer.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window size must be a positive integer\")\n\n\ndef _gaussian_weights(w: int) -> np.ndarray:\n    \"\"\"Generate a normalized Gaussian kernel of length ``w``.\"\"\"\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w, dtype=float)\n    weights = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    return weights / weights.sum()\n\n\ndef adaptive_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Simple moving\u2011average filter (valid convolution).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(x_arr, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Gaussian\u2011weighted moving average (valid convolution).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    weights = _gaussian_weights(w)\n    return np.convolve(x_arr, weights, mode=\"valid\")\n\n\ndef ema_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"Classic exponential moving average (output length = len(x)\u2011w+1).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(x_arr)\n    ema[0] = x_arr[0]\n    for i in range(1, len(x_arr)):\n        ema[i] = alpha * x_arr[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef median_filter(x: object, w: int = 20) -> np.ndarray:\n    \"\"\"Sliding\u2011window median filter (valid output).\"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    stride = x_arr.strides[0]\n    shape = (x_arr.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(\n        x_arr, shape=shape, strides=(stride, stride)\n    )\n    return np.median(windows, axis=1)\n\n\ndef _linear_detrend(x: object) -> np.ndarray:\n    \"\"\"Remove a linear trend via least\u2011squares fit.\"\"\"\n    x_arr = _to_numpy(x)\n    n = x_arr.size\n    if n == 0:\n        return x_arr\n    t = np.arange(n, dtype=float)\n    a, b = np.linalg.lstsq(\n        np.vstack([t, np.ones_like(t)]).T, x_arr, rcond=None\n    )[0]\n    return x_arr - (a * t + b)\n\n\ndef enhanced_filter_with_trend_preservation(x: object, w: int) -> np.ndarray:\n    \"\"\"\n    Detrend the signal linearly, then apply a Gaussian\u2011weighted moving average.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n    detrended = _linear_detrend(x_arr)\n    return weighted_filter(detrended, w)\n\n\ndef combined_filter(x: object, w: int = 20) -> np.ndarray:\n    \"\"\"\n    Pipeline: linear detrend \u2192 Gaussian weighted average \u2192 median smoothing.\n    Returns an empty array if any stage fails.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    if x_arr.size < w:\n        return np.array([], dtype=float)\n\n    detrended = _linear_detrend(x_arr)\n    weighted = weighted_filter(detrended, w)\n    if weighted.size == 0:\n        return np.array([], dtype=float)\n\n    return median_filter(weighted, w)\n\n\ndef _residual_variance(orig: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"\n    Compute variance of (orig \u2013 filtered) over the overlapping region.\n    Returns ``inf`` for empty overlap to penalise invalid solutions.\n    \"\"\"\n    n = min(len(orig), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(orig[:n] - filtered[:n]))\n\n\ndef _select_best_filter(x: object, w: int) -> np.ndarray:\n    \"\"\"\n    Evaluate all available filters and return the output with the lowest residual variance.\n    Deterministic tie\u2011breaking is performed by alphabetical order of filter names.\n    \"\"\"\n    _validate_window(w)\n    x_arr = _to_numpy(x)\n    candidates = {\n        \"basic\": adaptive_filter(x_arr, w),\n        \"weighted\": weighted_filter(x_arr, w),\n        \"ema\": ema_filter(x_arr, w),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x_arr, w),\n        \"combined\": combined_filter(x_arr, w),\n    }\n    # Choose the filter with minimal residual variance; break ties alphabetically\n    best_name = min(\n        candidates,\n        key=lambda k: (_residual_variance(x_arr, candidates[k]), k)\n    )\n    return candidates[best_name]\n\n\ndef process_signal(sig: object, w: int = 20, alg: str = \"combined\") -> np.ndarray:\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n\n    Supported ``alg`` values:\n        - \"basic\": simple moving average\n        - \"weighted\": Gaussian weighted moving average\n        - \"ema\": classic exponential moving average\n        - \"enhanced\": automatic best\u2011filter selection\n        - \"combined\": linear detrend \u2192 weighted \u2192 median\n        - any other value: automatic selection of the best filter\n    \"\"\"\n    if alg == \"basic\":\n        return adaptive_filter(sig, w)\n    if alg == \"weighted\":\n        return weighted_filter(sig, w)\n    if alg == \"ema\":\n        return ema_filter(sig, w)\n    if alg == \"combined\":\n        return combined_filter(sig, w)\n    if alg == \"enhanced\":\n        # Treat \"enhanced\" as a request for the most effective filter\n        return _select_best_filter(sig, w)\n\n    # Fallback: automatic selection\n    return _select_best_filter(sig, w)"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}