{"id": "ec1fe481-2baf-4f9c-96ab-bac11d65b0af", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\n\n\ndef _to_numpy(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _validate_window(w):\n    \"\"\"Ensure window size is a positive integer.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window_size must be a positive integer\")\n\n\ndef _linear_detrend(arr):\n    \"\"\"Remove linear trend using least\u2011squares regression.\"\"\"\n    n = arr.size\n    if n == 0:\n        return arr\n    t = np.arange(n, dtype=float)\n    A = np.vstack([t, np.ones_like(t)]).T\n    slope, intercept = np.linalg.lstsq(A, arr, rcond=None)[0]\n    return arr - (slope * t + intercept)\n\n\ndef _ma(x, w):\n    \"\"\"Simple moving average (valid convolution).\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    return np.convolve(arr, np.ones(w) / w, mode=\"valid\")\n\n\ndef _gaussian(x, w):\n    \"\"\"Gaussian\u2011weighted moving average (valid convolution).\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    sigma = 0.3 * w\n    centre = (w - 1) / 2.0\n    idx = np.arange(w)\n    weights = np.exp(-0.5 * ((idx - centre) / sigma) ** 2)\n    weights /= weights.sum()\n    return np.convolve(arr, weights, mode=\"valid\")\n\n\ndef _ema(x, w):\n    \"\"\"Exponential moving average aligned to the length of other filters.\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (w + 1)\n    ema = np.empty_like(arr)\n    ema[0] = arr[0]\n    for i in range(1, arr.size):\n        ema[i] = alpha * arr[i] + (1 - alpha) * ema[i - 1]\n    return ema[w - 1 :]\n\n\ndef _median(x, w):\n    \"\"\"Median filter over a sliding window (valid length).\"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n    stride = arr.strides[0]\n    shape = (arr.size - w + 1, w)\n    windows = np.lib.stride_tricks.as_strided(\n        arr, shape=shape, strides=(stride, stride)\n    )\n    return np.median(windows, axis=1)\n\n\ndef _combined(x, w):\n    \"\"\"\n    Detrend \u2192 Gaussian weighted moving average \u2192 median smoothing.\n    Returns an empty array if any stage fails.\n    \"\"\"\n    _validate_window(w)\n    arr = _to_numpy(x)\n    if arr.size < w:\n        return np.array([], dtype=float)\n\n    detrended = _linear_detrend(arr)\n    filtered = _gaussian(detrended, w)\n    if filtered.size == 0:\n        return np.array([], dtype=float)\n\n    return _median(filtered, w)\n\n\ndef _residual_variance(orig, filt):\n    \"\"\"Variance of (original \u2013 filtered) over the overlapping region.\"\"\"\n    if filt.size == 0:\n        return float(\"inf\")\n    n = min(len(orig), len(filt))\n    return float(np.var(orig[:n] - filt[:n]))\n\n\ndef _best_filter(x, w):\n    \"\"\"\n    Choose the filter with the lowest residual variance.\n    Deterministic tie\u2011break order: combined, gaussian, ema, median, ma.\n    \"\"\"\n    o = _to_numpy(x)\n    if o.size < w:\n        return np.array([], dtype=float)\n\n    candidates = {\n        \"combined\": _combined(o, w),\n        \"gaussian\": _gaussian(o, w),\n        \"ema\": _ema(o, w),\n        \"median\": _median(o, w),\n        \"ma\": _ma(o, w),\n    }\n    variances = {k: _residual_variance(o, v) for k, v in candidates.items()}\n    best_val = min(variances.values())\n    order = (\"combined\", \"gaussian\", \"ema\", \"median\", \"ma\")\n    for k in order:\n        if candidates[k].size and variances[k] == best_val:\n            return candidates[k]\n    return np.array([], dtype=float)\n\n\ndef _chunked_process(sig, w, chunk_size=2000):\n    \"\"\"\n    Process large signals by splitting them into manageable chunks.\n    Each chunk is filtered independently with the best filter and\n    the results are concatenated. Edge effects are ignored for simplicity.\n    \"\"\"\n    sig_arr = _to_numpy(sig)\n    n = sig_arr.size\n    if n <= chunk_size:\n        return _best_filter(sig_arr, w)\n\n    chunks = [sig_arr[i:i + chunk_size] for i in range(0, n, chunk_size)]\n    processed = [_best_filter(chunk, w) for chunk in chunks]\n    # Filtered chunks may be empty; filter those out before concatenation\n    processed = [p for p in processed if p.size]\n    return np.concatenate(processed) if processed else np.array([], dtype=float)\n\n\ndef process_signal(sig, w=20, algorithm_type=\"combined\", **kwargs):\n    \"\"\"\n    Dispatch to a filtering algorithm with optional chunked processing.\n\n    Supported ``algorithm_type`` values (case\u2011insensitive):\n        - \"basic\" or \"ma\": simple moving average\n        - \"weighted\": Gaussian weighted average\n        - \"ema\": exponential moving average\n        - \"median\": median filter\n        - \"enhanced\", \"combined\", \"auto\": automatic best\u2011filter selection\n    Any other value falls back to the automatic selection.\n\n    ``debug`` keyword (bool) adds a ``debug_info`` attribute with elapsed time.\n    \"\"\"\n    _validate_window(w)\n    sig_arr = _to_numpy(sig)\n    if sig_arr.size == 0:\n        return np.array([], dtype=float)\n\n    alg = (algorithm_type or \"\").lower()\n    if alg in (\"basic\", \"ma\"):\n        result = _ma(sig_arr, w)\n    elif alg == \"weighted\":\n        result = _gaussian(sig_arr, w)\n    elif alg == \"ema\":\n        result = _ema(sig_arr, w)\n    elif alg == \"median\":\n        result = _median(sig_arr, w)\n    else:\n        # Use chunked processing for very large inputs to keep memory bounded\n        if sig_arr.size > 5000:\n            result = _chunked_process(sig_arr, w)\n        else:\n            result = _best_filter(sig_arr, w)\n\n    if kwargs.get(\"debug\"):\n        import time\n\n        start = time.time()\n        # No extra work; just record the time taken to reach here\n        elapsed = time.time() - start\n        try:\n            result.debug_info = {\"elapsed\": elapsed}\n        except Exception:\n            pass\n\n    return result\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "55a2e091-2f4b-4169-b630-87d9f5b5d577", "generation": 14, "timestamp": 1764941685.754642, "iteration_found": 0, "metrics": {"runs_successfully": 1.0, "composite_score": 0.4205150578718804, "output_length": 91.0, "overall_score": 0.38035985150742135, "slope_changes": 68.0, "lag_error": 0.9780360456577568, "avg_error": 1.2635358917076887, "false_reversals": 57.8, "correlation": 0.3334964145206185, "noise_reduction": 0.0, "smoothness_score": 0.22727272727272727, "responsiveness_score": 0.5055519600844633, "accuracy_score": 0.3334964145206185, "efficiency_score": 1.0, "execution_time": 0.001226520538330078, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.4205150578718804, "output_length": 91.0, "overall_score": 0.38035985150742135, "slope_changes": 68.0, "lag_error": 0.9780360456577568, "avg_error": 1.2635358917076887, "false_reversals": 57.8, "correlation": 0.3334964145206185, "noise_reduction": 0.0, "smoothness_score": 0.22727272727272727, "responsiveness_score": 0.5055519600844633, "accuracy_score": 0.3334964145206185, "efficiency_score": 1.0, "execution_time": 0.000979137420654297, "success_rate": 1.0}, "island": 3, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}