{"id": "7a10d871-4709-415c-863f-af8e039c4754", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _arr(x):\n    a = np.asarray(x, float).ravel()\n    if a.ndim != 1:\n        raise ValueError(\"Input must be 1\u2011D\")\n    return a\n\ndef _alg(x, w, kind):\n    if x.size < w:\n        return np.empty(0, float)\n    if kind == \"basic\":\n        return np.convolve(x, np.ones(w) / w, \"valid\")\n    if kind == \"weighted\":\n        wt = np.exp(np.linspace(-2, 0, w))\n        wt /= wt.sum()\n        return np.convolve(x, wt, \"valid\")\n    if kind == \"ema\":\n        a = 2.0 / (w + 1)\n        out = np.empty_like(x)\n        out[0] = x[0]\n        for i in range(1, len(x)):\n            out[i] = a * x[i] + (1 - a) * out[i - 1]\n        return out[w - 1 :]\n    if kind == \"enhanced\":\n        trend = _alg(x, w, \"basic\")\n        if trend.size == 0:\n            return np.empty(0, float)\n        full = np.concatenate((np.full(w - 1, trend[0]), trend))\n        return _alg(x - full, w, \"weighted\")\n    raise ValueError(\"Unknown kind\")\n\ndef process_signal(sig, w: int = 20, alg: str = \"enhanced\"):\n    x = _arr(sig)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    key = alg.lower()\n    if key in (\"basic\", \"adaptive\"):\n        return _alg(x, w, \"basic\")\n    if key == \"weighted\":\n        return _alg(x, w, \"weighted\")\n    if key == \"ema\":\n        return _alg(x, w, \"ema\")\n    if key == \"enhanced\":\n        return _alg(x, w, \"enhanced\")\n    # automatic selection\n    best = None\n    best_var = float(\"inf\")\n    for name in (\"enhanced\", \"weighted\", \"basic\", \"ema\"):\n        res = _alg(x, w, name)\n        if res.size == 0:\n            continue\n        var = np.var(x[: len(res)] - res)\n        if var < best_var:\n            best_var = var\n            best = res\n    return best if best is not None else np.empty(0, float)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "1cd0e12e-6d75-4983-a637-148571a61622", "generation": 5, "timestamp": 1764939534.664345, "iteration_found": 388, "metrics": {"runs_successfully": 1.0, "composite_score": 0.4429433309255678, "output_length": 91.0, "overall_score": 0.3624766970140094, "slope_changes": 68.6, "lag_error": 0.4099887786960041, "avg_error": 1.1150775516528053, "false_reversals": 56.6, "correlation": 0.20076318890739916, "noise_reduction": 0.0, "smoothness_score": 0.22573363431151244, "responsiveness_score": 0.709225502436145, "accuracy_score": 0.20076318890739916, "efficiency_score": 1.0, "execution_time": 0.0004841804504394531, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.4429433309255678, "output_length": 91.0, "overall_score": 0.3624766970140094, "slope_changes": 68.6, "lag_error": 0.4099887786960041, "avg_error": 1.1150775516528053, "false_reversals": 56.6, "correlation": 0.20076318890739916, "noise_reduction": 0.0, "smoothness_score": 0.22573363431151244, "responsiveness_score": 0.709225502436145, "accuracy_score": 0.20076318890739916, "efficiency_score": 1.0, "execution_time": 0.000341033935546875, "success_rate": 1.0}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)\n## OUTPUT FORMAT (CRITICAL)\n- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers\n- Do NOT include the markers themselves in your output\n- Do NOT include any code outside the markers (imports, run_packing, etc.)\n- The system will automatically merge your output with the preserved code sections\n\n## FOCUS\n- Improve ONLY the `construct_packing()` function and helper functions within the evolve block\n- Functions like `run_packing()` are preserved automatically - do not include them\n\nViolating these requirements will cause the program to fail evaluation.\n\n---\n\nYou are a meta\u2011prompt engineer tasked with guiding the LLM to evolve **only** the `construct_packing()` function (and any helper functions defined inside the evolve block).  \n\n### Core Rules (must be obeyed for every generation)\n\n1. **Output ONLY the code that belongs between the markers** `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  \n2. **Do NOT include the markers themselves** in your response.  \n3. **Do NOT output any code outside those markers** \u2013 no imports, no `run_packing()`, no global variables, no comments that lie outside the block.  \n4. **Do NOT modify any other part of the file** (functions, classes, constants) that are outside the evolve block.  \n5. **Do NOT produce empty or placeholder implementations** \u2013 the function must remain runnable and return a value of the same type as before.  \n\n### What to avoid (explicitly forbidden)\n\n- **Aggressive rewrites that remove existing logic** or change the public signature of `construct_packing()`.  \n- **Introducing new imports or external dependencies** inside the evolve block.  \n- **Leaving the block empty or containing only `pass`.**  \n- **Repeating the same failed pattern** that caused the previous 13/13 invalid programs (e.g., deleting the function body, adding syntax errors, or violating the output format).  \n\n### Suggested concrete strategies\n\n- **Incremental refactor:** Keep the current algorithmic flow, but improve readability: rename ambiguous variables, add short inline comments, and factor repetitive code into tiny private helpers *still inside the block*.  \n- **Edge\u2011case handling:** Add explicit checks for empty inputs, `None` values, or out\u2011of\u2011range indices, returning a sensible default that matches the original return type.  \n- **Performance tweak:** If the original uses a na\u00efve nested loop, consider replacing it with a single\u2011pass dictionary lookup or using `itertools` constructs that do not require new imports.  \n- **Maintain type consistency:** Preserve the original return type (e.g., a list of `PackingItem` objects). If you introduce a new helper, annotate its parameters and return type clearly.  \n- **Preserve side\u2011effects:** If the original function mutates a passed\u2011in container, ensure the new code does the same or explicitly returns a new container while documenting the change.  \n\n### Formatting reminder (must be reiterated)\n\n- **Your response must consist solely of the Python code that belongs inside the evolve block.**  \n- **Do not prepend or append any text, explanations, or markers.**  \n\nFollow these guidelines precisely to produce a valid, runnable modification of `construct_packing()` that improves the implementation without breaking the surrounding system.", "user": "# Current Program Information\n- Fitness: 13.9292\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 13.9292 \u2192 13.9292. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4429, output_length: 91.0000, overall_score: 0.3625, slope_changes: 68.6000, lag_error: 0.4100, avg_error: 1.1151, false_reversals: 56.6000, correlation: 0.2008, noise_reduction: 0.0000, smoothness_score: 0.2257, responsiveness_score: 0.7092, accuracy_score: 0.2008, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4429, output_length: 91.0000, overall_score: 0.3625, slope_changes: 68.6000, lag_error: 0.4100, avg_error: 1.1151, false_reversals: 56.6000, correlation: 0.2008, noise_reduction: 0.0000, smoothness_score: 0.2257, responsiveness_score: 0.7092, accuracy_score: 0.2008, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4429, output_length: 91.0000, overall_score: 0.3625, slope_changes: 68.6000, lag_error: 0.4100, avg_error: 1.1151, false_reversals: 56.6000, correlation: 0.2008, noise_reduction: 0.0000, smoothness_score: 0.2257, responsiveness_score: 0.7092, accuracy_score: 0.2008, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"\n    Simple moving average filter using convolution.\n    Returns the filtered signal with length len(x) - window_size + 1.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        # Not enough data \u2013 return empty array for consistency\n        return np.array([], dtype=float)\n    return np.convolve(x, np.ones(window_size) / window_size, mode=\"valid\")\n\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"\n    Exponential weighted moving average.\n    Emphasises recent samples while preserving overall trend.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    weights = np.exp(np.linspace(-2, 0, window_size))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema_filter(x, window_size=20):\n    \"\"\"\n    Classic exponential moving average (EMA).\n    Output length matches other filters (len(x) - window_size + 1).\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    alpha = 2.0 / (window_size + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[window_size - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"\n    Detrends the signal using a simple moving average, then applies\n    a weighted moving average to the detrended series.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if x.size < window_size:\n        return np.array([], dtype=float)\n    # Estimate local trend\n    trend = adaptive_filter(x, window_size)\n    # Pad trend to original length (repeat edge values)\n    trend_full = np.concatenate((np.full(window_size - 1, trend[0]), trend))\n    detrended = x - trend_full\n    return weighted_filter(detrended, window_size)\n\n\ndef _residual_variance(original: np.ndarray, filtered: np.ndarray) -> float:\n    \"\"\"\n    Compute variance of the residual (original - filtered).\n    Signals are aligned to the shortest length.\n    \"\"\"\n    min_len = min(len(original), len(filtered))\n    if min_len == 0:\n        return np.inf\n    residual = original[:min_len] - filtered[:min_len]\n    return float(np.var(residual))\n\n\ndef _select_best_filter(x: np.ndarray, window_size: int) -> np.ndarray:\n    \"\"\"\n    Evaluate all available filters and return the one that yields the lowest\n    residual variance (i.e., highest estimated noise reduction).\n    \"\"\"\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n    }\n    # Choose filter with minimal residual variance relative to the raw signal\n    best_name = min(candidates, key=lambda k: _residual_variance(x, candidates[k]))\n    return candidates[best_name]\n\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatches to the requested filtering algorithm.\n    Supported types:\n        - \"basic\": simple moving average (adaptive_filter)\n        - \"weighted\": exponential weighted moving average (weighted_filter)\n        - \"ema\": classic exponential moving average (ema_filter)\n        - \"enhanced\": detrended weighted filter (enhanced_filter_with_trend_preservation)\n        - any other value: automatic selection of the best filter based on residual variance.\n    \"\"\"\n    if algorithm_type == \"basic\":\n        return adaptive_filter(input_signal, window_size)\n    if algorithm_type == \"weighted\":\n        return weighted_filter(input_signal, window_size)\n    if algorithm_type == \"ema\":\n        return ema_filter(input_signal, window_size)\n    if algorithm_type == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(input_signal, window_size)\n\n    # Fallback: automatic selection\n    return _select_best_filter(np.asarray(input_signal, dtype=float), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4429), Performs well on output_length (91.0000), Performs well on overall_score (0.3625), Performs well on slope_changes (68.6000), Performs well on lag_error (0.4100), Performs well on avg_error (1.1151), Performs well on false_reversals (56.6000), Performs well on correlation (0.2008), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2257), Performs well on responsiveness_score (0.7092), Performs well on accuracy_score (0.2008), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef adaptive(x, w=20):\n    \"\"\"Simple moving average filter.\"\"\"\n    x = np.asarray(x, dtype=float)\n    if w <= 0 or x.size < w:\n        return np.empty(0, dtype=float)\n    return np.convolve(x, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted(x, w=20):\n    \"\"\"Exponential weighted moving average filter.\"\"\"\n    x = np.asarray(x, dtype=float)\n    if w <= 0 or x.size < w:\n        return np.empty(0, dtype=float)\n    weights = np.exp(np.linspace(-2, 0, w))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema(x, w=20):\n    \"\"\"Classic exponential moving average (EMA).\"\"\"\n    x = np.asarray(x, dtype=float)\n    if w <= 0 or x.size < w:\n        return np.empty(0, dtype=float)\n    alpha = 2.0 / (w + 1)\n    e = np.empty_like(x)\n    e[0] = x[0]\n    for i in range(1, len(x)):\n        e[i] = alpha * x[i] + (1 - alpha) * e[i - 1]\n    return e[w - 1 :]\n\n\ndef enhanced(x, w=20):\n    \"\"\"Detrend with simple moving average, then apply weighted filter.\"\"\"\n    trend = adaptive(x, w)\n    if trend.size == 0:\n        return np.empty(0, dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    return weighted(x - trend_full, w)\n\n\ndef _residual_variance(original, filtered):\n    \"\"\"Variance of the residual (original - filtered) over the overlapping region.\"\"\"\n    n = min(len(original), len(filtered))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(original[:n] - filtered[:n]))\n\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    \"\"\"\n    Dispatch to the requested filtering algorithm.\n    Supported types (case\u2011insensitive):\n        - \"basic\" / \"adaptive\"\n        - \"weighted\"\n        - \"ema\"\n        - \"enhanced\"\n        - \"auto\" (or any unknown value) \u2192 automatic selection based on residual variance.\n    \"\"\"\n    alg = alg.lower()\n    if alg in (\"basic\", \"adaptive\"):\n        return adaptive(sig, w)\n    if alg == \"weighted\":\n        return weighted(sig, w)\n    if alg == \"ema\":\n        return ema(sig, w)\n    if alg == \"enhanced\":\n        return enhanced(sig, w)\n\n    # Automatic selection (fallback)\n    candidates = {\n        \"basic\": adaptive(sig, w),\n        \"weighted\": weighted(sig, w),\n        \"ema\": ema(sig, w),\n        \"enhanced\": enhanced(sig, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, dtype=float)\n    best_key = min(candidates, key=lambda k: _residual_variance(sig, candidates[k]))\n    return candidates[best_key]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4429), Performs well on output_length (91.0000), Performs well on overall_score (0.3625), Performs well on slope_changes (68.6000), Performs well on lag_error (0.4100), Performs well on avg_error (1.1151), Performs well on false_reversals (56.6000), Performs well on correlation (0.2008), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2257), Performs well on responsiveness_score (0.7092), Performs well on accuracy_score (0.2008), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"\n    Simple moving average filter using convolution.\n    Returns the filtered signal with length len(x) - window_size + 1.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if len(x) < window_size:\n        raise ValueError(\"signal shorter than window\")\n    return np.convolve(x, np.ones(window_size) / window_size, mode=\"valid\")\n\n\ndef weighted_filter(x, window_size=20):\n    \"\"\"\n    Exponential weighted moving average.\n    Emphasises recent samples while preserving overall trend.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if len(x) < window_size:\n        raise ValueError(\"signal shorter than window\")\n    weights = np.exp(np.linspace(-2, 0, window_size))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema_filter(x, window_size=20):\n    \"\"\"\n    Classic exponential moving average (EMA).\n    Output length matches other filters (len(x) - window_size + 1).\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if len(x) < window_size:\n        raise ValueError(\"signal shorter than window\")\n    alpha = 2.0 / (window_size + 1)\n    ema = np.empty_like(x)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema[window_size - 1 :]\n\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"\n    Detrends the signal using a simple moving average, then applies\n    an exponential weighted filter to the detrended series.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    if len(x) < window_size:\n        raise ValueError(\"signal shorter than window\")\n    # Estimate local trend\n    trend = adaptive_filter(x, window_size)\n    # Pad trend to original length (repeat edge values)\n    trend_full = np.concatenate(\n        (np.full(window_size - 1, trend[0]), trend)\n    )\n    detrended = x - trend_full\n    # Apply weighted smoothing\n    return weighted_filter(detrended, window_size)\n\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Dispatches to the requested filtering algorithm.\n    Types:\n        - \"basic\": simple moving average\n        - \"ema\": exponential moving average\n        - \"enhanced\": detrended weighted filter\n    \"\"\"\n    if algorithm_type == \"basic\":\n        return adaptive_filter(input_signal, window_size)\n    if algorithm_type == \"ema\":\n        return ema_filter(input_signal, window_size)\n    return enhanced_filter_with_trend_preservation(input_signal, window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4429), Performs well on output_length (91.0000), Performs well on overall_score (0.3625), Performs well on slope_changes (68.6000), Performs well on lag_error (0.4100), Performs well on avg_error (1.1151), Performs well on false_reversals (56.6000), Performs well on correlation (0.2008), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.2257), Performs well on responsiveness_score (0.7092), Performs well on accuracy_score (0.2008), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef simple_ma(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    return np.convolve(x, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted_ma(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    weights = np.exp(np.linspace(-2, 0, w))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef ema(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    a = 2.0 / (w + 1)\n    out = np.empty_like(x)\n    out[0] = x[0]\n    for i in range(1, len(x)):\n        out[i] = a * x[i] + (1 - a) * out[i - 1]\n    return out[w - 1 :]\n\n\ndef detrended_weighted(x, w):\n    x = np.asarray(x, float)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    if x.size < w:\n        return np.empty(0, float)\n    trend = simple_ma(x, w)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    detrended = x - trend_full\n    return weighted_ma(detrended, w)\n\n\ndef process_signal(sig, w=20, algo=\"enhanced\"):\n    \"\"\"\n    Apply the selected filtering algorithm.\n    Supported algo values (case\u2011sensitive):\n        \"basic\", \"weighted\", \"ema\", \"enhanced\"\n    Any other value defaults to the enhanced (detrended weighted) filter.\n    \"\"\"\n    if algo == \"basic\":\n        return simple_ma(sig, w)\n    if algo == \"weighted\":\n        return weighted_ma(sig, w)\n    if algo == \"ema\":\n        return ema(sig, w)\n    if algo == \"enhanced\":\n        return detrended_weighted(sig, w)\n    return detrended_weighted(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 13.9292)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _validate_signal(x):\n    try:\n        a = np.asarray(x, float).ravel()\n    except Exception:\n        return np.empty(0, float)\n    return a\n\ndef _ma(x, w, wt):\n    a = _validate_signal(x)\n    if w <= 0:\n        raise ValueError(\"window must be positive\")\n    if a.size < w:\n        return np.empty(0, float)\n    return np.convolve(a, wt, mode=\"valid\")\n\ndef adaptive_filter(x, window_size=20):\n    return _ma(x, window_size, np.ones(window_size) / window_size)\n\ndef weighted_filter(x, window_size=20):\n    wt = np.exp(np.linspace(-2, 0, window_size))\n    wt /= wt.sum()\n    return _ma(x, window_size, wt)\n\ndef ema_filter(x, window_size=20):\n    a = _validate_signal(x)\n    if window_size <= 0:\n        raise ValueError(\"window_size must be positive\")\n    if a.size < window_size:\n        return np.empty(0, float)\n    alpha = 2.0 / (window_size + 1)\n    ema = np.empty_like(a)\n    ema[0] = a[0]\n    for i in range(1, a.size):\n        ema[i] = alpha * a[i] + (1 - alpha) * ema[i - 1]\n    return ema[window_size - 1 :]\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    trend = adaptive_filter(x, window_size)\n    if trend.size == 0:\n        return np.empty(0, float)\n    trend_full = np.concatenate((np.full(window_size - 1, trend[0]), trend))\n    detrended = _validate_signal(x) - trend_full\n    return weighted_filter(detrended, window_size)\n\ndef double_enhanced(x, window_size=20):\n    first = enhanced_filter_with_trend_preservation(x, window_size)\n    if first.size == 0:\n        return np.empty(0, float)\n    w2 = max(1, window_size // 2)\n    return adaptive_filter(first, w2)\n\ndef gaussian_filter(x, window_size=20):\n    if window_size <= 0:\n        raise ValueError(\"window must be positive\")\n    sigma = max(window_size / 6.0, 0.1)\n    centre = (window_size - 1) / 2.0\n    i = np.arange(window_size, dtype=float)\n    wt = np.exp(-0.5 * ((i - centre) / sigma) ** 2)\n    wt /= wt.sum()\n    return _ma(x, window_size, wt)\n\ndef median_filter(x, window_size=20):\n    a = _validate_signal(x)\n    if window_size <= 0:\n        raise ValueError(\"window must be positive\")\n    if a.size < window_size:\n        return np.empty(0, float)\n    out_len = a.size - window_size + 1\n    out = np.empty(out_len, float)\n    for i in range(out_len):\n        out[i] = np.median(a[i:i + window_size])\n    return out\n\ndef advanced_filter(x, window_size=20):\n    first = enhanced_filter_with_trend_preservation(x, window_size)\n    if first.size == 0:\n        return np.empty(0, float)\n    medianed = median_filter(first, window_size)\n    if medianed.size == 0:\n        return np.empty(0, float)\n    w2 = max(1, window_size // 2)\n    return adaptive_filter(medianed, w2)\n\ndef _residual_variance(orig, filt):\n    m = min(len(orig), len(filt))\n    if m == 0:\n        return np.inf\n    return float(np.var(orig[:m] - filt[:m]))\n\ndef _select_best_filter(x, window_size):\n    candidates = {\n        \"basic\": adaptive_filter(x, window_size),\n        \"weighted\": weighted_filter(x, window_size),\n        \"ema\": ema_filter(x, window_size),\n        \"enhanced\": enhanced_filter_with_trend_preservation(x, window_size),\n        \"double\": double_enhanced(x, window_size),\n        \"gaussian\": gaussian_filter(x, window_size),\n        \"median\": median_filter(x, window_size),\n        \"advanced\": advanced_filter(x, window_size),\n    }\n    best_var = min(_residual_variance(x, v) for v in candidates.values())\n    best_keys = [k for k, v in candidates.items() if _residual_variance(x, v) == best_var]\n    # tie\u2011break by longest output\n    best_key = max(best_keys, key=lambda k: len(candidates[k]))\n    return candidates[best_key]\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    dispatch = {\n        \"basic\": adaptive_filter,\n        \"weighted\": weighted_filter,\n        \"ema\": ema_filter,\n        \"enhanced\": enhanced_filter_with_trend_preservation,\n        \"double\": double_enhanced,\n        \"gaussian\": gaussian_filter,\n        \"median\": median_filter,\n        \"advanced\": advanced_filter,\n    }\n    alg = algorithm_type.lower()\n    if alg in dispatch:\n        return dispatch[alg](input_signal, window_size)\n    return _select_best_filter(_validate_signal(input_signal), window_size)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\ndef _to_array(x):\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    return np.asarray(x, dtype=float).ravel()\n\n\ndef _check_window(arr, w):\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window size must be a positive integer\")\n    return arr.size >= w\n\n\ndef _ma(arr, w, kernel):\n    \"\"\"Convolution\u2011based moving average using the supplied kernel.\"\"\"\n    if not _check_window(arr, w):\n        return np.empty(0, float)\n    return np.convolve(arr, kernel, mode=\"valid\")\n\n\ndef simple(arr, w):\n    \"\"\"Uniform moving average.\"\"\"\n    arr = _to_array(arr)\n    return _ma(arr, w, np.ones(w) / w)\n\n\ndef weighted(arr, w):\n    \"\"\"Exponentially weighted moving average.\"\"\"\n    arr = _to_array(arr)\n    wt = np.exp(np.linspace(-2, 0, w))\n    wt /= wt.sum()\n    return _ma(arr, w, wt)\n\n\ndef ema(arr, w):\n    \"\"\"Classic exponential moving average (recursive).\"\"\"\n    arr = _to_array(arr)\n    if not _check_window(arr, w):\n        return np.empty(0, float)\n    alpha = 2.0 / (w + 1)\n    out = np.empty_like(arr)\n    out[0] = arr[0]\n    for i in range(1, len(arr)):\n        out[i] = alpha * arr[i] + (1 - alpha) * out[i - 1]\n    return out[w - 1 :]\n\n\ndef detrended(arr, w):\n    \"\"\"Detrend with a simple moving average then apply weighted smoothing.\"\"\"\n    arr = _to_array(arr)\n    trend = simple(arr, w)\n    if trend.size == 0:\n        return np.empty(0, float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    return weighted(arr - trend_full, w)\n\n\ndef gaussian(arr, w):\n    \"\"\"Gaussian weighted moving average.\"\"\"\n    arr = _to_array(arr)\n    if not _check_window(arr, w):\n        return np.empty(0, float)\n    sigma = max(w / 6.0, 0.1)\n    centre = (w - 1) / 2.0\n    i = np.arange(w, dtype=float)\n    kernel = np.exp(-0.5 * ((i - centre) / sigma) ** 2)\n    kernel /= kernel.sum()\n    return _ma(arr, w, kernel)\n\n\ndef median(arr, w):\n    \"\"\"Median filter (non\u2011linear smoothing).\"\"\"\n    arr = _to_array(arr)\n    if not _check_window(arr, w):\n        return np.empty(0, float)\n    # Create a view of sliding windows without copying\n    shape = (arr.size - w + 1, w)\n    strides = (arr.strides[0], arr.strides[0])\n    windows = np.lib.stride_tricks.as_strided(arr, shape=shape, strides=strides)\n    return np.median(windows, axis=1)\n\n\ndef double_enhanced(arr, w):\n    \"\"\"\n    Apply detrended filter, then a simple moving average with a reduced window.\n    This often yields a smoother result for noisy signals.\n    \"\"\"\n    first = detrended(arr, w)\n    if first.size == 0:\n        return np.empty(0, float)\n    reduced_w = max(1, w // 2)\n    return simple(first, reduced_w)\n\n\ndef _residual_variance(orig, filt):\n    n = min(len(orig), len(filt))\n    return np.inf if n == 0 else float(np.var(orig[:n] - filt[:n]))\n\n\ndef _best_filter(arr, w):\n    \"\"\"Select the filter with the lowest residual variance (deterministic tie\u2011break).\"\"\"\n    candidates = {\n        \"basic\": simple(arr, w),\n        \"weighted\": weighted(arr, w),\n        \"ema\": ema(arr, w),\n        \"enhanced\": detrended(arr, w),\n        \"gaussian\": gaussian(arr, w),\n        \"median\": median(arr, w),\n        \"double\": double_enhanced(arr, w),\n    }\n    # Discard empty results\n    candidates = {k: v for k, v in candidates.items() if v.size}\n    if not candidates:\n        return np.empty(0, float)\n\n    # Compute residual variances\n    variances = {k: _residual_variance(arr, v) for k, v in candidates.items()}\n    min_var = min(variances.values())\n    best_keys = [k for k, v in variances.items() if v == min_var]\n\n    # Tie\u2011break: prefer longer output, then alphabetical order\n    best_key = max(\n        best_keys,\n        key=lambda k: (len(candidates[k]), k)\n    )\n    return candidates[best_key]\n\n\ndef process_signal(sig, w=20, algo=\"enhanced\"):\n    \"\"\"\n    Dispatch to a filtering algorithm.\n    ``algo`` is case\u2011insensitive; unknown values trigger automatic selection.\n    Supported algorithms:\n        basic, weighted, ema, enhanced, gaussian, median, double\n    \"\"\"\n    algo = str(algo).lower()\n    dispatch = {\n        \"basic\": simple,\n        \"weighted\": weighted,\n        \"ema\": ema,\n        \"enhanced\": detrended,\n        \"gaussian\": gaussian,\n        \"median\": median,\n        \"double\": double_enhanced,\n    }\n    if algo in dispatch:\n        return dispatch[algo](sig, w)\n    return _best_filter(_to_array(sig), w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Alternative runs_successfully approach, NumPy-based implementation\n\n### Inspiration 2 (Score: 13.9292, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom typing import Callable, Dict, List\n\n\ndef _to_numpy(x) -> np.ndarray:\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    arr = np.asarray(x, dtype=float).ravel()\n    if arr.ndim != 1:\n        raise ValueError(\"Input must be convertible to a 1\u2011D sequence\")\n    return arr\n\n\ndef _validate_window(w: int) -> None:\n    \"\"\"Validate that the window size is a positive integer.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window size must be a positive integer\")\n\n\ndef _adaptive(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Simple moving average (uniform weights).\"\"\"\n    if x.size < w:\n        return np.empty(0, dtype=float)\n    return np.convolve(x, np.ones(w) / w, mode=\"valid\")\n\n\ndef _weighted(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Exponentially weighted moving average.\"\"\"\n    if x.size < w:\n        return np.empty(0, dtype=float)\n    weights = np.exp(np.linspace(-2, 0, w))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef _ema(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Classic exponential moving average (recursive formulation).\"\"\"\n    if x.size < w:\n        return np.empty(0, dtype=float)\n    alpha = 2.0 / (w + 1)\n    out = np.empty_like(x)\n    out[0] = x[0]\n    for i in range(1, len(x)):\n        out[i] = alpha * x[i] + (1 - alpha) * out[i - 1]\n    return out[w - 1 :]\n\n\ndef _enhanced(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Detrend with a simple moving average then apply a weighted filter.\"\"\"\n    trend = _adaptive(x, w)\n    if trend.size == 0:\n        return np.empty(0, dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    return _weighted(x - trend_full, w)\n\n\ndef _hybrid(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Combine weighted and EMA filters by averaging their outputs.\"\"\"\n    if x.size < w:\n        return np.empty(0, dtype=float)\n    wgt = _weighted(x, w)\n    ema = _ema(x, w)\n    # Align lengths (both should be len(x)-w+1, but guard against any mismatch)\n    min_len = min(wgt.size, ema.size)\n    if min_len == 0:\n        return np.empty(0, dtype=float)\n    return (wgt[:min_len] + ema[:min_len]) / 2.0\n\n\ndef _residual_variance(orig: np.ndarray, filt: np.ndarray) -> float:\n    \"\"\"Mean\u2011squared residual between two aligned signals.\"\"\"\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(orig[:n] - filt[:n]))\n\n\n# Mapping from canonical algorithm names to their implementations\n_ALGOS: Dict[str, Callable[[np.ndarray, int], np.ndarray]] = {\n    \"basic\": _adaptive,\n    \"adaptive\": _adaptive,\n    \"weighted\": _weighted,\n    \"ema\": _ema,\n    \"enhanced\": _enhanced,\n    \"hybrid\": _hybrid,\n}\n\n# Deterministic priority order for tie\u2011breaking in auto\u2011selection\n_PRIORITY: List[str] = [\"hybrid\", \"enhanced\", \"weighted\", \"basic\", \"ema\"]\n\n\ndef process_signal(sig, w: int = 20, alg: str = \"enhanced\") -> np.ndarray:\n    \"\"\"\n    Apply a filtering algorithm to ``sig``.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    w : int, optional\n        Window size (must be positive). Default is 20.\n    alg : str, optional\n        Algorithm name (case\u2011insensitive). Supported names are\n        ``basic``/``adaptive``, ``weighted``, ``ema``, ``enhanced``,\n        ``hybrid``. Any other value triggers automatic selection of the best\n        filter based on residual variance.\n\n    Returns\n    -------\n    np.ndarray\n        Filtered signal (may be empty if the input is shorter than ``w``).\n    \"\"\"\n    _validate_window(w)\n    x = _to_numpy(sig)\n    key = alg.lower()\n\n    # Direct dispatch if a known algorithm is requested\n    if key in _ALGOS:\n        return _ALGOS[key](x, w)\n\n    # ----- Automatic selection (fallback) -----\n    # Compute each candidate, discarding empty results\n    candidates: Dict[str, np.ndarray] = {\n        name: func(x, w) for name, func in _ALGOS.items() if func(x, w).size\n    }\n\n    if not candidates:\n        return np.empty(0, dtype=float)\n\n    # Determine minimal residual variance\n    best_score = min(_residual_variance(x, f) for f in candidates.values())\n\n    # Gather all algorithms achieving the best score\n    best_keys = [k for k, f in candidates.items() if _residual_variance(x, f) == best_score]\n\n    # Apply deterministic tie\u2011break using the predefined priority list\n    for pref in _PRIORITY:\n        if pref in best_keys:\n            return candidates[pref]\n\n    # Fallback (should never reach here)\n    return candidates[best_keys[0]]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 3 (Score: 13.4402, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef adaptive(x, w=20):\n    x = np.asarray(x, float)\n    if w <= 0 or x.size < w:\n        return np.empty(0, float)\n    return np.convolve(x, np.ones(w) / w, mode=\"valid\")\n\n\ndef weighted(x, w=20):\n    x = np.asarray(x, float)\n    if w <= 0 or x.size < w:\n        return np.empty(0, float)\n    wt = np.exp(np.linspace(-2, 0, w))\n    wt /= wt.sum()\n    return np.convolve(x, wt, mode=\"valid\")\n\n\ndef ema(x, w=20):\n    x = np.asarray(x, float)\n    if w <= 0 or x.size < w:\n        return np.empty(0, float)\n    a = 2.0 / (w + 1)\n    out = np.empty_like(x)\n    out[0] = x[0]\n    for i in range(1, len(x)):\n        out[i] = a * x[i] + (1 - a) * out[i - 1]\n    return out[w - 1 :]\n\n\ndef enhanced(x, w=20):\n    tr = adaptive(x, w)\n    if tr.size == 0:\n        return np.empty(0, float)\n    tr_full = np.concatenate((np.full(w - 1, tr[0]), tr))\n    return weighted(x - tr_full, w)\n\n\ndef double_enhanced(x, w=20):\n    first = enhanced(x, w)\n    if first.size == 0:\n        return np.empty(0, float)\n    half = max(1, w // 2)\n    return adaptive(first, half)\n\n\ndef _residual_variance(orig, filt):\n    n = min(len(orig), len(filt))\n    return float(\"inf\") if n == 0 else float(np.var(orig[:n] - filt[:n]))\n\n\ndef _best_filter(sig, w):\n    cand = {\n        \"adaptive\": adaptive(sig, w),\n        \"weighted\": weighted(sig, w),\n        \"ema\": ema(sig, w),\n        \"enhanced\": enhanced(sig, w),\n        \"double\": double_enhanced(sig, w),\n    }\n    cand = {k: v for k, v in cand.items() if v.size}\n    if not cand:\n        return np.empty(0, float)\n    best = min(cand, key=lambda k: _residual_variance(sig, cand[k]))\n    return cand[best]\n\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    alg = alg.lower()\n    if alg in (\"basic\", \"adaptive\"):\n        return adaptive(sig, w)\n    if alg == \"weighted\":\n        return weighted(sig, w)\n    if alg == \"ema\":\n        return ema(sig, w)\n    if alg == \"enhanced\":\n        return _best_filter(sig, w)\n\n    # fallback \u2013 automatic selection\n    return _best_filter(sig, w)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom typing import Callable, Dict, List\n\n\ndef _to_numpy(x) -> np.ndarray:\n    \"\"\"Convert input to a 1\u2011D float NumPy array.\"\"\"\n    arr = np.asarray(x, dtype=float).ravel()\n    if arr.ndim != 1:\n        raise ValueError(\"Input must be convertible to a 1\u2011D sequence\")\n    return arr\n\n\ndef _validate_window(w: int) -> None:\n    \"\"\"Validate that the window size is a positive integer.\"\"\"\n    if not isinstance(w, int) or w <= 0:\n        raise ValueError(\"window size must be a positive integer\")\n\n\ndef _adaptive(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Simple moving average (uniform weights).\"\"\"\n    if x.size < w:\n        return np.empty(0, dtype=float)\n    return np.convolve(x, np.ones(w) / w, mode=\"valid\")\n\n\ndef _weighted(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Exponentially weighted moving average.\"\"\"\n    if x.size < w:\n        return np.empty(0, dtype=float)\n    weights = np.exp(np.linspace(-2, 0, w))\n    weights /= weights.sum()\n    return np.convolve(x, weights, mode=\"valid\")\n\n\ndef _ema(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Classic exponential moving average (recursive formulation).\"\"\"\n    if x.size < w:\n        return np.empty(0, dtype=float)\n    alpha = 2.0 / (w + 1)\n    out = np.empty_like(x)\n    out[0] = x[0]\n    for i in range(1, len(x)):\n        out[i] = alpha * x[i] + (1 - alpha) * out[i - 1]\n    return out[w - 1 :]\n\n\ndef _enhanced(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Detrend with a simple moving average then apply a weighted filter.\"\"\"\n    trend = _adaptive(x, w)\n    if trend.size == 0:\n        return np.empty(0, dtype=float)\n    trend_full = np.concatenate((np.full(w - 1, trend[0]), trend))\n    return _weighted(x - trend_full, w)\n\n\ndef _residual_variance(orig: np.ndarray, filt: np.ndarray) -> float:\n    \"\"\"Mean\u2011squared residual between two aligned signals.\"\"\"\n    n = min(len(orig), len(filt))\n    if n == 0:\n        return float(\"inf\")\n    return float(np.var(orig[:n] - filt[:n]))\n\n\n# Mapping from canonical algorithm names to their implementations\n_ALGOS: Dict[str, Callable[[np.ndarray, int], np.ndarray]] = {\n    \"basic\": _adaptive,\n    \"adaptive\": _adaptive,\n    \"weighted\": _weighted,\n    \"ema\": _ema,\n    \"enhanced\": _enhanced,\n}\n\n# Deterministic priority order for tie\u2011breaking in auto\u2011selection\n_PRIORITY: List[str] = [\"enhanced\", \"weighted\", \"basic\", \"ema\"]\n\n\ndef process_signal(sig, w: int = 20, alg: str = \"enhanced\") -> np.ndarray:\n    \"\"\"\n    Apply a filtering algorithm to ``sig``.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    w : int, optional\n        Window size (must be positive). Default is 20.\n    alg : str, optional\n        Algorithm name (case\u2011insensitive). Supported names are\n        ``basic``/``adaptive``, ``weighted``, ``ema``, ``enhanced``.\n        Any other value triggers automatic selection of the best filter\n        based on residual variance.\n\n    Returns\n    -------\n    np.ndarray\n        Filtered signal (may be empty if the input is shorter than ``w``).\n    \"\"\"\n    _validate_window(w)\n    x = _to_numpy(sig)\n    key = alg.lower()\n\n    # Direct dispatch if a known algorithm is requested\n    if key in _ALGOS:\n        return _ALGOS[key](x, w)\n\n    # ----- Automatic selection (fallback) -----\n    # Compute each candidate, discarding empty results\n    candidates: Dict[str, np.ndarray] = {\n        name: func(x, w) for name, func in _ALGOS.items() if func(x, w).size\n    }\n\n    if not candidates:\n        return np.empty(0, dtype=float)\n\n    # Determine minimal residual variance\n    best_score = min(_residual_variance(x, f) for f in candidates.values())\n\n    # Gather all algorithms achieving the best score\n    best_keys = [k for k, f in candidates.items() if _residual_variance(x, f) == best_score]\n\n    # Apply deterministic tie\u2011break using the predefined priority list\n    for pref in _PRIORITY:\n        if pref in best_keys:\n            return candidates[pref]\n\n    # Fallback (should never reach here)\n    return candidates[best_keys[0]]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["import numpy as np\n\ndef _arr(x):\n    a = np.asarray(x, float).ravel()\n    if a.ndim != 1:\n        raise ValueError(\"Input must be 1\u2011D\")\n    return a\n\ndef _alg(x, w, kind):\n    if x.size < w:\n        return np.empty(0, float)\n    if kind == \"basic\":\n        return np.convolve(x, np.ones(w) / w, \"valid\")\n    if kind == \"weighted\":\n        wt = np.exp(np.linspace(-2, 0, w))\n        wt /= wt.sum()\n        return np.convolve(x, wt, \"valid\")\n    if kind == \"ema\":\n        a = 2.0 / (w + 1)\n        out = np.empty_like(x)\n        out[0] = x[0]\n        for i in range(1, len(x)):\n            out[i] = a * x[i] + (1 - a) * out[i - 1]\n        return out[w - 1 :]\n    if kind == \"enhanced\":\n        trend = _alg(x, w, \"basic\")\n        if trend.size == 0:\n            return np.empty(0, float)\n        full = np.concatenate((np.full(w - 1, trend[0]), trend))\n        return _alg(x - full, w, \"weighted\")\n    raise ValueError(\"Unknown kind\")\n\ndef process_signal(sig, w: int = 20, alg: str = \"enhanced\"):\n    x = _arr(sig)\n    if w <= 0:\n        raise ValueError(\"window size must be positive\")\n    key = alg.lower()\n    if key in (\"basic\", \"adaptive\"):\n        return _alg(x, w, \"basic\")\n    if key == \"weighted\":\n        return _alg(x, w, \"weighted\")\n    if key == \"ema\":\n        return _alg(x, w, \"ema\")\n    if key == \"enhanced\":\n        return _alg(x, w, \"enhanced\")\n    # automatic selection\n    best = None\n    best_var = float(\"inf\")\n    for name in (\"enhanced\", \"weighted\", \"basic\", \"ema\"):\n        res = _alg(x, w, name)\n        if res.size == 0:\n            continue\n        var = np.var(x[: len(res)] - res)\n        if var < best_var:\n            best_var = var\n            best = res\n    return best if best is not None else np.empty(0, float)"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}