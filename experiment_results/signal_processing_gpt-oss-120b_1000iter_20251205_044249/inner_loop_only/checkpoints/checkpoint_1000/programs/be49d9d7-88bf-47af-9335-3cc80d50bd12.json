{"id": "be49d9d7-88bf-47af-9335-3cc80d50bd12", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef _kernel(w, kind):\n    t = np.arange(w) - (w - 1) / 2\n    if kind == \"gaussian\":\n        sigma = w / 6.0\n        k = np.exp(-0.5 * (t / sigma) ** 2)\n    elif kind == \"hann\":\n        k = np.hanning(w)\n    elif kind in (\"exp\", \"exponential\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:  # uniform fallback\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _detrend(x, w):\n    return x - np.convolve(x, np.ones(w) / w, mode=\"same\") if w > 0 and len(x) >= w else x\n\ndef _mad(x):\n    m = np.median(x)\n    return np.median(np.abs(x - m))\n\ndef _auto_kind(x):\n    mad = _mad(x)\n    var = x.var()\n    if mad < 0.02 and var < 0.02:\n        return \"gaussian\"\n    if mad < 0.07:\n        return \"hann\"\n    return \"exponential\"\n\ndef _interp_nan(x):\n    if np.isnan(x).any():\n        i = np.arange(x.size)\n        mask = np.isfinite(x)\n        x = np.interp(i, i[mask], x[mask])\n    return x\n\ndef _median_filter(x, w):\n    p = w // 2\n    a = np.pad(x, (p, p), mode=\"edge\")\n    shape = (len(x), w)\n    strides = (a.strides[0], a.strides[0])\n    windows = np.lib.stride_tricks.as_strided(a, shape, strides)\n    return np.median(windows, axis=1)\n\ndef _valid_slice(y, w):\n    off = w - 1\n    s = off // 2\n    e = -(off - s) if (off - s) != 0 else None\n    return y[s:e]\n\ndef process_signal(sig, win=20, alg=\"enhanced\", full=False):\n    if win <= 0:\n        raise ValueError(\"win must be a positive integer\")\n    x = _interp_nan(np.asarray(sig, float))\n\n    if alg == \"enhanced\":\n        x = _detrend(x, win)\n        kind = _auto_kind(x)\n        y = np.convolve(x, _kernel(win, kind), mode=\"same\")\n    elif alg == \"simple\":\n        y = np.convolve(x, _kernel(win, \"uniform\"), mode=\"same\")\n    elif alg == \"median\":\n        y = _median_filter(x, win)\n        return y if full else y\n    else:\n        y = np.convolve(x, _kernel(win, alg), mode=\"same\")\n\n    return y if full else _valid_slice(y, win)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "45b656f7-3b9a-4fab-8a96-8edfb1deda4e", "generation": 9, "timestamp": 1764936424.4767811, "iteration_found": 973, "metrics": {"runs_successfully": 1.0, "composite_score": 0.41313607247534356, "output_length": 91.0, "overall_score": 0.28813772418464545, "slope_changes": 154.8, "lag_error": 0.35881931759431995, "avg_error": 0.9556927600460691, "false_reversals": 125.6, "correlation": -0.007282066797801695, "noise_reduction": 0.0, "smoothness_score": 0.11441647597254004, "responsiveness_score": 0.7359330170330661, "accuracy_score": 0.0, "efficiency_score": 1.0, "execution_time": 0.0005523681640625, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.41313607247534356, "output_length": 91.0, "overall_score": 0.28813772418464545, "slope_changes": 154.8, "lag_error": 0.35881931759431995, "avg_error": 0.9556927600460691, "false_reversals": 125.6, "correlation": -0.007282066797801695, "noise_reduction": 0.0, "smoothness_score": 0.11441647597254004, "responsiveness_score": 0.7359330170330661, "accuracy_score": 0.0, "efficiency_score": 1.0, "execution_time": 0.0005990505218505859, "success_rate": 1.0}, "island": 4}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 23.5787\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 23.5787 \u2192 23.5787. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4131, output_length: 91.0000, overall_score: 0.2881, slope_changes: 154.8000, lag_error: 0.3588, avg_error: 0.9557, false_reversals: 125.6000, correlation: -0.0073, noise_reduction: 0.0000, smoothness_score: 0.1144, responsiveness_score: 0.7359, accuracy_score: 0.0000, efficiency_score: 1.0000, execution_time: 0.0007, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4131, output_length: 91.0000, overall_score: 0.2881, slope_changes: 154.8000, lag_error: 0.3588, avg_error: 0.9557, false_reversals: 125.6000, correlation: -0.0073, noise_reduction: 0.0000, smoothness_score: 0.1144, responsiveness_score: 0.7359, accuracy_score: 0.0000, efficiency_score: 1.0000, execution_time: 0.0007, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4131, output_length: 91.0000, overall_score: 0.2881, slope_changes: 154.8000, lag_error: 0.3588, avg_error: 0.9557, false_reversals: 125.6000, correlation: -0.0073, noise_reduction: 0.0000, smoothness_score: 0.1144, responsiveness_score: 0.7359, accuracy_score: 0.0000, efficiency_score: 1.0000, execution_time: 0.0008, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 23.5787)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _kernel(w, k):\n    if k == \"gaussian\":\n        s = w / 6.0\n        t = np.arange(w) - (w - 1) / 2.0\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif k == \"hann\":\n        k = np.hanning(w)\n    elif k in (\"exp\", \"exponential\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _mad(x):\n    m = np.median(x)\n    return np.median(np.abs(x - m))\n\ndef _auto_kind(x):\n    a = _mad(x)\n    return \"gaussian\" if a < 0.02 else \"hann\" if a < 0.07 else \"exponential\"\n\ndef process_signal(sig, win=20, alg=\"enhanced\", full=False):\n    \"\"\"Smooth 1\u2011D signal.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    win : int, optional\n        Window length (>0). Default 20.\n    alg : str, optional\n        \"enhanced\" \u2013 detrend + adaptive kernel,\n        \"simple\"   \u2013 uniform moving average,\n        \"median\"   \u2013 median filter,\n        other      \u2013 kernel name.\n    full : bool, optional\n        If True, return full\u2011length output (mode='same');\n        otherwise return the central valid part.\n\n    Returns\n    -------\n    np.ndarray\n        Smoothed signal.\n    \"\"\"\n    if win <= 0:\n        raise ValueError(\"window must be positive\")\n    x = np.asarray(sig, dtype=float)\n\n    if alg == \"enhanced\":\n        x = x - np.convolve(x, np.ones(win) / win, mode=\"same\")\n        kind = _auto_kind(x)\n        y = np.convolve(x, _kernel(win, kind), mode=\"same\")\n    elif alg == \"simple\":\n        y = np.convolve(x, _kernel(win, \"uniform\"), mode=\"same\")\n    elif alg == \"median\":\n        pad = win // 2\n        p = np.pad(x, (pad, pad), mode=\"edge\")\n        s = p.strides[0]\n        w = np.lib.stride_tricks.as_strided(p, (len(x), win), (s, s))\n        y = np.median(w, axis=1)\n        if full:\n            y = np.pad(y, (pad, pad), mode=\"edge\")\n    else:\n        y = np.convolve(x, _kernel(win, alg), mode=\"same\")\n\n    if not full and alg != \"median\":\n        off = win - 1\n        s = off // 2\n        e = -(off - s) if (off - s) != 0 else None\n        y = y[s:e]\n    return y\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4131), Performs well on output_length (91.0000), Performs well on overall_score (0.2881), Performs well on slope_changes (154.8000), Performs well on lag_error (0.3588), Performs well on avg_error (0.9557), Performs well on false_reversals (125.6000), Performs well on correlation (-0.0073), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1144), Performs well on responsiveness_score (0.7359), Performs well on accuracy_score (0.0000), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0008), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 23.5787)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef _kernel(w, kind):\n    t = np.arange(w) - (w - 1) / 2\n    if kind == \"gaussian\":\n        s = w / 6.0\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind == \"hann\":\n        k = np.hanning(w)\n    elif kind in (\"exp\", \"exponential\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _mad(x):\n    m = np.median(x)\n    return np.median(np.abs(x - m))\n\ndef _auto_kind(x):\n    m = _mad(x)\n    v = x.var()\n    return \"gaussian\" if m < 0.015 and v < 0.02 else \"hann\" if m < 0.07 else \"exponential\"\n\ndef _detrend(x, w):\n    return x - np.convolve(x, np.ones(w) / w, mode=\"same\") if w and x.size >= w else x\n\ndef _interp_nan(x):\n    if np.isnan(x).any():\n        i = np.arange(x.size)\n        m = np.isfinite(x)\n        x = np.interp(i, i[m], x[m])\n    return x\n\ndef _median_filter(x, w):\n    p = w // 2\n    a = np.pad(x, (p, p), mode=\"edge\")\n    win = np.lib.stride_tricks.as_strided(a, (x.size, w), (a.strides[0], a.strides[0]))\n    return np.median(win, axis=1)\n\ndef process_signal(sig, win=20, alg=\"enhanced\", full=False):\n    if win <= 0:\n        raise ValueError(\"win must be positive\")\n    x = _interp_nan(np.asarray(sig, float))\n    if alg == \"enhanced\":\n        x = _detrend(x, win)\n        kind = _auto_kind(x)\n        y = np.convolve(x, _kernel(win, kind), mode=\"same\")\n    elif alg == \"simple\":\n        y = np.convolve(x, _kernel(win, \"uniform\"), mode=\"same\")\n    elif alg == \"median\":\n        y = _median_filter(x, win)\n        return y if full else y\n    else:\n        y = np.convolve(x, _kernel(win, alg), mode=\"same\")\n    if not full:\n        off = win - 1\n        s = off // 2\n        e = -(off - s) if (off - s) != 0 else None\n        y = y[s:e]\n    return y\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4131), Performs well on output_length (91.0000), Performs well on overall_score (0.2881), Performs well on slope_changes (154.8000), Performs well on lag_error (0.3588), Performs well on avg_error (0.9557), Performs well on false_reversals (125.6000), Performs well on correlation (-0.0073), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1144), Performs well on responsiveness_score (0.7359), Performs well on accuracy_score (0.0000), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0007), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 23.5787)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef _kernel(w, kind):\n    t = np.arange(w) - (w - 1) / 2\n    if kind == \"gaussian\":\n        s = w / 6.0\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind == \"hann\":\n        k = np.hanning(w)\n    elif kind in (\"exponential\", \"exp\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _mad(x):\n    m = np.median(x)\n    return np.median(np.abs(x - m))\n\ndef _auto_kind(x):\n    mad = _mad(x)\n    var = np.var(x)\n    if mad < 0.02 and var < 0.02:\n        return \"gaussian\"\n    if mad < 0.08:\n        return \"hann\"\n    return \"exponential\"\n\ndef _detrend(x, w):\n    return x - np.convolve(x, np.ones(w) / w, mode=\"same\") if w > 0 and len(x) >= w else x\n\ndef _median_filter(x, w):\n    p = w // 2\n    a = np.pad(x, (p, p), mode=\"edge\")\n    shape = (len(x), w)\n    strides = (a.strides[0], a.strides[0])\n    windows = np.lib.stride_tricks.as_strided(a, shape, strides)\n    return np.median(windows, axis=1)\n\ndef _valid_slice(y, w):\n    off = w - 1\n    start = off // 2\n    end = -(off - start) if (off - start) != 0 else None\n    return y[start:end]\n\ndef process_signal(sig, window=20, algo=\"enhanced\", full=False):\n    if window <= 0:\n        raise ValueError(\"window must be positive\")\n    x = np.asarray(sig, float)\n    if np.isnan(x).any():\n        n = np.arange(len(x))\n        mask = np.isfinite(x)\n        x = np.interp(n, n[mask], x[mask])\n    if algo == \"enhanced\":\n        x = _detrend(x, window)\n        kind = _auto_kind(x)\n        y = np.convolve(x, _kernel(window, kind), mode=\"same\")\n    elif algo == \"simple\":\n        y = np.convolve(x, _kernel(window, \"uniform\"), mode=\"same\")\n    elif algo == \"median\":\n        y = _median_filter(x, window)\n        return y if full else y\n    else:\n        y = np.convolve(x, _kernel(window, algo), mode=\"same\")\n    return y if full else _valid_slice(y, window)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4131), Performs well on output_length (91.0000), Performs well on overall_score (0.2881), Performs well on slope_changes (154.8000), Performs well on lag_error (0.3588), Performs well on avg_error (0.9557), Performs well on false_reversals (125.6000), Performs well on correlation (-0.0073), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1144), Performs well on responsiveness_score (0.7359), Performs well on accuracy_score (0.0000), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0007), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 23.5787)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef _kernel(w, kind):\n    t = np.arange(w) - (w - 1) / 2\n    if kind == \"gaussian\":\n        s = w / 6.0\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind == \"hann\":\n        k = np.hanning(w)\n    elif kind in (\"exp\", \"exponential\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _interp_nan(x):\n    if np.isnan(x).any():\n        i = np.arange(x.size)\n        m = np.isfinite(x)\n        x = np.interp(i, i[m], x[m])\n    return x\n\ndef _detrend(x, w):\n    if w > 0 and x.size >= w:\n        return x - np.convolve(x, np.ones(w) / w, mode=\"same\")\n    return x\n\ndef _mad(x):\n    m = np.median(x)\n    return np.median(np.abs(x - m))\n\ndef _auto_kind(x):\n    mad = _mad(x)\n    var = x.var()\n    if mad < 0.015 and var < 0.02:\n        return \"gaussian\"\n    if mad < 0.07:\n        return \"hann\"\n    return \"exponential\"\n\ndef _median_filter(x, w):\n    p = w // 2\n    a = np.pad(x, (p, p), mode=\"edge\")\n    shape = (x.size, w)\n    strides = (a.strides[0], a.strides[0])\n    win = np.lib.stride_tricks.as_strided(a, shape, strides)\n    return np.median(win, axis=1)\n\ndef _valid_slice(y, w):\n    off = w - 1\n    s = off // 2\n    e = -(off - s) if (off - s) != 0 else None\n    return y[s:e]\n\ndef process_signal(sig, win=20, alg=\"enhanced\", full=False):\n    if win <= 0:\n        raise ValueError(\"win must be positive\")\n    x = _interp_nan(np.asarray(sig, float))\n    if alg == \"enhanced\":\n        x = _detrend(x, win)\n        kind = _auto_kind(x)\n        y = np.convolve(x, _kernel(win, kind), mode=\"same\")\n    elif alg == \"simple\":\n        y = np.convolve(x, _kernel(win, \"uniform\"), mode=\"same\")\n    elif alg == \"median\":\n        y = _median_filter(x, win)\n        return y if full else y\n    elif alg == \"smooth\":\n        y = np.convolve(x, _kernel(win, \"hann\"), mode=\"same\")\n    else:\n        y = np.convolve(x, _kernel(win, alg), mode=\"same\")\n    if not full:\n        y = _valid_slice(y, win)\n    return y\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 23.5787)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _validate(sig, w):\n    if w <= 0 or len(sig) < w:\n        raise ValueError(\"invalid window or signal length\")\n\n@lru_cache(None)\ndef _kernel(w, kind):\n    t = np.arange(w) - (w - 1) / 2\n    if kind == \"gaussian\":\n        s = w / 6.0\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind == \"hann\":\n        k = np.hanning(w)\n    elif kind in (\"exp\", \"exponential\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _mad(x):\n    m = np.median(x)\n    return np.median(np.abs(x - m))\n\ndef _auto_kind(x):\n    m = _mad(x)\n    v = np.var(x)\n    return \"gaussian\" if m < .02 and v < .02 else \"hann\" if m < .07 else \"exponential\"\n\ndef _detrend(x, w):\n    return x - np.convolve(x, np.ones(w) / w, mode=\"same\") if len(x) >= w else x\n\ndef _median_filter(x, w):\n    p = w // 2\n    a = np.pad(x, (p, p), mode=\"edge\")\n    s = a.strides[0]\n    win = np.lib.stride_tricks.as_strided(a, (len(x), w), (s, s))\n    return np.median(win, axis=1)\n\ndef _valid_slice(y, w):\n    o = w - 1\n    s = o // 2\n    e = -(o - s) if (o - s) != 0 else None\n    return y[s:e]\n\ndef process_signal(sig, win=20, alg=\"enhanced\", full=False):\n    _validate(sig, win)\n    x = np.asarray(sig, float)\n\n    if np.isnan(x).any():\n        n = np.arange(len(x))\n        m = np.isfinite(x)\n        x = np.interp(n, n[m], x[m])\n\n    if alg == \"enhanced\":\n        x = _detrend(x, win)\n        kind = _auto_kind(x)\n        y = np.convolve(x, _kernel(win, kind), mode=\"same\")\n    elif alg == \"simple\":\n        y = np.convolve(x, _kernel(win, \"uniform\"), mode=\"same\")\n    elif alg == \"median\":\n        y = _median_filter(x, win)\n        if full:\n            y = np.pad(y, (win // 2, win // 2), mode=\"edge\")\n    else:\n        y = np.convolve(x, _kernel(win, alg), mode=\"same\")\n\n    return y if full or alg == \"median\" else _valid_slice(y, win)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 23.5787, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef _kernel(w, kind):\n    \"\"\"Return a normalized convolution kernel.\"\"\"\n    if isinstance(kind, np.ndarray):\n        if kind.shape != (w,):\n            raise ValueError(\"custom kernel length must equal window size\")\n        k = kind\n    elif kind == \"gaussian\":\n        s = w / 6.0\n        t = np.arange(w) - (w - 1) / 2.0\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind == \"hann\":\n        k = np.hanning(w)\n    elif kind in (\"exp\", \"exponential\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    elif kind == \"uniform\":\n        k = np.ones(w)\n    else:\n        raise ValueError(f\"unknown kernel kind: {kind}\")\n    return k / k.sum()\n\ndef _mad(x):\n    m = np.median(x)\n    return np.median(np.abs(x - m))\n\ndef _auto_kind(x):\n    \"\"\"Select kernel based on signal variability.\"\"\"\n    mad = _mad(x)\n    var = x.var()\n    if mad < 0.02 and var < 0.02:\n        return \"gaussian\"\n    if mad < 0.07:\n        return \"hann\"\n    return \"exponential\"\n\ndef _interp_nan(x):\n    if np.isnan(x).any():\n        i = np.arange(x.size)\n        mask = np.isfinite(x)\n        x = np.interp(i, i[mask], x[mask])\n    return x\n\ndef _median_filter(x, w):\n    \"\"\"Median filter using sliding_window_view when available.\"\"\"\n    try:\n        view = np.lib.stride_tricks.sliding_window_view(x, w)\n        return np.median(view, axis=1)\n    except AttributeError:\n        p = w // 2\n        a = np.pad(x, (p, p), mode=\"edge\")\n        v = np.lib.stride_tricks.as_strided(\n            a, (len(x), w), (a.strides[0], a.strides[0])\n        )\n        return np.median(v, axis=1)\n\ndef _detrend(x, w):\n    \"\"\"Remove moving\u2011average trend.\"\"\"\n    if w and len(x) >= w:\n        return x - np.convolve(x, np.ones(w) / w, mode=\"same\")\n    return x\n\n@lru_cache(maxsize=None)\ndef _sg_coeffs(w, order):\n    \"\"\"Savitzky\u2011Golay smoothing coefficients (odd window).\"\"\"\n    if w % 2 == 0:\n        w += 1\n    half = w // 2\n    A = np.arange(-half, half + 1)[:, None]\n    X = np.vander(A.squeeze(), N=order + 1, increasing=True)\n    coeffs = np.linalg.pinv(X)[0]\n    return coeffs\n\ndef _savitzky_golay(x, w, order=2):\n    coeffs = _sg_coeffs(w, order)\n    return np.convolve(x, coeffs, mode=\"same\")\n\ndef _slice_valid(y, w):\n    \"\"\"Return central valid part of a 'same' convolution output.\"\"\"\n    off = w - 1\n    start = off // 2\n    end = -(off - start) if (off - start) != 0 else None\n    return y[start:end]\n\ndef process_signal(\n    sig,\n    win=20,\n    alg=\"enhanced\",\n    full=False,\n    detrend_win=None,\n    custom_kernel=None,\n    sg_order=2,\n):\n    \"\"\"\n    Smooth a 1\u2011D signal.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    win : int, optional\n        Primary smoothing window (default 20). Must be >0.\n    alg : str, optional\n        \"enhanced\" \u2013 detrend + adaptive kernel,\n        \"simple\"   \u2013 uniform moving average,\n        \"median\"   \u2013 median filter,\n        \"sg\"       \u2013 Savitzky\u2011Golay smoothing,\n        other      \u2013 kernel name or \"custom\".\n    full : bool, optional\n        If True, return full\u2011length output (mode='same').\n    detrend_win : int or None, optional\n        Window size for detrending (default = win).\n    custom_kernel : array\u2011like or None, optional\n        User\u2011supplied kernel for alg=\"custom\".\n    sg_order : int, optional\n        Polynomial order for Savitzky\u2011Golay (default 2).\n\n    Returns\n    -------\n    np.ndarray\n        Smoothed signal.\n    \"\"\"\n    if win <= 0:\n        raise ValueError(\"win must be positive\")\n    x = _interp_nan(np.asarray(sig, float))\n\n    # Detrending (only for algorithms that need it)\n    if alg == \"enhanced\":\n        dwin = detrend_win if detrend_win is not None else win\n        x = _detrend(x, dwin)\n        kind = _auto_kind(x)\n        y = np.convolve(x, _kernel(win, kind), mode=\"same\")\n    elif alg == \"simple\":\n        y = np.convolve(x, _kernel(win, \"uniform\"), mode=\"same\")\n    elif alg == \"median\":\n        y = _median_filter(x, win)\n        if full:\n            pad = win // 2\n            y = np.pad(y, (pad, pad), mode=\"edge\")\n        return y\n    elif alg == \"sg\":\n        y = _savitzky_golay(x, win, order=sg_order)\n    elif alg == \"custom\":\n        if custom_kernel is None:\n            raise ValueError(\"custom_kernel must be provided for alg='custom'\")\n        ck = np.asarray(custom_kernel, float)\n        y = np.convolve(x, _kernel(win, ck), mode=\"same\")\n    else:\n        # treat alg as kernel name\n        y = np.convolve(x, _kernel(win, alg), mode=\"same\")\n\n    if not full:\n        y = _slice_valid(y, win)\n    return y\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 2 (Score: 23.5787, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _kernel(w, kind):\n    t = np.arange(w) - (w - 1) / 2\n    if kind == \"gaussian\":\n        s = w / 6.0\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind == \"hann\":\n        k = np.hanning(w)\n    elif kind in (\"exp\", \"exponential\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _auto_kind(x):\n    mad = np.median(np.abs(x - np.median(x)))\n    var = x.var()\n    return \"gaussian\" if mad < 0.02 and var < 0.02 else \"hann\" if mad < 0.07 else \"exponential\"\n\ndef _detrend(x, w):\n    return x - np.convolve(x, np.ones(w) / w, mode=\"same\") if w and len(x) >= w else x\n\ndef _median(x, w):\n    p = w // 2\n    a = np.pad(x, (p, p), mode=\"edge\")\n    shape = (len(x), w)\n    strides = (a.strides[0], a.strides[0])\n    win = np.lib.stride_tricks.as_strided(a, shape, strides)\n    return np.median(win, axis=1)\n\ndef process_signal(sig, window=20, alg=\"enhanced\", full=False):\n    if window <= 0:\n        raise ValueError(\"window must be a positive integer\")\n    x = np.asarray(sig, float)\n\n    if np.isnan(x).any():\n        n = np.arange(len(x))\n        m = np.isfinite(x)\n        x = np.interp(n, n[m], x[m])\n\n    if alg == \"enhanced\":\n        x = _detrend(x, window)\n        kind = _auto_kind(x)\n        y = np.convolve(x, _kernel(window, kind), mode=\"same\")\n    elif alg == \"simple\":\n        y = np.convolve(x, _kernel(window, \"uniform\"), mode=\"same\")\n    elif alg == \"median\":\n        y = _median(x, window)\n    else:\n        y = np.convolve(x, _kernel(window, alg), mode=\"same\")\n\n    if full:\n        return y\n    off = window - 1\n    start = off // 2\n    end = -(off - start) if (off - start) != 0 else None\n    return y[start:end]\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 3 (Score: 23.5787, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\ndef _v(sig, w):\n    if w <= 0 or not isinstance(w, int):\n        raise ValueError(\"window must be positive int\")\n    if len(sig) < w:\n        raise ValueError(\"signal shorter than window\")\n\n@lru_cache(None)\ndef _k(w, t):\n    a = np.arange(w) - (w - 1) / 2\n    if t == \"gaussian\":\n        s = w / 6.0\n        k = np.exp(-0.5 * (a / s) ** 2)\n    elif t == \"hann\":\n        k = np.hanning(w)\n    elif t in (\"exp\", \"exponential\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _mad(x):\n    m = np.median(x)\n    return np.median(np.abs(x - m))\n\ndef _ak(x):\n    m = _mad(x)\n    v = x.var()\n    if m < 0.02 and v < 0.02:\n        return \"gaussian\"\n    if m < 0.07:\n        return \"hann\"\n    return \"exponential\"\n\ndef _dt(x, w):\n    return x - np.convolve(x, np.ones(w) / w, mode=\"same\") if len(x) >= w else x\n\ndef _mf(x, w):\n    try:\n        from numpy.lib.stride_tricks import sliding_window_view\n        return np.median(sliding_window_view(x, w), axis=1)\n    except Exception:\n        p = w // 2\n        a = np.pad(x, (p, p), mode=\"edge\")\n        s = (a.strides[0], a.strides[0])\n        sh = (len(x), w)\n        return np.median(np.lib.stride_tricks.as_strided(a, sh, s), axis=1)\n\ndef process_signal(sig, win=20, alg=\"enhanced\", full=False):\n    _v(sig, win)\n    x = np.asarray(sig, float)\n    if np.isnan(x).any():\n        n = np.arange(len(x))\n        m = np.isfinite(x)\n        x = np.interp(n, n[m], x[m])\n    if alg == \"enhanced\":\n        x = _dt(x, win)\n        k = _ak(x)\n        y = np.convolve(x, _k(win, k), mode=\"same\")\n    elif alg == \"simple\":\n        y = np.convolve(x, _k(win, \"uniform\"), mode=\"same\")\n    elif alg == \"median\":\n        y = _mf(x, win)\n        if full:\n            p = win // 2\n            y = np.pad(y, (p, p), mode=\"edge\")\n    elif alg == \"sg\":\n        y = np.convolve(x, _k(win, \"hann\"), mode=\"same\")\n    else:\n        y = np.convolve(x, _k(win, alg), mode=\"same\")\n    if not full and alg != \"median\":\n        o = win - 1\n        s = o // 2\n        e = -(o - s) if (o - s) != 0 else None\n        y = y[s:e]\n    return y\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef _kernel(w, kind):\n    \"\"\"Return a normalized kernel.\"\"\"\n    if kind == \"gaussian\":\n        sigma = w / 6.0\n        t = np.arange(w) - (w - 1) / 2.0\n        k = np.exp(-0.5 * (t / sigma) ** 2)\n    elif kind in (\"exponential\", \"exp\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    elif kind == \"hann\":\n        k = np.hanning(w)\n    else:  # uniform fallback\n        k = np.ones(w)\n    return k / k.sum()\n\n\ndef _detrend(x, w):\n    \"\"\"Remove a moving\u2011average trend.\"\"\"\n    if w > 0 and len(x) >= w:\n        return x - np.convolve(x, np.ones(w) / w, mode=\"same\")\n    return x\n\n\ndef _mad(x):\n    \"\"\"Median absolute deviation.\"\"\"\n    m = np.median(x)\n    return np.median(np.abs(x - m))\n\n\ndef _auto_kind(x):\n    \"\"\"Choose kernel based on signal variability.\"\"\"\n    return \"gaussian\" if _mad(x) < 0.05 else \"exponential\"\n\n\ndef _median_filter(x, w):\n    \"\"\"Median filter using stride tricks (valid output).\"\"\"\n    pad = w // 2\n    padded = np.pad(x, (pad, pad), mode=\"edge\")\n    shape = (len(x), w)\n    strides = (padded.strides[0], padded.strides[0])\n    windows = np.lib.stride_tricks.as_strided(padded, shape=shape, strides=strides)\n    return np.median(windows, axis=1)\n\n\ndef process_signal(sig, win=20, alg=\"enhanced\", full=False):\n    \"\"\"\n    Smooth a 1\u2011D signal.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    win : int, optional\n        Window length (default 20).\n    alg : str, optional\n        \"enhanced\" \u2013 detrend + adaptive kernel,\n        \"simple\"   \u2013 uniform moving average,\n        \"median\"   \u2013 median filter,\n        \"smooth\"   \u2013 Hann kernel,\n        otherwise interpreted as a kernel kind.\n    full : bool, optional\n        If True, return full\u2011length output (mode='same'); else valid output.\n    \"\"\"\n    if win <= 0:\n        raise ValueError(\"win must be a positive integer\")\n    x = np.asarray(sig, dtype=float)\n\n    if alg == \"enhanced\":\n        x = _detrend(x, win)\n        kind = _auto_kind(x)\n        y = np.convolve(x, _kernel(win, kind), mode=\"same\")\n    elif alg == \"simple\":\n        y = np.convolve(x, _kernel(win, \"uniform\"), mode=\"same\")\n    elif alg == \"median\":\n        return _median_filter(x, win)\n    elif alg == \"smooth\":\n        y = np.convolve(x, _kernel(win, \"hann\"), mode=\"same\")\n    else:\n        y = np.convolve(x, _kernel(win, alg), mode=\"same\")\n\n    if not full:\n        offset = win - 1\n        start = offset // 2\n        end = -(offset - start) if (offset - start) != 0 else None\n        y = y[start:end]\n    return y\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["import numpy as np\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef _kernel(w, kind):\n    t = np.arange(w) - (w - 1) / 2\n    if kind == \"gaussian\":\n        sigma = w / 6.0\n        k = np.exp(-0.5 * (t / sigma) ** 2)\n    elif kind == \"hann\":\n        k = np.hanning(w)\n    elif kind in (\"exp\", \"exponential\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:  # uniform fallback\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _detrend(x, w):\n    return x - np.convolve(x, np.ones(w) / w, mode=\"same\") if w > 0 and len(x) >= w else x\n\ndef _mad(x):\n    m = np.median(x)\n    return np.median(np.abs(x - m))\n\ndef _auto_kind(x):\n    mad = _mad(x)\n    var = x.var()\n    if mad < 0.02 and var < 0.02:\n        return \"gaussian\"\n    if mad < 0.07:\n        return \"hann\"\n    return \"exponential\"\n\ndef _interp_nan(x):\n    if np.isnan(x).any():\n        i = np.arange(x.size)\n        mask = np.isfinite(x)\n        x = np.interp(i, i[mask], x[mask])\n    return x\n\ndef _median_filter(x, w):\n    p = w // 2\n    a = np.pad(x, (p, p), mode=\"edge\")\n    shape = (len(x), w)\n    strides = (a.strides[0], a.strides[0])\n    windows = np.lib.stride_tricks.as_strided(a, shape, strides)\n    return np.median(windows, axis=1)\n\ndef _valid_slice(y, w):\n    off = w - 1\n    s = off // 2\n    e = -(off - s) if (off - s) != 0 else None\n    return y[s:e]\n\ndef process_signal(sig, win=20, alg=\"enhanced\", full=False):\n    if win <= 0:\n        raise ValueError(\"win must be a positive integer\")\n    x = _interp_nan(np.asarray(sig, float))\n\n    if alg == \"enhanced\":\n        x = _detrend(x, win)\n        kind = _auto_kind(x)\n        y = np.convolve(x, _kernel(win, kind), mode=\"same\")\n    elif alg == \"simple\":\n        y = np.convolve(x, _kernel(win, \"uniform\"), mode=\"same\")\n    elif alg == \"median\":\n        y = _median_filter(x, win)\n        return y if full else y\n    else:\n        y = np.convolve(x, _kernel(win, alg), mode=\"same\")\n\n    return y if full else _valid_slice(y, win)"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}