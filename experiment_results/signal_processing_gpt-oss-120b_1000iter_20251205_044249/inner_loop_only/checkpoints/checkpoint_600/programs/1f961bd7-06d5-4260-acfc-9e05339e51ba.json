{"id": "1f961bd7-06d5-4260-acfc-9e05339e51ba", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef _kernel(w,k):\n    t=np.arange(w)-(w-1)/2\n    if k==\"gaussian\":s=w/6.;k=np.exp(-.5*(t/s)**2)\n    elif k in(\"exp\",\"exponential\"):k=np.exp(np.linspace(-2,0,w))\n    else:k=np.ones(w)\n    return k/k.sum()\n\ndef _mad(x):m=np.median(x);return np.median(np.abs(x-m))\n\ndef _auto_kind(x):return \"gaussian\" if _mad(x)<0.05 else \"exponential\"\n\ndef _median(x,w):\n    p=w//2;xv=np.pad(x,(p,p),mode=\"edge\")\n    return np.median(np.lib.stride_tricks.sliding_window_view(xv,w),axis=1)\n\ndef _smooth(x,w,k,n):\n    for _ in range(n):\n        if k==\"median\":x=_median(x,w)\n        else:x=np.convolve(x,_kernel(w,k),mode=\"same\")\n    return x\n\ndef process_signal(sig,win=20,alg=\"enhanced\",passes=1,full=False):\n    x=np.asarray(sig,float)\n    if alg==\"enhanced\":\n        x=x-np.convolve(x,np.ones(win)/win,mode=\"same\")\n        k=_auto_kind(x)\n    elif alg==\"robust\":\n        x=_median(x,win);k=_auto_kind(x)\n    elif alg==\"simple\":k=\"uniform\"\n    elif alg==\"gaussian\":k=\"gaussian\"\n    elif alg in(\"exp\",\"exponential\"):k=\"exponential\"\n    elif alg==\"median\":k=\"median\"\n    else:k=alg\n    y=_smooth(x,win,k,passes)\n    if not full and win>1:\n        half=win//2\n        return y[half:-(half)] if win%2 else y[half:-(half)]\n    return y\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "87392b43-4ee1-4f95-a3f5-490e22b2ccd3", "generation": 11, "timestamp": 1764934189.454431, "iteration_found": 581, "metrics": {"runs_successfully": 1.0, "composite_score": 0.41300746150997664, "output_length": 90.0, "overall_score": 0.28808627979849866, "slope_changes": 154.8, "lag_error": 0.3621312403540458, "avg_error": 0.9575093078419732, "false_reversals": 124.0, "correlation": -0.0065224212389614535, "noise_reduction": 0.0, "smoothness_score": 0.11441647597254004, "responsiveness_score": 0.7341436495796687, "accuracy_score": 0.0, "efficiency_score": 1.0, "execution_time": 0.0005730628967285156, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.4128316457180309, "output_length": 91.0, "overall_score": 0.28798980114435524, "slope_changes": 155.0, "lag_error": 0.35539883377261255, "avg_error": 0.9565324748302244, "false_reversals": 124.2, "correlation": -0.006103226166624641, "noise_reduction": 0.0, "smoothness_score": 0.11428571428571428, "responsiveness_score": 0.7377902172282407, "accuracy_score": 0.0, "efficiency_score": 1.0, "execution_time": 0.0007899284362792968, "success_rate": 1.0}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 23.5037\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 23.5100 \u2192 23.5037. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4095, output_length: 91.0000, overall_score: 0.3111, slope_changes: 153.4000, lag_error: 0.4734, avg_error: 0.9280, false_reversals: 125.6000, correlation: 0.1212, noise_reduction: 0.0000, smoothness_score: 0.1153, responsiveness_score: 0.6787, accuracy_score: 0.1212, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4095, output_length: 91.0000, overall_score: 0.3111, slope_changes: 153.4000, lag_error: 0.4734, avg_error: 0.9280, false_reversals: 125.6000, correlation: 0.1212, noise_reduction: 0.0000, smoothness_score: 0.1153, responsiveness_score: 0.6787, accuracy_score: 0.1212, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4095, output_length: 91.0000, overall_score: 0.3111, slope_changes: 153.4000, lag_error: 0.4734, avg_error: 0.9280, false_reversals: 125.6000, correlation: 0.1212, noise_reduction: 0.0000, smoothness_score: 0.1153, responsiveness_score: 0.6787, accuracy_score: 0.1212, efficiency_score: 1.0000, execution_time: 0.0007, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 23.5100)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\ndef _kernel(w,k):\n    t=np.arange(w)-(w-1)/2\n    if k==\"gaussian\":\n        s=w/6.;k=np.exp(-.5*(t/s)**2)\n    elif k==\"exponential\":\n        k=np.exp(np.linspace(-2,0,w))\n    elif k==\"triangular\":\n        k=1-np.abs(t)/((w+1)/2)\n    else:\n        k=np.ones(w)\n    return k/k.sum()\ndef _median(x,w):\n    if len(x)<w:return x\n    p=w//2;x=np.pad(x,(p,p),mode=\"edge\")\n    return np.median(np.lib.stride_tricks.sliding_window_view(x,w),axis=1)\ndef _detrend(x,w,m):\n    return x-_median(x,w) if m==\"median\" else x-np.convolve(x,np.ones(w)/w,mode=\"same\")\ndef _smooth(x,w,k,p):\n    for _ in range(p):\n        x=_median(x,w) if k==\"median\" else np.convolve(x,_kernel(w,k),mode=\"same\")\n    return x\ndef process_signal(sig,window=20,algo=\"enhanced\",passes=1):\n    x=np.asarray(sig,float)\n    if algo==\"enhanced\":\n        x=_detrend(x,window,\"mean\");k=\"exponential\"\n    elif algo==\"robust\":\n        x=_detrend(x,window,\"median\");k=\"exponential\"\n    elif algo==\"simple\":\n        k=\"uniform\"\n    elif algo==\"gaussian\":\n        k=\"gaussian\"\n    elif algo in (\"exp\",\"exponential\"):\n        k=\"exponential\"\n    elif algo==\"median\":\n        k=\"median\"\n    elif algo==\"triangular\":\n        k=\"triangular\"\n    else:\n        k=algo\n    return _smooth(x,window,k,passes)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4095), Performs well on output_length (91.0000), Performs well on overall_score (0.3111), Performs well on slope_changes (153.4000), Performs well on lag_error (0.4734), Performs well on avg_error (0.9280), Performs well on false_reversals (125.6000), Performs well on correlation (0.1212), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1153), Performs well on responsiveness_score (0.6787), Performs well on accuracy_score (0.1212), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0007), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 23.5100)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _k(w,t):\n    a=np.arange(w)-(w-1)/2\n    if t==\"gaussian\":s=w/6.;k=np.exp(-.5*(a/s)**2)\n    elif t==\"exponential\":k=np.exp(np.linspace(-2,0,w))\n    else:k=np.ones(w)\n    return k/k.sum()\n\ndef _m(x,w):\n    p=w//2;x=np.pad(x,(p,p),mode=\"edge\")\n    return np.median(np.lib.stride_tricks.sliding_window_view(x,w),axis=1)\n\ndef _d(x,w,m):\n    return x-_m(x,w) if m==\"median\" else x-np.convolve(x,np.ones(w)/w,mode=\"same\")\n\ndef _a(x):\n    return \"gaussian\" if np.median(np.abs(x-np.median(x)))<.04 else \"exponential\"\n\ndef _s(x,w,k):\n    return _m(x,w) if k==\"median\" else np.convolve(x,_k(w,k),mode=\"same\")\n\ndef process_signal(sig,window=20,algo=\"enhanced\",passes=1):\n    x=np.asarray(sig,float)\n    if algo==\"enhanced\":\n        x=_d(x,window,\"mean\");k=_a(x)\n    elif algo==\"robust\":\n        x=_d(x,window,\"median\");k=_a(x)\n    elif algo==\"simple\":k=\"uniform\"\n    elif algo==\"gaussian\":k=\"gaussian\"\n    elif algo in(\"exp\",\"exponential\"):k=\"exponential\"\n    elif algo==\"median\":k=\"median\"\n    else:k=algo\n    for _ in range(passes):x=_s(x,window,k)\n    return x\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4095), Performs well on output_length (91.0000), Performs well on overall_score (0.3111), Performs well on slope_changes (153.4000), Performs well on lag_error (0.4734), Performs well on avg_error (0.9280), Performs well on false_reversals (125.6000), Performs well on correlation (0.1212), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1153), Performs well on responsiveness_score (0.6787), Performs well on accuracy_score (0.1212), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 23.5100)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _kernel(w, k):\n    t = np.arange(w) - (w - 1) / 2\n    if k == \"gaussian\":\n        s = w / 6.0\n        k = np.exp(-0.5 * ((t / s) ** 2))\n    elif k == \"triangular\":\n        k = 1 - np.abs(t) / ((w + 1) / 2)\n    elif k == \"exponential\":\n        k = np.exp(np.linspace(-2, 0, w))\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _auto_kind(x):\n    mad = np.median(np.abs(x - np.median(x)))\n    return \"gaussian\" if mad < 0.02 else \"triangular\" if mad < 0.05 else \"exponential\"\n\ndef process_signal(sig, window=20, algo=\"enhanced\"):\n    x = np.asarray(sig, float)\n    if algo == \"enhanced\":\n        x = x - np.convolve(x, np.ones(window) / window, mode=\"same\")\n        k = _auto_kind(x)\n    else:\n        k = algo\n    return np.convolve(x, _kernel(window, k), mode=\"same\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4095), Performs well on output_length (91.0000), Performs well on overall_score (0.3111), Performs well on slope_changes (153.4000), Performs well on lag_error (0.4734), Performs well on avg_error (0.9280), Performs well on false_reversals (125.6000), Performs well on correlation (0.1212), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1153), Performs well on responsiveness_score (0.6787), Performs well on accuracy_score (0.1212), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 23.5100)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef _kernel(w, kind):\n    \"\"\"Return a normalized kernel array.\"\"\"\n    t = np.arange(w) - (w - 1) / 2\n    if kind == \"gaussian\":\n        sigma = w / 6.0\n        k = np.exp(-0.5 * (t / sigma) ** 2)\n    elif kind in (\"exponential\", \"exp\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    elif kind == \"triangular\":\n        k = 1 - np.abs(t) / ((w + 1) / 2)\n    else:  # uniform fallback\n        k = np.ones(w)\n    return k / k.sum()\n\n\ndef _median_filter(x, w):\n    \"\"\"Median filter with edge padding.\"\"\"\n    if w <= 1:\n        return x\n    pad = w // 2\n    xv = np.pad(x, (pad, pad), mode=\"edge\")\n    windows = np.lib.stride_tricks.sliding_window_view(xv, w)\n    return np.median(windows, axis=1)\n\n\ndef _detrend(x, w, method=\"mean\"):\n    \"\"\"Remove a slow trend using a moving average or median.\"\"\"\n    if w <= 0 or len(x) < w:\n        return x\n    if method == \"median\":\n        return x - _median_filter(x, w)\n    # default: moving\u2011average detrend\n    trend = np.convolve(x, np.ones(w) / w, mode=\"same\")\n    return x - trend\n\n\ndef _auto_kind(x):\n    \"\"\"Choose a smoothing kernel based on signal dispersion.\"\"\"\n    mad = np.median(np.abs(x - np.median(x)))\n    if mad < 0.02:\n        return \"median\"\n    if mad < 0.05:\n        return \"gaussian\"\n    if mad < 0.10:\n        return \"triangular\"\n    return \"exponential\"\n\n\ndef _smooth(x, w, kind, passes=1):\n    \"\"\"Apply the selected kernel (or median) repeatedly.\"\"\"\n    for _ in range(passes):\n        if kind == \"median\":\n            x = _median_filter(x, w)\n        else:\n            x = np.convolve(x, _kernel(w, kind), mode=\"same\")\n    return x\n\n\ndef process_signal(sig, win=20, alg=\"enhanced\", passes=1, full=False):\n    \"\"\"\n    Smooth a 1\u2011D signal.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Raw signal.\n    win : int, default 20\n        Smoothing window size.\n    alg : str, default \"enhanced\"\n        \"enhanced\", \"robust\", \"simple\", \"gaussian\", \"exp\",\n        \"exponential\", \"triangular\", \"median\" or a custom kernel name.\n    passes : int, default 1\n        Number of smoothing iterations.\n    full : bool, default False\n        If True, use ``mode='same'``; otherwise keep full length (``same`` as well\n        to avoid truncation artefacts).\n\n    Returns\n    -------\n    np.ndarray\n        Smoothed signal (same length as input).\n    \"\"\"\n    x = np.asarray(sig, float)\n\n    # Choose detrending and kernel based on algorithm\n    if alg == \"enhanced\":\n        x = _detrend(x, win, method=\"mean\")\n        kind = _auto_kind(x)\n    elif alg == \"robust\":\n        x = _detrend(x, win, method=\"median\")\n        kind = _auto_kind(x)\n    elif alg == \"simple\":\n        kind = \"uniform\"\n    elif alg == \"gaussian\":\n        kind = \"gaussian\"\n    elif alg in (\"exp\", \"exponential\"):\n        kind = \"exponential\"\n    elif alg == \"triangular\":\n        kind = \"triangular\"\n    elif alg == \"median\":\n        kind = \"median\"\n    else:\n        kind = alg  # custom kernel name\n\n    # ``full`` flag is kept for API compatibility but we always use ``same``\n    # to preserve the original length and avoid edge loss.\n    return _smooth(x, win, kind, passes=passes)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 23.5100)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef _kernel(w, kind):\n    t = np.arange(w) - (w - 1) / 2\n    if kind == \"gaussian\":\n        s = w / 6.0\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind == \"exponential\":\n        k = np.exp(np.linspace(-2, 0, w))\n    elif kind == \"triangular\":\n        k = 1 - np.abs(t) / ((w + 1) / 2)\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _median(x, w):\n    if len(x) < w:\n        return x\n    p = w // 2\n    xv = np.pad(x, (p, p), mode=\"edge\")\n    return np.median(np.lib.stride_tricks.sliding_window_view(xv, w), axis=1)\n\ndef _detrend(x, w, method):\n    if method == \"median\":\n        trend = _median(x, w)\n    else:\n        trend = np.convolve(x, np.ones(w) / w, mode=\"same\")\n    return x - trend\n\ndef _auto_kind(x):\n    mad = np.median(np.abs(x - np.median(x)))\n    if mad < 0.04:\n        return \"gaussian\"\n    if mad < 0.08:\n        return \"triangular\"\n    return \"exponential\"\n\ndef _smooth(x, w, kind, passes):\n    for _ in range(passes):\n        if kind == \"median\":\n            x = _median(x, w)\n        else:\n            x = np.convolve(x, _kernel(w, kind), mode=\"same\")\n    return x\n\ndef process_signal(sig, window=20, algo=\"enhanced\", passes=1):\n    x = np.asarray(sig, float)\n    if algo == \"enhanced\":\n        x = _detrend(x, window, \"mean\")\n        kind = _auto_kind(x)\n    elif algo == \"robust\":\n        x = _detrend(x, window, \"median\")\n        kind = _auto_kind(x)\n    elif algo == \"simple\":\n        kind = \"uniform\"\n    elif algo == \"gaussian\":\n        kind = \"gaussian\"\n    elif algo in (\"exp\", \"exponential\"):\n        kind = \"exponential\"\n    elif algo == \"median\":\n        kind = \"median\"\n    elif algo == \"triangular\":\n        kind = \"triangular\"\n    else:\n        kind = algo\n    return _smooth(x, window, kind, passes)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 23.5037, Type: Migrant)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef _kernel(w: int, kind: str) -> np.ndarray:\n    \"\"\"Return a normalized weighting kernel.\"\"\"\n    if kind == \"gaussian\":\n        sigma = w / 6.0\n        t = np.arange(w) - (w - 1) / 2\n        k = np.exp(-0.5 * (t / sigma) ** 2)\n    elif kind in (\"exponential\", \"exp\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:  # uniform fallback\n        k = np.ones(w)\n    return k / k.sum()\n\n\ndef _detrend(x: np.ndarray, w: int) -> np.ndarray:\n    \"\"\"Remove a moving\u2011average trend (same\u2011mode convolution).\"\"\"\n    if w > 0 and len(x) >= w:\n        return x - np.convolve(x, np.ones(w) / w, mode=\"same\")\n    return x\n\n\ndef _mad(x: np.ndarray) -> float:\n    \"\"\"Median absolute deviation \u2013 a robust spread estimator.\"\"\"\n    med = np.median(x)\n    return np.median(np.abs(x - med))\n\n\ndef _auto_kind(x: np.ndarray) -> str:\n    \"\"\"Choose kernel adaptively: low\u2011MAD \u2192 Gaussian, else exponential.\"\"\"\n    return \"gaussian\" if _mad(x) < 0.05 else \"exponential\"\n\n\ndef process_signal(\n    input_signal,\n    window_size: int = 20,\n    algorithm_type: str = \"enhanced\",\n    full: bool = False,\n):\n    \"\"\"\n    Smooth a 1\u2011D signal.\n\n    Parameters\n    ----------\n    input_signal : array\u2011like\n        Raw signal.\n    window_size : int, optional\n        Length of the smoothing kernel (default 20).\n    algorithm_type : str, optional\n        \"enhanced\" \u2013 detrend + adaptive kernel,\n        \"simple\"   \u2013 uniform moving average,\n        any other value is taken as a kernel kind\n        (e.g. \"gaussian\", \"exponential\", \"exp\").\n    full : bool, optional\n        If True, return a full\u2011length (``same``) output; otherwise ``valid``.\n\n    Returns\n    -------\n    np.ndarray\n        Filtered signal.\n    \"\"\"\n    if window_size <= 0:\n        raise ValueError(\"window_size must be a positive integer\")\n\n    x = np.asarray(input_signal, dtype=float)\n\n    if algorithm_type == \"enhanced\":\n        x = _detrend(x, window_size)\n        kind = _auto_kind(x)\n    elif algorithm_type == \"simple\":\n        kind = \"uniform\"\n    else:\n        kind = algorithm_type  # may be \"gaussian\", \"exp\", etc.\n\n    mode = \"same\" if full else \"valid\"\n    return np.convolve(x, _kernel(window_size, kind), mode=mode)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 2 (Score: 13.5069, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _weights(w, kind):\n    if kind == \"gaussian\":\n        sigma = w / 6.0\n        t = np.arange(w) - (w - 1) / 2\n        wts = np.exp(-0.5 * (t / sigma) ** 2)\n    elif kind == \"exponential\":\n        wts = np.exp(np.linspace(-2, 0, w))\n    elif kind == \"triangular\":\n        t = np.arange(w) - (w - 1) / 2\n        wts = 1 - np.abs(t) / ((w + 1) / 2)\n    else:  # uniform\n        wts = np.ones(w)\n    return wts / wts.sum()\n\ndef _smooth(x, w, kind):\n    if len(x) < w:\n        raise ValueError(\"Signal shorter than window\")\n    return np.convolve(x, _weights(w, kind), mode=\"valid\")\n\ndef _detrend_linear(x):\n    if len(x) < 2:\n        return x\n    t = np.arange(len(x))\n    m, c = np.linalg.lstsq(np.vstack([t, np.ones_like(t)]).T, x, rcond=None)[0]\n    return x - (m * t + c)\n\ndef process_signal(sig, window=20, algorithm=\"enhanced\", detrend=\"linear\"):\n    x = np.asarray(sig, dtype=float)\n    if detrend == \"linear\":\n        x = _detrend_linear(x)\n    kind = {\n        \"enhanced\": \"exponential\",\n        \"simple\": \"uniform\",\n        \"gaussian\": \"gaussian\",\n        \"exp\": \"exponential\",\n        \"triangular\": \"triangular\",\n    }.get(algorithm, algorithm)\n    return _smooth(x, int(window), kind)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n### Inspiration 3 (Score: 13.5069, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef _kernel(w, kind):\n    if kind == \"gaussian\":\n        s = w / 6.0\n        t = np.arange(w) - (w - 1) / 2\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind == \"exponential\":\n        k = np.exp(np.linspace(-2, 0, w))\n    else:  # uniform fallback\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _detrend(x, w, method):\n    if method == \"linear\" and len(x) > 1:\n        t = np.arange(len(x))\n        m, c = np.linalg.lstsq(np.vstack([t, np.ones_like(t)]).T, x, rcond=None)[0]\n        return x - (m * t + c)\n    if method == \"ma\" and w > 0:\n        return x - np.convolve(x, np.ones(w) / w, mode=\"same\")\n    return x\n\ndef process_signal(sig, window=20, algorithm=\"enhanced\", detrend=\"linear\"):\n    \"\"\"Smooth a 1\u2011D signal with optional detrending.\"\"\"\n    x = np.asarray(sig, dtype=float)\n    x = _detrend(x, window, detrend)\n\n    kind = {\n        \"enhanced\": \"exponential\",\n        \"simple\": \"uniform\",\n        \"gaussian\": \"gaussian\",\n        \"exp\": \"exponential\",\n    }.get(algorithm, algorithm)\n\n    wv = _kernel(window, kind)\n    return np.convolve(x, wv, mode=\"valid\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Excellent runs_successfully (1.000), Excellent output_length (91.000)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np, ast\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef _kernel(w, kind):\n    \"\"\"Return a normalized kernel.\n\n    ``kind`` may be:\n        - \"gaussian\"\n        - \"exponential\" / \"exp\"\n        - \"uniform\"\n        - a ``np.ndarray`` (custom kernel) \u2013 not cached\n    \"\"\"\n    if isinstance(kind, np.ndarray):\n        k = kind\n    elif kind == \"gaussian\":\n        s = w / 6.0\n        t = np.arange(w) - (w - 1) / 2\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind in (\"exponential\", \"exp\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _auto_kind(x, mad_thresh=0.05, var_thresh=0.5):\n    mad = np.median(np.abs(x - np.median(x)))\n    var = np.var(x)\n    return \"gaussian\" if (mad < mad_thresh and var < var_thresh) else \"exponential\"\n\ndef _detrend(x, w):\n    return x - np.convolve(x, np.ones(w) / w, mode=\"same\") if w and len(x) >= w else x\n\ndef process_signal(sig, win=20, alg=\"enhanced\", full=False):\n    \"\"\"Smooth a 1\u2011D signal.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    win : int, optional\n        Window length (>0).\n    alg : str, optional\n        \"enhanced\" \u2013 detrend + adaptive kernel,\n        \"simple\"   \u2013 uniform moving average,\n        \"custom:[...]\": literal list/array for a custom kernel,\n        any other string is taken as a kernel name.\n    full : bool, optional\n        Return full\u2011length output (mode ``same``) when True.\n    \"\"\"\n    if win <= 0:\n        raise ValueError(\"win must be positive\")\n    x = np.asarray(sig, float)\n\n    if alg == \"enhanced\":\n        x = _detrend(x, win)\n        kind = _auto_kind(x)\n    elif alg == \"simple\":\n        kind = \"uniform\"\n    elif alg.startswith(\"custom:\"):\n        try:\n            custom = np.asarray(ast.literal_eval(alg.split(\":\", 1)[1]), float)\n            if custom.shape != (win,):\n                raise ValueError\n            kind = custom\n        except Exception as e:\n            raise ValueError(f\"invalid custom kernel: {e}\")\n    else:\n        kind = alg\n\n    mode = \"same\" if full else \"valid\"\n    return np.convolve(x, _kernel(win, kind), mode=mode)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["import numpy as np\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef _kernel(w,k):\n    t=np.arange(w)-(w-1)/2\n    if k==\"gaussian\":s=w/6.;k=np.exp(-.5*(t/s)**2)\n    elif k in(\"exp\",\"exponential\"):k=np.exp(np.linspace(-2,0,w))\n    else:k=np.ones(w)\n    return k/k.sum()\n\ndef _mad(x):m=np.median(x);return np.median(np.abs(x-m))\n\ndef _auto_kind(x):return \"gaussian\" if _mad(x)<0.05 else \"exponential\"\n\ndef _median(x,w):\n    p=w//2;xv=np.pad(x,(p,p),mode=\"edge\")\n    return np.median(np.lib.stride_tricks.sliding_window_view(xv,w),axis=1)\n\ndef _smooth(x,w,k,n):\n    for _ in range(n):\n        if k==\"median\":x=_median(x,w)\n        else:x=np.convolve(x,_kernel(w,k),mode=\"same\")\n    return x\n\ndef process_signal(sig,win=20,alg=\"enhanced\",passes=1,full=False):\n    x=np.asarray(sig,float)\n    if alg==\"enhanced\":\n        x=x-np.convolve(x,np.ones(win)/win,mode=\"same\")\n        k=_auto_kind(x)\n    elif alg==\"robust\":\n        x=_median(x,win);k=_auto_kind(x)\n    elif alg==\"simple\":k=\"uniform\"\n    elif alg==\"gaussian\":k=\"gaussian\"\n    elif alg in(\"exp\",\"exponential\"):k=\"exponential\"\n    elif alg==\"median\":k=\"median\"\n    else:k=alg\n    y=_smooth(x,win,k,passes)\n    if not full and win>1:\n        half=win//2\n        return y[half:-(half)] if win%2 else y[half:-(half)]\n    return y"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}