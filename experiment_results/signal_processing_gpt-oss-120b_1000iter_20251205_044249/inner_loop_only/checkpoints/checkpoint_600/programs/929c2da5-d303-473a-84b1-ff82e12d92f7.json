{"id": "929c2da5-d303-473a-84b1-ff82e12d92f7", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _check_len(x, w):\n    if w <= 0:\n        raise ValueError(\"Window must be positive\")\n    if len(x) < w:\n        raise ValueError(f\"Signal length ({len(x)}) < window ({w})\")\n\ndef _exp_weights(w):\n    wts = np.exp(np.linspace(-2, 0, w))\n    return wts / wts.sum()\n\ndef _gauss_weights(w):\n    sigma = w / 6.0\n    t = np.arange(w) - (w - 1) / 2.0\n    wts = np.exp(-0.5 * (t / sigma) ** 2)\n    return wts / wts.sum()\n\ndef _detrend(x, w, method):\n    if method == \"median\":\n        v = np.lib.stride_tricks.sliding_window_view(x, w)\n        m = np.median(v, axis=1)\n        p = (len(x) - len(m)) // 2\n        return x - np.pad(m, (p, len(x) - len(m) - p), mode=\"edge\")\n    else:  # mean\n        return x - np.convolve(x, np.ones(w) / w, mode=\"same\")\n\ndef process_signal(sig, window=20, method=\"enhanced\", **kw):\n    x = np.asarray(sig, float)\n    m = method.lower()\n    if m in (\"basic\", \"ma\"):\n        _check_len(x, window)\n        return np.convolve(x, np.ones(window) / window, mode=\"valid\")\n    if m == \"median\":\n        _check_len(x, window)\n        v = np.lib.stride_tricks.sliding_window_view(x, window)\n        return np.median(v, axis=1)\n    if m in (\"enhanced\", \"robust\"):\n        _check_len(x, window)\n        detrend_method = \"mean\" if m == \"enhanced\" else \"median\"\n        x = _detrend(x, window, detrend_method)\n        kind = kw.get(\"kind\", \"exponential\")\n    else:\n        _check_len(x, window)\n        kind = {\"gaussian\": \"gaussian\", \"simple\": \"uniform\"}.get(m, m)\n    if kind == \"gaussian\":\n        return np.convolve(x, _gauss_weights(window), mode=\"valid\")\n    if kind in (\"exponential\", \"exp\"):\n        return np.convolve(x, _exp_weights(window), mode=\"valid\")\n    if kind == \"uniform\":\n        return np.convolve(x, np.ones(window) / window, mode=\"valid\")\n    raise ValueError(f\"Unsupported method: {method}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "eb22c1f8-5de5-4779-be99-98e3e0489e11", "generation": 5, "timestamp": 1764932352.134921, "iteration_found": 227, "metrics": {"runs_successfully": 1.0, "composite_score": 0.4128316457180309, "output_length": 91.0, "overall_score": 0.28798980114435524, "slope_changes": 155.0, "lag_error": 0.35539883377261255, "avg_error": 0.9565324748302244, "false_reversals": 124.2, "correlation": -0.006103226166624641, "noise_reduction": 0.0, "smoothness_score": 0.11428571428571428, "responsiveness_score": 0.7377902172282407, "accuracy_score": 0.0, "efficiency_score": 1.0, "execution_time": 0.0004200458526611328, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.4147238108898642, "output_length": 91.0, "overall_score": 0.3667365016552355, "slope_changes": 64.2, "lag_error": 1.0255240244901955, "avg_error": 1.3708262692399187, "false_reversals": 52.4, "correlation": 0.2667051952850475, "noise_reduction": 0.0, "smoothness_score": 0.23752969121140144, "responsiveness_score": 0.4936994021839312, "accuracy_score": 0.2667051952850475, "efficiency_score": 1.0, "execution_time": 0.0005632877349853515, "success_rate": 1.0}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 13.4402\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 23.5037 \u2192 13.4402. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4128, output_length: 91.0000, overall_score: 0.2880, slope_changes: 155.0000, lag_error: 0.3554, avg_error: 0.9565, false_reversals: 124.2000, correlation: -0.0061, noise_reduction: 0.0000, smoothness_score: 0.1143, responsiveness_score: 0.7378, accuracy_score: 0.0000, efficiency_score: 1.0000, execution_time: 0.0005, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4128, output_length: 91.0000, overall_score: 0.2880, slope_changes: 155.0000, lag_error: 0.3554, avg_error: 0.9565, false_reversals: 124.2000, correlation: -0.0061, noise_reduction: 0.0000, smoothness_score: 0.1143, responsiveness_score: 0.7378, accuracy_score: 0.0000, efficiency_score: 1.0000, execution_time: 0.0005, success_rate: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Evolve block rewrite (preserved external code)\n- Metrics: runs_successfully: 1.0000, composite_score: 0.4128, output_length: 91.0000, overall_score: 0.2880, slope_changes: 155.0000, lag_error: 0.3554, avg_error: 0.9565, false_reversals: 124.2000, correlation: -0.0061, noise_reduction: 0.0000, smoothness_score: 0.1143, responsiveness_score: 0.7378, accuracy_score: 0.0000, efficiency_score: 1.0000, execution_time: 0.0006, success_rate: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 23.5037)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _kernel(w, kind):\n    if kind == \"gaussian\":\n        s = w / 6.0\n        t = np.arange(w) - (w - 1) / 2\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind == \"exponential\":\n        k = np.exp(np.linspace(-2, 0, w))\n    else:\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _detrend(x, w, method):\n    if method == \"median\":\n        v = np.lib.stride_tricks.sliding_window_view(x, w)\n        m = np.median(v, axis=1)\n        p = (len(x) - len(m)) // 2\n        m = np.pad(m, (p, len(x) - len(m) - p), mode=\"edge\")\n    else:\n        m = np.convolve(x, np.ones(w) / w, mode=\"same\")\n    return x - m\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    x = np.asarray(sig, float)\n    if alg == \"enhanced\":\n        x = _detrend(x, w, \"mean\")\n        k = \"exponential\"\n    elif alg == \"robust\":\n        x = _detrend(x, w, \"median\")\n        k = \"exponential\"\n    elif alg == \"simple\":\n        k = \"uniform\"\n    elif alg == \"gaussian\":\n        k = \"gaussian\"\n    elif alg == \"median\":\n        v = np.lib.stride_tricks.sliding_window_view(x, w)\n        return np.median(v, axis=1)\n    else:\n        k = alg\n    return np.convolve(x, _kernel(w, k), mode=\"valid\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4128), Performs well on output_length (91.0000), Performs well on overall_score (0.2880), Performs well on slope_changes (155.0000), Performs well on lag_error (0.3554), Performs well on avg_error (0.9565), Performs well on false_reversals (124.2000), Performs well on correlation (-0.0061), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1143), Performs well on responsiveness_score (0.7378), Performs well on accuracy_score (0.0000), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0006), Performs well on success_rate (1.0000)\n\n### Program 2 (Score: 23.5037)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _check_len(x, w):\n    if len(x) < w:\n        raise ValueError(f\"Signal length ({len(x)}) < window ({w})\")\n\ndef _weights(w, kind):\n    if kind == \"gaussian\":\n        sigma = w / 6.0\n        t = np.arange(w) - (w - 1) / 2\n        wts = np.exp(-0.5 * (t / sigma) ** 2)\n    elif kind == \"exponential\":\n        wts = np.exp(np.linspace(-2, 0, w))\n    else:  # uniform or fallback\n        wts = np.ones(w)\n    return wts / wts.sum()\n\ndef _median_filter(x, w):\n    _check_len(x, w)\n    n = len(x) - w + 1\n    out = np.empty(n)\n    for i in range(n):\n        out[i] = np.median(x[i:i + w])\n    return out\n\ndef _smooth(x, w, kind):\n    _check_len(x, w)\n    if kind == \"median\":\n        return _median_filter(x, w)\n    return np.convolve(x, _weights(w, kind), mode=\"valid\")\n\ndef _detrend(x, tw, method=\"mean\"):\n    if tw <= 0 or len(x) < tw:\n        return x\n    if method == \"median\":\n        trend = _median_filter(x, tw)\n        # pad trend to original length (valid mode)\n        pad = (len(x) - len(trend)) // 2\n        trend = np.pad(trend, (pad, len(x) - len(trend) - pad), mode=\"edge\")\n    else:  # mean\n        trend = np.convolve(x, np.ones(tw) / tw, mode=\"same\")\n    return x - trend\n\ndef process_signal(\n    input_signal,\n    window_size=20,\n    algorithm_type=\"enhanced\",\n    detrend=False,\n    detrend_method=\"mean\",\n):\n    \"\"\"\n    Parameters\n    ----------\n    input_signal : array\u2011like\n        Raw 1\u2011D signal.\n    window_size : int, optional\n        Length of the smoothing window (default 20).\n    algorithm_type : str, optional\n        \"enhanced\" \u2013 mean detrend + exponential,\n        \"robust\"   \u2013 median detrend + exponential,\n        \"simple\"   \u2013 uniform moving average,\n        \"gaussian\" \u2013 Gaussian weighted average,\n        \"median\"   \u2013 median filter,\n        \"exp\"/\"exponential\" \u2013 exponential weighted average,\n        any other value is taken as a weighting kind.\n    detrend : bool, optional\n        If True, apply detrending before smoothing.\n    detrend_method : {\"mean\",\"median\"}, optional\n        Method used when ``detrend`` is True.\n\n    Returns\n    -------\n    np.ndarray\n        Filtered signal (valid part only).\n    \"\"\"\n    x = np.asarray(input_signal, dtype=float)\n\n    # Resolve algorithm type\n    if algorithm_type == \"enhanced\":\n        detrend, detrend_method, kind = True, \"mean\", \"exponential\"\n    elif algorithm_type == \"robust\":\n        detrend, detrend_method, kind = True, \"median\", \"exponential\"\n    elif algorithm_type == \"simple\":\n        kind = \"uniform\"\n    elif algorithm_type == \"gaussian\":\n        kind = \"gaussian\"\n    elif algorithm_type in (\"exp\", \"exponential\"):\n        kind = \"exponential\"\n    elif algorithm_type == \"median\":\n        kind = \"median\"\n    else:\n        kind = algorithm_type\n\n    if detrend:\n        x = _detrend(x, window_size, method=detrend_method)\n\n    return _smooth(x, window_size, kind)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4128), Performs well on output_length (91.0000), Performs well on overall_score (0.2880), Performs well on slope_changes (155.0000), Performs well on lag_error (0.3554), Performs well on avg_error (0.9565), Performs well on false_reversals (124.2000), Performs well on correlation (-0.0061), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1143), Performs well on responsiveness_score (0.7378), Performs well on accuracy_score (0.0000), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0005), Performs well on success_rate (1.0000)\n\n### Program 3 (Score: 23.5037)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _weights(w, k):\n    if k == \"gaussian\":\n        s = w / 6.0\n        t = np.arange(w) - (w - 1) / 2\n        wt = np.exp(-0.5 * (t / s) ** 2)\n    elif k == \"exponential\":\n        wt = np.exp(np.linspace(-2, 0, w))\n    else:\n        wt = np.ones(w)\n    return wt / wt.sum()\n\ndef _median(x, w):\n    v = np.lib.stride_tricks.sliding_window_view(x, w)\n    return np.median(v, axis=1)\n\ndef _detrend(x, w, method=\"mean\"):\n    if w <= 0 or len(x) < w:\n        return x\n    if method == \"median\":\n        m = _median(x, w)\n        p = (len(x) - len(m)) // 2\n        trend = np.pad(m, (p, len(x) - len(m) - p), mode=\"edge\")\n    else:\n        trend = np.convolve(x, np.ones(w) / w, mode=\"same\")\n    return x - trend\n\ndef process_signal(sig, window=20, alg=\"enhanced\", trend_w=None, trend_m=\"mean\"):\n    x = np.asarray(sig, float)\n    if trend_w is None:\n        trend_w = window\n    if alg == \"enhanced\":\n        x = _detrend(x, trend_w, \"mean\")\n        k = \"exponential\"\n    elif alg == \"robust\":\n        x = _detrend(x, trend_w, \"median\")\n        k = \"exponential\"\n    elif alg == \"simple\":\n        k = \"uniform\"\n    elif alg == \"gaussian\":\n        k = \"gaussian\"\n    elif alg in (\"exp\", \"exponential\"):\n        k = \"exponential\"\n    elif alg == \"median\":\n        return _median(x, window)\n    else:\n        k = alg\n    return np.convolve(x, _weights(window, k), mode=\"valid\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Performs well on runs_successfully (1.0000), Performs well on composite_score (0.4128), Performs well on output_length (91.0000), Performs well on overall_score (0.2880), Performs well on slope_changes (155.0000), Performs well on lag_error (0.3554), Performs well on avg_error (0.9565), Performs well on false_reversals (124.2000), Performs well on correlation (-0.0061), Performs well on noise_reduction (0.0000), Performs well on smoothness_score (0.1143), Performs well on responsiveness_score (0.7378), Performs well on accuracy_score (0.0000), Performs well on efficiency_score (1.0000), Performs well on execution_time (0.0005), Performs well on success_rate (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 14.0152)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _check_len(x, w):\n    if len(x) < w:\n        raise ValueError(f\"Signal length ({len(x)}) must be >= window ({w})\")\n\ndef _kernel(w, kind):\n    if kind == \"exp\":\n        k = np.exp(np.linspace(-2, 0, w))\n    elif kind == \"gauss\":\n        sigma = w / 6.0\n        t = np.arange(w) - (w - 1) / 2.0\n        k = np.exp(-0.5 * (t / sigma) ** 2)\n    else:  # basic uniform average\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _filter(x, w, kind):\n    _check_len(x, w)\n    return np.convolve(x, _kernel(w, kind), mode=\"valid\")\n\ndef process_signal(sig, w=20, algorithm_type=\"exp\"):\n    \"\"\"Apply selected smoothing filter to `sig`.\"\"\"\n    return _filter(sig, w, algorithm_type)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n### Program D2 (Score: 23.5037)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _weights(w, kind):\n    if kind == \"gaussian\":\n        sigma = w / 6.0\n        t = np.arange(w) - (w - 1) / 2\n        wts = np.exp(-0.5 * (t / sigma) ** 2)\n    elif kind == \"exponential\":\n        wts = np.exp(np.linspace(-2, 0, w))\n    else:\n        wts = np.ones(w)\n    return wts / wts.sum()\n\ndef _median_filter(x, w):\n    if len(x) < w:\n        raise ValueError(\"Signal shorter than window\")\n    n = len(x) - w + 1\n    out = np.empty(n, dtype=float)\n    for i in range(n):\n        out[i] = np.median(x[i:i + w])\n    return out\n\ndef _detrend(x, tw, method=\"mean\"):\n    if tw <= 0 or len(x) < tw:\n        return x\n    if method == \"median\":\n        trend = _median_filter(x, tw)\n        pad = (len(x) - len(trend)) // 2\n        trend = np.pad(trend, (pad, len(x) - len(trend) - pad), mode=\"edge\")\n    else:\n        trend = np.convolve(x, np.ones(tw) / tw, mode=\"same\")\n    return x - trend\n\ndef process_signal(sig, w=20, alg=\"enhanced\"):\n    x = np.asarray(sig, float)\n    if alg == \"enhanced\":\n        x = _detrend(x, w, method=\"mean\")\n        kind = \"exponential\"\n    elif alg == \"robust\":\n        x = _detrend(x, w, method=\"median\")\n        kind = \"exponential\"\n    elif alg == \"simple\":\n        kind = \"uniform\"\n    elif alg == \"gaussian\":\n        kind = \"gaussian\"\n    elif alg in (\"exp\", \"exponential\"):\n        kind = \"exponential\"\n    elif alg == \"median\":\n        kind = \"median\"\n    else:\n        kind = alg\n\n    if kind == \"median\":\n        return _median_filter(x, w)\n    return np.convolve(x, _weights(w, kind), mode=\"valid\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nKey features: Alternative approach to runs_successfully, Alternative approach to composite_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\ndef _chk(x, w):\n    if len(x) < w:\n        raise ValueError(\"Signal length must be >= window size\")\n\ndef _exp_w(w):\n    wts = np.exp(np.linspace(-2, 0, w))\n    return wts / wts.sum()\n\ndef _conv(x, w, k):\n    _chk(x, w)\n    return np.convolve(x, k, mode=\"valid\")\n\ndef _weighted(x, w):\n    return _conv(x, w, _exp_w(w))\n\ndef _median(x, w):\n    _chk(x, w)\n    shape = (len(x) - w + 1, w)\n    strides = (x.strides[0], x.strides[0])\n    win = np.lib.stride_tricks.as_strided(x, shape=shape, strides=strides)\n    return np.median(win, axis=1)\n\ndef _ema(x, w):\n    _chk(x, w)\n    a = 2.0 / (w + 1)\n    y = np.empty_like(x, dtype=float)\n    y[0] = x[0]\n    for i in range(1, len(x)):\n        y[i] = a * x[i] + (1 - a) * y[i - 1]\n    return y[w - 1 :]\n\ndef process_signal(sig, w=20, algo=\"enhanced\"):\n    sig = np.asarray(sig, dtype=float)\n    if algo in (\"enhanced\", \"weighted\"):\n        return _weighted(sig, w)\n    if algo == \"basic\":\n        return _conv(sig, w, np.ones(w) / w)\n    if algo == \"median\":\n        return _median(sig, w)\n    if algo == \"ema\":\n        return _ema(sig, w)\n    raise ValueError(f\"Unsupported algorithm_type: {algo}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Alternative runs_successfully approach, NumPy-based implementation\n\n### Inspiration 2 (Score: 13.7277, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nReal-Time Adaptive Signal Processing Algorithm for Non-Stationary Time Series\n\nThis algorithm implements a sliding window approach to filter volatile, non-stationary\ntime series data while minimizing noise and preserving signal dynamics.\n\"\"\"\nimport numpy as np\nfrom scipy import signal\nfrom collections import deque\n\n\ndef adaptive_filter(x, window_size=20):\n    \"\"\"\n    Adaptive signal processing algorithm using sliding window approach.\n\n    Args:\n        x: Input signal (1D array of real-valued samples)\n        window_size: Size of the sliding window (W samples)\n\n    Returns:\n        y: Filtered output signal with length = len(x) - window_size + 1\n    \"\"\"\n    if len(x) < window_size:\n        raise ValueError(f\"Input signal length ({len(x)}) must be >= window_size ({window_size})\")\n\n    # Initialize output array\n    output_length = len(x) - window_size + 1\n    y = np.zeros(output_length)\n\n    # Simple moving average as baseline\n    for i in range(output_length):\n        window = x[i : i + window_size]\n\n        # Basic moving average filter\n        y[i] = np.mean(window)\n\n    return y\n\n\ndef enhanced_filter_with_trend_preservation(x, window_size=20):\n    \"\"\"\n    Enhanced version with trend preservation using weighted moving average.\n\n    Args:\n        x: Input signal (1D array of real-valued samples)\n        window_size: Size of the sliding window\n\n    Returns:\n        y: Filtered output signal\n    \"\"\"\n    if len(x) < window_size:\n        raise ValueError(f\"Input signal length ({len(x)}) must be >= window_size ({window_size})\")\n\n    output_length = len(x) - window_size + 1\n    y = np.zeros(output_length)\n\n    # Create weights that emphasize recent samples\n    weights = np.exp(np.linspace(-2, 0, window_size))\n    weights = weights / np.sum(weights)\n\n    for i in range(output_length):\n        window = x[i : i + window_size]\n\n        # Weighted moving average with exponential weights\n        y[i] = np.sum(window * weights)\n\n    return y\n\n\ndef process_signal(input_signal, window_size=20, algorithm_type=\"enhanced\"):\n    \"\"\"\n    Main signal processing function that applies the selected algorithm.\n\n    Args:\n        input_signal: Input time series data\n        window_size: Window size for processing\n        algorithm_type: Type of algorithm to use (\"basic\" or \"enhanced\")\n\n    Returns:\n        Filtered signal\n    \"\"\"\n    if algorithm_type == \"enhanced\":\n        return enhanced_filter_with_trend_preservation(input_signal, window_size)\n    else:\n        return adaptive_filter(input_signal, window_size)\n\n\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Excellent runs_successfully (1.000), Excellent output_length (91.000), Excellent slope_changes (66.000)\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _validate_len(x, w):\n    if len(x) < w:\n        raise ValueError(f\"Signal length ({len(x)}) must be >= window ({w})\")\n\ndef _exp_kernel(w):\n    k = np.exp(np.linspace(-2, 0, w))\n    return k / k.sum()\n\ndef _gauss_kernel(w):\n    sigma = w / 6.0\n    t = np.arange(w) - (w - 1) / 2.0\n    k = np.exp(-0.5 * (t / sigma) ** 2)\n    return k / k.sum()\n\ndef _uniform_kernel(w):\n    return np.ones(w) / w\n\ndef _convolve(x, w, kind):\n    _validate_len(x, w)\n    if kind == \"exp\":\n        kernel = _exp_kernel(w)\n    elif kind == \"gauss\":\n        kernel = _gauss_kernel(w)\n    else:\n        kernel = _uniform_kernel(w)\n    return np.convolve(x, kernel, mode=\"valid\")\n\ndef _ema_recursive(x, alpha):\n    if not 0 < alpha <= 1:\n        raise ValueError(\"Alpha must be in (0, 1]\")\n    ema = np.empty_like(x, dtype=float)\n    ema[0] = x[0]\n    for i in range(1, len(x)):\n        ema[i] = alpha * x[i] + (1 - alpha) * ema[i - 1]\n    return ema\n\ndef process_signal(signal, *, window=20, method=\"enhanced\", **kwargs):\n    \"\"\"\n    Filter a 1\u2011D signal.\n\n    Parameters\n    ----------\n    signal : array\u2011like\n    window : int, default 20\n    method : {\"basic\",\"ma\",\"exp\",\"gauss\",\"enhanced\",\"ema\",\"recursive\"}\n    **kwargs\n        - alpha : float for EMA (default 2/(window+1))\n        - kernel : str for convolution kernel (exp, gauss, basic)\n\n    Returns\n    -------\n    np.ndarray\n        Length = len(signal)-window+1 for convolution methods,\n        same length for EMA.\n    \"\"\"\n    sig = np.asarray(signal, dtype=float)\n    m = method.lower()\n\n    if m in (\"basic\", \"ma\"):\n        return _convolve(sig, window, \"basic\")\n    if m in (\"exp\", \"exponential\"):\n        return _convolve(sig, window, \"exp\")\n    if m in (\"gauss\", \"gaussian\"):\n        return _convolve(sig, window, \"gauss\")\n    if m in (\"enhanced\", \"weighted\"):\n        kind = kwargs.get(\"kernel\", \"exp\")\n        return _convolve(sig, window, kind)\n    if m in (\"ema\", \"recursive\"):\n        alpha = kwargs.get(\"alpha\", 2.0 / (window + 1))\n        return _ema_recursive(sig, alpha)\n\n    raise ValueError(f\"Unsupported method: {method}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\nUnique approach: Modification: Evolve block rewrite (preserved external code), Alternative runs_successfully approach, NumPy-based implementation\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef _check_len(x, w):\n    if w <= 0:\n        raise ValueError(\"Window must be positive\")\n    if len(x) < w:\n        raise ValueError(f\"Signal length ({len(x)}) must be >= window ({w})\")\n\ndef _exp_weights(w):\n    wts = np.exp(np.linspace(-2, 0, w))\n    return wts / wts.sum()\n\ndef _gauss_weights(w):\n    sigma = w / 6.0\n    t = np.arange(w) - (w - 1) / 2.0\n    wts = np.exp(-0.5 * (t / sigma) ** 2)\n    return wts / wts.sum()\n\ndef process_signal(signal, window=20, method=\"enhanced\", **kwargs):\n    sig = np.asarray(signal, dtype=float)\n    m = method.lower()\n\n    if m in (\"basic\", \"ma\"):\n        _check_len(sig, window)\n        return np.convolve(sig, np.ones(window) / window, mode=\"valid\")\n\n    if m in (\"enhanced\", \"weighted\", \"exp\", \"exponential\"):\n        _check_len(sig, window)\n        return np.convolve(sig, _exp_weights(window), mode=\"valid\")\n\n    if m in (\"gauss\", \"gaussian\"):\n        _check_len(sig, window)\n        return np.convolve(sig, _gauss_weights(window), mode=\"valid\")\n\n    if m == \"ema\":\n        _check_len(sig, window)\n        alpha = kwargs.get(\"alpha\", 2.0 / (window + 1))\n        if not (0 < alpha <= 1):\n            raise ValueError(\"Alpha must be in (0, 1]\")\n        ema = np.empty_like(sig)\n        ema[0] = sig[0]\n        for i in range(1, len(sig)):\n            ema[i] = alpha * sig[i] + (1 - alpha) * ema[i - 1]\n        return ema\n\n    raise ValueError(f\"Unsupported method: {method}\")\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n\n```\n\n# Task\nImprove the code to maximize FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\n\n## CRITICAL INSTRUCTIONS\nIf the code contains `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers:\n- Output ONLY the code that goes BETWEEN these markers\n- Do NOT include the markers themselves\n- Do NOT include code outside the markers (like `run_packing()`)\n- The system will automatically merge your output with the preserved sections\n\nIf there are NO EVOLVE-BLOCK markers:\n- Output the complete rewritten program\n\n```python\n# Your improved code here (ONLY the evolve block content if markers exist)\n```", "responses": ["import numpy as np\n\ndef _check_len(x, w):\n    if w <= 0:\n        raise ValueError(\"Window must be positive\")\n    if len(x) < w:\n        raise ValueError(f\"Signal length ({len(x)}) < window ({w})\")\n\ndef _exp_weights(w):\n    wts = np.exp(np.linspace(-2, 0, w))\n    return wts / wts.sum()\n\ndef _gauss_weights(w):\n    sigma = w / 6.0\n    t = np.arange(w) - (w - 1) / 2.0\n    wts = np.exp(-0.5 * (t / sigma) ** 2)\n    return wts / wts.sum()\n\ndef _detrend(x, w, method):\n    if method == \"median\":\n        v = np.lib.stride_tricks.sliding_window_view(x, w)\n        m = np.median(v, axis=1)\n        p = (len(x) - len(m)) // 2\n        return x - np.pad(m, (p, len(x) - len(m) - p), mode=\"edge\")\n    else:  # mean\n        return x - np.convolve(x, np.ones(w) / w, mode=\"same\")\n\ndef process_signal(sig, window=20, method=\"enhanced\", **kw):\n    x = np.asarray(sig, float)\n    m = method.lower()\n    if m in (\"basic\", \"ma\"):\n        _check_len(x, window)\n        return np.convolve(x, np.ones(window) / window, mode=\"valid\")\n    if m == \"median\":\n        _check_len(x, window)\n        v = np.lib.stride_tricks.sliding_window_view(x, window)\n        return np.median(v, axis=1)\n    if m in (\"enhanced\", \"robust\"):\n        _check_len(x, window)\n        detrend_method = \"mean\" if m == \"enhanced\" else \"median\"\n        x = _detrend(x, window, detrend_method)\n        kind = kw.get(\"kind\", \"exponential\")\n    else:\n        _check_len(x, window)\n        kind = {\"gaussian\": \"gaussian\", \"simple\": \"uniform\"}.get(m, m)\n    if kind == \"gaussian\":\n        return np.convolve(x, _gauss_weights(window), mode=\"valid\")\n    if kind in (\"exponential\", \"exp\"):\n        return np.convolve(x, _exp_weights(window), mode=\"valid\")\n    if kind == \"uniform\":\n        return np.convolve(x, np.ones(window) / window, mode=\"valid\")\n    raise ValueError(f\"Unsupported method: {method}\")"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}