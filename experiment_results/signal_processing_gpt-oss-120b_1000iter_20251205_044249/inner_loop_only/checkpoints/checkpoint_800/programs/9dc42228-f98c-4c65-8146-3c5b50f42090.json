{"id": "9dc42228-f98c-4c65-8146-3c5b50f42090", "code": "# EVOLVE-BLOCK-START\nimport numpy as np\nfrom functools import lru_cache\nimport ast\n\n@lru_cache(maxsize=None)\ndef _kernel(w, kind):\n    \"\"\"Return a normalized kernel.\n\n    ``kind`` may be:\n        - \"gaussian\"\n        - \"exponential\" / \"exp\"\n        - \"uniform\"\n        - an ``np.ndarray`` of length ``w`` (custom kernel)\n    \"\"\"\n    if isinstance(kind, np.ndarray):\n        k = kind\n        if k.shape != (w,):\n            raise ValueError(\"custom kernel length must equal window size\")\n    elif kind == \"gaussian\":\n        s = w / 6.0\n        t = np.arange(w) - (w - 1) / 2\n        k = np.exp(-0.5 * (t / s) ** 2)\n    elif kind in (\"exponential\", \"exp\"):\n        k = np.exp(np.linspace(-2, 0, w))\n    elif kind == \"uniform\":\n        k = np.ones(w)\n    else:\n        # fallback to uniform for unknown strings\n        k = np.ones(w)\n    return k / k.sum()\n\ndef _auto_kind(x, thresh=0.05):\n    \"\"\"Choose kernel based on signal variability.\"\"\"\n    mad = np.median(np.abs(x - np.median(x)))\n    var = np.var(x)\n    # Prefer Gaussian when signal is both low\u2011MAD and low\u2011variance\n    return \"gaussian\" if (mad < thresh and var < 0.5) else \"exponential\"\n\ndef process_signal(sig, win=20, alg=\"enhanced\", full=False, thresh=0.05):\n    \"\"\"Smooth ``sig`` using a configurable kernel.\n\n    Parameters\n    ----------\n    sig : array\u2011like\n        Input signal.\n    win : int, optional\n        Window size (must be > 0).\n    alg : str, optional\n        - \"enhanced\" : detrend + automatic kernel selection.\n        - \"simple\"   : uniform moving average.\n        - \"custom:[...]\": a literal list/array defining a custom kernel.\n        - any other string is taken as a kernel name.\n    full : bool, optional\n        Return full\u2011length output (mode ``same``) when True.\n    thresh : float, optional\n        MAD threshold used by the automatic kernel selector.\n    \"\"\"\n    if win <= 0:\n        raise ValueError(\"win must be a positive integer\")\n    x = np.asarray(sig, float)\n\n    if alg == \"enhanced\":\n        if len(x) >= win:\n            x = x - np.convolve(x, np.ones(win) / win, mode=\"same\")\n        kind = _auto_kind(x, thresh)\n    elif alg == \"simple\":\n        kind = \"uniform\"\n    elif alg.startswith(\"custom:\"):\n        # e.g. \"custom:[0.1,0.2,0.4,0.2,0.1]\"\n        try:\n            custom = np.asarray(ast.literal_eval(alg.split(\":\", 1)[1]), float)\n        except Exception as e:\n            raise ValueError(f\"invalid custom kernel spec: {e}\")\n        kind = custom\n    else:\n        kind = alg\n\n    mode = \"same\" if full else \"valid\"\n    return np.convolve(x, _kernel(win, kind), mode=mode)\n# EVOLVE-BLOCK-END\n\n\ndef generate_test_signal(length=1000, noise_level=0.3, seed=42):\n    \"\"\"\n    Generate synthetic test signal with known characteristics.\n\n    Args:\n        length: Length of the signal\n        noise_level: Standard deviation of noise to add\n        seed: Random seed for reproducibility\n\n    Returns:\n        Tuple of (noisy_signal, clean_signal)\n    \"\"\"\n    np.random.seed(seed)\n    t = np.linspace(0, 10, length)\n\n    # Create a complex signal with multiple components\n    clean_signal = (\n        2 * np.sin(2 * np.pi * 0.5 * t)  # Low frequency component\n        + 1.5 * np.sin(2 * np.pi * 2 * t)  # Medium frequency component\n        + 0.5 * np.sin(2 * np.pi * 5 * t)  # Higher frequency component\n        + 0.8 * np.exp(-t / 5) * np.sin(2 * np.pi * 1.5 * t)  # Decaying oscillation\n    )\n\n    # Add non-stationary behavior\n    trend = 0.1 * t * np.sin(0.2 * t)  # Slowly varying trend\n    clean_signal += trend\n\n    # Add random walk component for non-stationarity\n    random_walk = np.cumsum(np.random.randn(length) * 0.05)\n    clean_signal += random_walk\n\n    # Add noise\n    noise = np.random.normal(0, noise_level, length)\n    noisy_signal = clean_signal + noise\n\n    return noisy_signal, clean_signal\n\n\ndef run_signal_processing(signal_length=1000, noise_level=0.3, window_size=20):\n    \"\"\"\n    Run the signal processing algorithm on a test signal.\n\n    Returns:\n        Dictionary containing results and metrics\n    \"\"\"\n    # Generate test signal\n    noisy_signal, clean_signal = generate_test_signal(signal_length, noise_level)\n\n    # Process the signal\n    filtered_signal = process_signal(noisy_signal, window_size, \"enhanced\")\n\n    # Calculate basic metrics\n    if len(filtered_signal) > 0:\n        # Align signals for comparison (account for processing delay)\n        delay = window_size - 1\n        aligned_clean = clean_signal[delay:]\n        aligned_noisy = noisy_signal[delay:]\n\n        # Ensure same length\n        min_length = min(len(filtered_signal), len(aligned_clean))\n        filtered_signal = filtered_signal[:min_length]\n        aligned_clean = aligned_clean[:min_length]\n        aligned_noisy = aligned_noisy[:min_length]\n\n        # Calculate correlation with clean signal\n        correlation = np.corrcoef(filtered_signal, aligned_clean)[0, 1] if min_length > 1 else 0\n\n        # Calculate noise reduction\n        noise_before = np.var(aligned_noisy - aligned_clean)\n        noise_after = np.var(filtered_signal - aligned_clean)\n        noise_reduction = (noise_before - noise_after) / noise_before if noise_before > 0 else 0\n\n        return {\n            \"filtered_signal\": filtered_signal,\n            \"clean_signal\": aligned_clean,\n            \"noisy_signal\": aligned_noisy,\n            \"correlation\": correlation,\n            \"noise_reduction\": noise_reduction,\n            \"signal_length\": min_length,\n        }\n    else:\n        return {\n            \"filtered_signal\": [],\n            \"clean_signal\": [],\n            \"noisy_signal\": [],\n            \"correlation\": 0,\n            \"noise_reduction\": 0,\n            \"signal_length\": 0,\n        }\n\n\nif __name__ == \"__main__\":\n    # Test the algorithm\n    results = run_signal_processing()\n    print(f\"Signal processing completed!\")\n    print(f\"Correlation with clean signal: {results['correlation']:.3f}\")\n    print(f\"Noise reduction: {results['noise_reduction']:.3f}\")\n    print(f\"Processed signal length: {results['signal_length']}\")\n", "language": "python", "parent_id": "f2e56da9-5178-4547-82aa-0149a734f6c7", "generation": 7, "timestamp": 1764933287.2411351, "iteration_found": 0, "metrics": {"runs_successfully": 1.0, "composite_score": 0.4128316457180309, "output_length": 91.0, "overall_score": 0.28798980114435524, "slope_changes": 155.0, "lag_error": 0.35539883377261255, "avg_error": 0.9565324748302244, "false_reversals": 124.2, "correlation": -0.006103226166624641, "noise_reduction": 0.0, "smoothness_score": 0.11428571428571428, "responsiveness_score": 0.7377902172282407, "accuracy_score": 0.0, "efficiency_score": 1.0, "execution_time": 0.0007441520690917968, "success_rate": 1.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Evolve block rewrite (preserved external code)", "parent_metrics": {"runs_successfully": 1.0, "composite_score": 0.4128316457180309, "output_length": 91.0, "overall_score": 0.28798980114435524, "slope_changes": 155.0, "lag_error": 0.35539883377261255, "avg_error": 0.9565324748302244, "false_reversals": 124.2, "correlation": -0.006103226166624641, "noise_reduction": 0.0, "smoothness_score": 0.11428571428571428, "responsiveness_score": 0.7377902172282407, "accuracy_score": 0.0, "efficiency_score": 1.0, "execution_time": 0.0006289958953857421, "success_rate": 1.0}, "island": 4, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}