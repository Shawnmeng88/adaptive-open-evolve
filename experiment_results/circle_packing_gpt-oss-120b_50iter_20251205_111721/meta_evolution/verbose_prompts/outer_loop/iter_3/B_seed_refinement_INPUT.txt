# Prompt Type: B
# Outer Iteration: 3
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 3
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 5324 chars
- Current best prompt length: 3513 chars

## Convergence History:
### Successful Patterns:
- Change that helped: condensed by 191 chars
- Change that helped: removed 'must'; condensed by 522 chars
- Negative guidance (what to avoid) helped
- Explicit constraint mentions helped

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9609
- Valid: 8, Invalid: 2
- Failure modes: ['Validity failures: 2/10 (20.0%)']

## CODE ANALYSIS (NEW - What Actually Happened):
## Code Analysis from Recent Iterations

### Approaches Tried:
  ✓ grid_based: 14 attempts
  ✓ iterative_refinement: 14 attempts
  ✓ linear_programming: 12 attempts
  ✓ random_search: 10 attempts
  ✓ constraint_solving: 10 attempts
  ✓ greedy: 2 attempts

### Best Performing Approach: linear_programming
Key techniques in best code:
  - LP for radius optimization
  - pairwise distance constraints
  - boundary constraint handling
  - value clipping for safety
  - safety margins for numerical stability

### What Led to Improvements:
  - Iter 9: +0.0406 using linear_programming, grid_based
  - Iter 12: +0.0336 using linear_programming, grid_based
  - Iter 25: +0.0156 using linear_programming, grid_based

### Common Failures:
  - other_runtime_error: 2 occurrences
  - undefined_variable: 1 occurrences

### Recommendations for Next Prompt:
  - BUILD ON: linear_programming has been successful - refine and extend this approach
  - FIX: Missing overlap checking in code
  - KEEP: Best improvement used: LP for radius optimization, pairwise distance constraints, boundary constraint handling

# ============================================
# FINAL REFINED PROMPT (seed_prompt_3):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Message – Instructions for Evolving the Packing Code**

You may edit **only** the functions that lie between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers. All other code (imports, `run_packing()`, visualisation, etc.) is fixed and will be merged automatically.

### Primary Goal
Maximise the total sum of radii for the 26‑circle packing **while guaranteeing full validity** (`validity = 1.0`). Any overlap between circles or any circle crossing the unit‑square boundary makes the solution unacceptable.

### What to Keep / Build Upon
1. **Linear‑Programming radius optimisation** – retain the LP formulation that:
   * Maximises `∑ r_i`.
   * Constrains each radius to be ≤ the distance from its centre to each of the four square edges.
   * Enforces pairwise non‑overlap: `r_i + r_j ≤ distance(centre_i, centre_j)`.
   * Uses a tiny safety margin (e.g., `1e‑9`) on every inequality to avoid numerical edge‑cases.
2. **Deterministic or random layout generation** – you may keep the existing deterministic layout as a fallback and the random‑layout generator for diversity.
3. **Local search / refinement** – if you add a refinement step, it must respect the same constraints and never increase a radius beyond the LP‑computed bound.

### Mandatory Behaviour
* After the LP solution, **verify** that all constraints are satisfied (including the safety margin). If any violation is detected, fall back to a safe configuration (e.g., the deterministic layout) rather than returning an invalid packing.
* The function `construct_packing()` must return a tuple `(centers, radii, validity)` where `validity` is exactly `1.0` for a valid packing and `0.0` otherwise.
* Do **not** introduce new imports that are not already available in the surrounding code. Use only `numpy`, `scipy.optimize.linprog`, and the standard library.

### What to Avoid (based on previous failures)
* **Missing overlap checks** – every pair of circles must be checked after any modification.
* **Undefined variables or name‑resolution errors** – ensure all helper functions are defined before they are used and that all variable names are consistent.
* **Runtime errors due to shape mismatches** – keep array dimensions consistent; use `.reshape(-1, 2)` only when appropriate.
* **Uncontrolled random walks that can diverge** – if you use random perturbations, limit the number of iterations and clamp changes to stay within the feasible region.

### Implementation Guidance
* Keep the LP construction simple and robust: build the `A_ub` matrix and `b_ub` vector once, then call `linprog` with method `"highs"` (or the default) and `bounds=(0, None)` for each radius.
* After solving, clip radii with `np.clip(radii, 0, max_possible)` where `max_possible` is the minimum distance to the square edges for each centre.
* Optionally, run a short deterministic local improvement that tries to shift a centre slightly (by at most `1e‑3`) if doing so allows a marginal radius increase without breaking any constraint.

### Output Requirements (CRITICAL)
* **Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.**
* **Do NOT include the markers themselves** in your response.
* **Do NOT include any code outside the markers** (imports, `run_packing()`, etc.).
* The system will automatically merge your output with the preserved surrounding code.

Follow these instructions precisely to produce a valid, higher‑scoring packing solution.
