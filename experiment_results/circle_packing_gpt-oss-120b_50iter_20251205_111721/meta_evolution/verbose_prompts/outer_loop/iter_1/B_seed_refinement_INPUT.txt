# Prompt Type: B
# Outer Iteration: 1
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 1
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 4492 chars
- Current best prompt length: 4226 chars

## Convergence History:
### Successful Patterns:
- Negative guidance (what to avoid) helped
- Explicit constraint mentions helped

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9095
- Valid: 10, Invalid: 3
- Failure modes: ['Validity failures: 3/13 (23.1%)']

## CODE ANALYSIS (NEW - What Actually Happened):
## Code Analysis from Recent Iterations

### Approaches Tried:
  ✓ grid_based: 7 attempts
  ✓ iterative_refinement: 7 attempts
  ✓ linear_programming: 5 attempts
  ✓ constraint_solving: 5 attempts
  ✓ random_search: 4 attempts

### Best Performing Approach: linear_programming
Key techniques in best code:
  - LP for radius optimization
  - pairwise distance constraints
  - boundary constraint handling
  - position perturbation
  - value clipping for safety

### What Led to Improvements:
  - Iter 0: +0.3642 using grid_based, iterative_refinement
  - Iter 1: +0.5046 using linear_programming, grid_based
  - Iter 9: +0.0406 using linear_programming, grid_based

### Common Failures:
  - other_runtime_error: 2 occurrences

### Recommendations for Next Prompt:
  - BUILD ON: linear_programming has been successful - refine and extend this approach
  - KEEP: Best improvement used: LP for radius optimization, pairwise distance constraints, boundary constraint handling

# ============================================
# FINAL REFINED PROMPT (seed_prompt_1):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**System Message – Instructions for Evolving the Packing Code**

You are to improve **only** the functions inside the `# EVOLVE-BLOCK-START` / `# EVOLVE-BLOCK-END` region, chiefly `construct_packing()` and any helper routines it uses. The rest of the file (imports, `run_packing()`, visualization, etc.) is fixed and will be merged automatically.

### Primary Goal
- **Maximize the combined score** (sum of radii) for the 26‑circle packing **while keeping the solution fully valid** (`validity = 1.0`).  
- A solution that violates the unit‑square borders or creates overlapping circles is unacceptable.

### What Worked – Keep and Extend
1. **Linear‑Programming Radius Optimization**  
   - Formulate a linear program that maximizes the sum of radii subject to:  
     * `r_i ≤ distance from centre_i to each of the four square edges`  
     * `r_i + r_j ≤ Euclidean distance between centre_i and centre_j` for every pair `i < j`.  
   - Use `scipy.optimize.linprog` (or an equivalent LP solver) with the **high‑precision** method (`method='highs'` is recommended).  
   - After solving, **clip** any negative radii to zero and enforce the border limits again for safety.

2. **Robust Pairwise Distance Handling**  
   - Pre‑compute a symmetric matrix of centre‑to‑centre distances once; reuse it in the LP constraints.  
   - Guard against numerical noise by adding a tiny epsilon (e.g., `1e-9`) to the right‑hand side of each inequality.

3. **Boundary Constraint Calculation**  
   - For each centre `(x, y)`, compute `border_i = min(x, 1‑x, y, 1‑y)`.  
   - Use these values directly as upper bounds for the corresponding radius variable.

4. **Post‑Processing Safety Checks**  
   - After the LP solution, verify all constraints (border and pairwise) and, if any violation exceeds `1e‑8`, reduce the offending radii proportionally until the packing is feasible.

### What Failed – Must NOT Use
- **Pure random‑search or exhaustive grid search** for radii – these cause runtime errors and give poor scores.  
- **Iterative heuristic adjustments without a formal feasibility guarantee** (e.g., ad‑hoc shrinking loops) – they frequently produce invalid packings.  
- **Heavy‑weight symbolic or constraint‑solving libraries** that were previously tried and led to crashes.  

### Implementation Guidelines
- **Do not add new imports** outside the evolve block; you may use only the modules already imported at the top of the file (`numpy`, `scipy.optimize`, etc.).  
- **Do not modify the function signatures** of `construct_packing()` or its helpers.  
- **Preserve the existing data structures** (e.g., the `centers` array passed to `construct_packing`).  
- Keep the code **readable and well‑commented**: explain each step of the LP formulation and the post‑processing safety clamp.  
- **Maintain deterministic output**: avoid any stochastic elements (no `np.random` calls) inside the evolve block.

### Output Formatting (Critical)
- **Return ONLY the Python code that belongs between the markers** `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`.  
- **Do NOT include the markers themselves** or any surrounding code.  
- **Do NOT output any explanatory text, markdown, or additional comments outside the code block**.  

Your task is to rewrite the target functions following the successful linear‑programming strategy while adhering strictly to the constraints above.
