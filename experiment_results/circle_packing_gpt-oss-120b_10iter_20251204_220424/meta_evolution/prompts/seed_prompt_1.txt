## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include any code outside the markers (imports, run_packing, etc.)
- The system will automatically merge your output with the preserved code sections

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions within the evolve block
- Functions like `run_packing()` are preserved automatically - do not include them

Violating these requirements will cause the program to fail evaluation.

---

**SYSTEM MESSAGE â€“ EVOLUTION BLOCK GUIDELINES**

You are tasked with improving **only** the functions inside the `# EVOLVE-BLOCK-START` â€¦ `# EVOLVE-BLOCK-END` region, specifically `construct_packing()` and any helper functions defined there. The rest of the program (imports, `run_packing()`, visualization, etc.) is fixed and will be merged automatically.

---

### âœ… REQUIRED OUTPUT FORMAT (CRITICAL)
- **Output ONLY the Python source code that belongs *between* the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.**
- **Do NOT include the marker comments themselves.**
- **Do NOT include any other code** (imports, `run_packing()`, etc.).
- The system will splice your output into the existing file; any deviation will cause a runtime error.

---

### ðŸŽ¯ OBJECTIVE
- **Maximize the combined score** (proportional to the sum of radii) for a packing of **26 circles** inside the unit square.
- **Validity must be 1.0**: every circle fully inside `[0,1]Ã—[0,1]` and no pair of circles overlaps (distance â‰¥ sum of radii).

---

### ðŸš« WHAT TO AVOID (FAILED APPROACHES)
1. **Random placement without refinement** â€“ leads to many invalid packings.
2. **Ignoring the square boundary** â€“ circles may extend outside the unit square.
3. **Only local adjustments** that cannot escape a poor initial layout (e.g., singleâ€‘step gradient descent from a random start).
4. **Hardâ€‘coding a single geometry** that works for a subset of seeds but fails on others.
5. **Using nonâ€‘deterministic global optimizers that do not guarantee feasibility** (e.g., `differential_evolution` without explicit constraints).
6. **Returning radii that violate pairwise distance constraints** â€“ the evaluator will set `validity = 0`.

---

### ðŸ’¡ SUGGESTED STRATEGIES (CONCRETE & DOMAINâ€‘SPECIFIC)

1. **Robust Initial Layout**
   - Generate a *hexagonal / staggered grid* of 26 points scaled to fit the unit square.  
   - Optionally jitter each point by a small amount (â‰¤â€¯0.02) to break symmetry while staying inside the square.

2. **Linearâ€‘Programmed Radius Maximization**
   - For a *fixed set of centers*, formulate a linear program:
     - **Variables:** `r_i â‰¥ 0` (radius of each circle).  
     - **Objective:** maximize `âˆ‘ r_i` (or equivalently `âˆ‘ r_i` with a small weight on the minimum radius to avoid degenerate solutions).  
     - **Constraints:**  
        - **Boundary:** `r_i â‰¤ min(x_i, 1â€‘x_i, y_i, 1â€‘y_i)` for each circle.  
        - **Nonâ€‘overlap:** `r_i + r_j â‰¤ dist(i, j)` for every pair `i < j`.  
   - Use `scipy.optimize.linprog` with the **highâ€‘precision method** (`method='highs'`) and set a tight tolerance (`options={'tol':1e-9}`).

3. **Iterative Center Refinement**
   - After solving the LP, compute the **gradient of the objective** with respect to each center (approximate numerically).  
   - Perform a few **small displacement steps** (e.g., `step = 0.01`) that *increase* the minimal pairwise slack while keeping all centers inside the square.  
   - Reâ€‘solve the LP after each displacement to reâ€‘optimize radii.

4. **Multiâ€‘Start & Bestâ€‘Ofâ€‘N**
   - Run the whole pipeline (grid â†’ LP â†’ refinement) **N times** (e.g., `N=5`) with different jitter seeds.  
   - Keep the configuration with the **largest summed radius** that also passes the validity test.

5. **Postâ€‘Processing Cleanup**
   - After the final LP, enforce a **tiny safety margin** (e.g., `r_i *= 0.999`) to guard against floatingâ€‘point rounding errors that could otherwise cause `validity = 0`.

6. **Helper Functions**
   - Implement small, pureâ€‘Python helpers for:
     - Distance matrix computation (`_pairwise_distances(centers)`).
     - Boundary limit extraction (`_boundary_limits(centers)`).
     - LP construction (`_solve_radius_lp(centers)`).
   - Keep these helpers **inside the evolve block**; they are part of the code you may modify.

---

### ðŸ“‹ IMPLEMENTATION CHECKLIST
- [ ] Use **only** NumPy and SciPy (already imported in the outer file).
- [ ] Return a tuple `(centers, radii)` from `construct_packing()`.
- [ ] Ensure **all radii are nonâ€‘negative** and **â‰¤** the computed boundary limits.
- [ ] Verify **pairwise nonâ€‘overlap** after the final safety scaling; if any violation remains, fallback to the bestâ€‘ofâ€‘N configuration.
- [ ] Keep the function signatures unchanged; the surrounding framework expects them exactly.

---

### ðŸ›‘ FINAL REMINDER
- **Only output the code block** (no markers, no explanatory text).  
- The code must be **syntactically correct** and **selfâ€‘contained** within the evolve region.  
- Follow the strategies above to produce a higherâ€‘scoring, alwaysâ€‘valid packing.