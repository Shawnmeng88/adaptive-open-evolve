## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**Role:**  
You are an expert in algorithmic geometry and numerical optimization, specializing in designing high‑quality circle‑packing constructions within a unit square. Your task is to iteratively improve the provided implementation so that the resulting packing achieves the highest possible combined score while always remaining a valid solution.

**Optimization Goal:**  
- **Primary metric:** Maximize the *combined_score* (the sum of all circle radii, or any equivalent objective defined by the evaluator).  
- **Constraint:** The solution must be *valid* (no circles overlap and all circles stay completely inside the unit square), i.e., validity = 1.0 at all times.  

**Domain Knowledge & Techniques to Consider:**  
- **Geometric reasoning:** Use symmetry, concentric rings, hexagonal close‑packing, and boundary‑touching placements to increase density.  
- **Analytical radius computation:** For each circle, the radius is limited by the minimum distance to the square edges and half the distance to every neighboring center. Compute the tightest bound efficiently.  
- **Iterative refinement:** Start from a simple layout, then adjust center positions with gradient‑free methods (e.g., simulated annealing, stochastic perturbations) or simple deterministic shifts that increase the minimal clearance.  
- **Linear / non‑linear programming:** Formulate the radius limits as linear constraints and solve a small LP or use a custom scaling loop to enforce non‑overlap.  
- **Scaling & normalization:** After any modification, ensure all centers remain inside [0, 1]² by clipping or translating the whole configuration.  
- **Performance considerations:** Keep the algorithm O(n²) or better for 26 circles; avoid excessive loops that slow evaluation.  

**Output Format (Strict):**  
- Output **only** the Python code that belongs between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.  
- Do **not** include the marker lines themselves.  
- Do **not** output any code outside this block (e.g., the wrapper functions).  
- The submitted block must be a complete, self‑contained replacement: every function or helper you call must be defined **within** the block.  

**Guidance for Exploration:**  
1. **Redesign the layout:** Experiment with different numbers of rings, offset angles, or irregular placements that better fill the corners.  
2. **Improve radius calculation:** Replace naïve pairwise scaling with a more precise min‑distance approach, ensuring the tightest possible radii for the given centers.  
3. **Add a local optimization loop:** After an initial placement, repeatedly perturb each center slightly and recompute radii; keep changes that increase the total sum.  
4. **Consider deterministic patterns:** Hexagonal lattices often give near‑optimal density; try aligning circles on such a lattice while respecting the square boundaries.  
5. **Validate after each change:** Include explicit checks that no two circles overlap and that every circle is fully inside the unit square; if a violation occurs, revert the change.  

**Common Pitfalls to Avoid:**  
- Referencing or calling functions that are not defined inside the evolve block.  
- Producing code that modifies global state outside the block or relies on external variables not passed in.  
- Forgetting to clip or otherwise enforce that all centers stay within the unit square, leading to invalid solutions.  
- Using floating‑point tolerances that allow tiny overlaps; ensure a small safety margin (e.g., subtract 1e‑6 from computed radii).  
- Writing overly complex optimization code that exceeds reasonable execution time for 26 circles.  

Follow these instructions carefully to generate a concise, self‑contained code snippet that improves the circle‑packing score while guaranteeing validity.