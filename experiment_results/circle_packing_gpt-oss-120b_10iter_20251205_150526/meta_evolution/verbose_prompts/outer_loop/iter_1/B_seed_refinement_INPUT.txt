# Prompt Type: B
# Outer Iteration: 1
# This is the INPUT to the MetaLLM
# ======================================================================

# PROMPT REFINEMENT VIA METALLM - ITERATION 1
# ============================================

## Input to MetaLLM:
- Problem: ## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the m...
- Best code length: 4393 chars
- Current best prompt length: 4219 chars

## Convergence History:
### Successful Patterns:
- Negative guidance (what to avoid) helped
- Explicit constraint mentions helped

### Stuck Patterns:
(none)

### Last Iteration Metrics:
- Final best score: 0.9256
- Valid: 6, Invalid: 0
- Failure modes: []

## CODE ANALYSIS (What Actually Happened):
## Code Analysis from Recent Iterations

### Approaches Tried (with success rate):
  - constructive_placement: 1 attempts (mixed)
  - heuristic_pattern: 1 attempts (mixed)
  - iterative_refinement: 1 attempts (mixed)
  - greedy_random_sampling: 1 attempts (worked)
  - constructive_heuristic: 1 attempts (worked)
  - monte_carlo_sampling: 1 attempts (worked)
  - unknown: 1 attempts (worked)

### Approaches Not Yet Tried:
  - constraint_solving
  - force_directed
  - greedy
  - grid_based
  - linear_programming
  - nonlinear_optimization
  - quadratic_programming
  - random_search

### Novel Approaches Discovered:
  - constructive_placement: 1 attempts
  - heuristic_pattern: 1 attempts
  - greedy_random_sampling: 1 attempts
  - constructive_heuristic: 1 attempts
  - monte_carlo_sampling: 1 attempts

### Creative Techniques Observed:
  - reduces the number of random candidates after the first ten circles to speed up the greedy placement while still maintaining quality.

### Best Result Used: linear_programming
Techniques in best code:
  - hexagonal grid layout
  - LP for radius optimization
  - boundary constraint handling

### Score Improvements:
  - Iter 0: +0.3642 (linear_programming, grid_based)
  - Iter 1: +0.1922 (linear_programming, grid_based)
  - Iter 3: +0.3692 (linear_programming, grid_based)

### Summary:
  - Novel approaches discovered: constructive_placement, heuristic_pattern, greedy_random_sampling, constructive_heuristic, monte_carlo_sampling
  - Novel technique: reduces the number of random candidates after the first ten circles to speed up the greedy placement while still maintaining quality.
  - Working approaches: greedy_random_sampling, constructive_heuristic
  - Not yet explored: grid_based, linear_programming, random_search
  - Best improvement techniques: hexagonal grid layout, LP for radius optimization, boundary constraint handling

# ============================================
# FINAL REFINED PROMPT (seed_prompt_1):
# ============================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Guidance for Evolving the Packing Algorithm**

You are an expert algorithm designer and numerical‑optimization specialist focused on geometric packing problems.  
Your task is to generate the complete code that will replace the contents between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers. The surrounding file (imports, the `run_packing()` wrapper, and the `visualize()` function) is fixed and will be merged automatically with whatever you output.

---

### Mandatory Output Format (do **not** violate)

- **Output ONLY** the Python code that belongs **between** the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.  
- **Do NOT** include the marker lines themselves.  
- **Do NOT** include calls to `run_packing()` or `visualize()`.  
- The system will automatically combine your output with the preserved outer code.  

---

### Core Requirements

1. **Validity** – Every circle must stay completely inside the unit square and must not overlap any other circle.  
2. **Scoring** – The returned numeric score should equal the sum of the radii (or the metric used by the evaluator). Higher total radius = better score.  
3. **Self‑Containment** – **All** functions, classes, or utilities that your code calls must be defined **within** the output block. Missing definitions will cause runtime errors.  

---

### Successful Algorithmic Strategies (to incorporate)

- **Hexagonal lattice seed** – Start from a dense hexagonal grid that respects the square boundaries; this provides a strong initial arrangement for many circles.  
- **Linear‑programming radius optimization** – Formulate a linear program that maximizes the sum of radii subject to pairwise non‑overlap constraints (distance ≥ r_i + r_j) and boundary constraints (r_i ≤ x_i, r_i ≤ 1‑x_i, r_i ≤ y_i, r_i ≤ 1‑y_i). Solving this LP yields the optimal radii for a fixed set of centers.  
- **Greedy placement with reduced candidate pool** – After placing the first few circles, generate only a limited number of random candidate positions (e.g., 50–100) instead of thousands. Evaluate each candidate by the LP‑derived radius it would obtain and keep the best. This dramatically speeds up the search while preserving quality.  
- **Monte‑Carlo refinement** – Occasionally perturb existing centers (small random shifts) and re‑solve the LP; accept the change if the total radius improves and all constraints remain satisfied.  
- **Constructive heuristic for ordering** – Place circles in descending order of the maximum feasible radius given the current layout; this greedy ordering tends to lock in large circles early, leaving space for smaller ones later.  

---

### Approaches That Have Shown Little or No Benefit (avoid)

- **Pure random sampling without LP refinement** – generates many invalid or low‑quality configurations and wastes computation time.  
- **Excessive candidate generation after the initial circles** – leads to long runtimes with negligible score gains.  
- **Neglecting boundary constraints** – produces circles that extend outside the unit square, causing the evaluator to reject the solution.  
- **Using non‑linear solvers for this linear‑constraint problem** – adds unnecessary complexity and often fails to converge within the time budget.  

---

### What to Do

- Build a pipeline that **(a)** creates an initial set of center points using a hexagonal lattice (adjusted to fit the unit square), **(b)** formulates and solves the linear program to obtain optimal radii for those centers, **(c)** iteratively improves the layout by greedy addition of new circles with a limited random‑candidate pool, and **(d)** optionally applies Monte‑Carlo perturbations to escape local optima.  
- Ensure every mathematical operation uses only the already‑available `numpy` and `scipy.optimize.linprog` (or `scipy.optimize.linprog`‑compatible calls).  
- Return a tuple `(centers, radii, total_score)` where `centers` is an `(n, 2)` NumPy array, `radii` is a length‑`n` NumPy array, and `total_score` is a float equal to `radii.sum()`.  

---

### Reminder

- **All** helper functions, data‑generation utilities, and the final `construct_packing`‑style entry point must be **fully defined** inside the output block.  
- Do **not** reference or rely on any identifiers that are defined outside the block (except the pre‑imported `numpy as np` and `scipy.optimize.linprog`).  

Follow these guidelines precisely to produce a valid, high‑scoring packing solution.
