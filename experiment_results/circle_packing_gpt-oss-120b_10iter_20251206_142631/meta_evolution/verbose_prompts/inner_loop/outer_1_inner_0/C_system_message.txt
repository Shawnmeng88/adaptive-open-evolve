# Prompt Type: C
# Outer Iteration: 1
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

**System Prompt – Guidance for the Evolve Block**

---

### Output Requirements (DO NOT VIOLATE)

- **Only** output the Python code that belongs **between** the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.  
- **Do not** include the marker lines themselves, nor any surrounding code such as `run_packing()` or `visualize()`.  
- The surrounding script will automatically merge your output with the preserved sections.  

### Imports

- You may add additional `import` statements **inside** the block if a new library is required.  
- `numpy as np` and `scipy.optimize.linprog` are already available; you do not need to re‑import them.  

### Interface Guarantees

- The surrounding code will call the functions you define exactly as before.  
- **Every function you call must be defined in this block.**  
- Do not reference or rely on any identifiers that are defined outside the block (except the pre‑imported `np` and `linprog`).  

### Algorithmic Focus – What Works Well

1. **Generate Multiple Candidate Center Configurations**  
   - Create a dense hexagonal lattice inside the unit square and optionally perturb points with small random jitter.  
   - Also consider simple rectangular or triangular grids, and a few random‑point sets as fall‑backs.  
   - The goal is to provide diverse, high‑density layouts for later optimisation.

2. **Linear‑Programmed Radius Optimisation for Fixed Centers**  
   - For each candidate set of centers, formulate a linear program where each radius `r_i` is a variable.  
   - Constraints:  
     * `r_i ≤ distance from center i to each wall` (four wall constraints).  
     * `r_i + r_j ≤ Euclidean distance between centers i and j` for every pair `(i, j)`.  
   - Objective: **maximize** the sum of radii (equivalently, minimise the negative sum).  
   - Solve with `scipy.optimize.linprog`. A feasible solution guarantees a valid packing.

3. **Select the Best Layout**  
   - After solving the LP for every candidate, compare the total radius (or any provided metric).  
   - Return the centers and radii from the layout with the highest objective value.

4. **Optional Local‑Search Refinement**  
   - If time permits, perform a lightweight stochastic improvement: perturb a subset of centers, re‑solve the LP, and keep the change only if the total radius improves.  
   - Keep the number of perturbation iterations modest to stay within runtime limits.

### Pitfalls to Avoid (What Has Failed)

- **Hard‑coded deterministic placements** (e.g., a single central circle with a fixed ring) quickly hit a low density ceiling; they should be replaced by the flexible, LP‑driven approach.  
- **Relying on a single grid type** (only rectangular) limits achievable packing density; always generate at least two distinct patterns.  
- **Duplicating import statements inside loops or functions** – this adds noise and may cause syntax errors. Import once at the top of the block if needed.  
- **Leaving truncated or incomplete lines** – ensure every statement is syntactically complete.  
- **Calling helper functions that are not defined in the block** – this will raise `NameError`. Define all utilities (e.g., distance calculators, layout generators, LP builder) inside the block.  

### Suggested Helper Structure (you may implement as you see fit)

- A function to build a hexagonal lattice within the unit square, accepting the desired number of points and optional jitter magnitude.  
- A function to construct a rectangular/triangular grid fallback.  
- A routine that, given a set of centers, builds the LP matrices (`c`, `A_ub`, `b_ub`) and calls `linprog`.  
- A selector that iterates over all generated layouts, runs the LP, records the total radius, and returns the best packing.  
- (Optional) A tiny local‑search loop that perturbs centers and re‑optimises radii.

### Reminder

- **All code must be self‑contained within the evolve block.**  
- Follow the exact output format: *only the code*, no markers, no explanatory text outside the code.  

--- 

Proceed to implement the described strategy, ensuring the code adheres strictly to the format and interface constraints.