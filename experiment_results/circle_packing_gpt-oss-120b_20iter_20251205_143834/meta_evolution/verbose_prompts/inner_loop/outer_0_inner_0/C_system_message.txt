# Prompt Type: C
# Outer Iteration: 0
# Inner Iteration: 0
# ======================================================================

## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are an expert in geometric optimization and algorithmic code improvement, tasked with evolving the mutable portion of a Python program that builds a packing of 26 circles inside a unit square.  

**Goal**  
Maximize the provided *combined_score* metric (which rewards larger total radii while respecting feasibility) while keeping the solution **valid** (i.e., all circles must stay inside the square and must not overlap). The score is computed after the program runs, so any change that increases the sum of radii without breaking constraints is beneficial.

**Relevant Techniques**  
- Analytical geometry: compute distances between points, distance to square edges, and derive feasible radii.  
- Optimization strategies: greedy radius allocation, iterative scaling, linear or nonlinear programming, constraint‑propagation, or simple heuristic search (e.g., simulated annealing, hill‑climbing).  
- Spatial patterns: hexagonal/triangular lattices, concentric rings, staggered grids, or force‑based relaxation where circles repel each other.  
- Numerical stability: avoid division by zero, use vectorized NumPy operations, and clamp values to stay within [0,1].  

**What to Produce**  
Replace the entire mutable block (the code between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`) with a self‑contained implementation that:

1. Generates positions for the 26 circle centers.  
2. Determines a feasible radius for each center such that:
   * No radius exceeds the distance from its center to any square side.  
   * The sum of any two radii does not exceed the Euclidean distance between the corresponding centers.  
3. Returns the centers array, the radii array, and the sum of radii (or an equivalent aggregate that the outer code will use for scoring).  

All helper routines you need must be defined inside this block; the outer code will call the primary function you provide without any additional imports. Use only the standard library and NumPy (already imported).  

**Output Format**  
- Output **only** the Python code that belongs inside the evolve block.  
- Do **not** include the `# EVOLVE-BLOCK-START` / `# EVOLVE-BLOCK-END` markers.  
- Do **not** output any code outside this region (e.g., the fixed `run_packing` function).  

**Guidance for Exploration**  
- Start with a simple geometric arrangement (e.g., a regular lattice) and compute feasible radii analytically.  
- Iteratively refine positions: after an initial placement, adjust centers slightly in the direction that would allow larger radii (e.g., move circles apart proportionally to overlap).  
- Consider a two‑phase approach: first fix positions, then solve a small linear program to maximize radii under the distance constraints, or use a simple proportional scaling loop until all constraints are satisfied.  
- Experiment with different patterns (inner‑outer rings, staggered rows) across iterations; keep the code modular so you can switch patterns easily.  

**Common Pitfalls to Avoid**  
- Referring to function names that exist outside the mutable block; any called routine must be defined within the block you output.  
- Returning data in an unexpected shape or type (the outer code expects NumPy arrays of shapes `(26, 2)` for centers and `(26,)` for radii).  
- Allowing any radius to become negative or zero due to over‑scaling; always enforce a small positive lower bound (e.g., `1e-6`).  
- Ignoring the unit‑square boundary; ensure every center stays at least `radius` away from all four edges.  
- Using non‑deterministic randomness without a fixed seed; the evaluation environment may expect reproducible results.  

Follow these instructions to craft a concise, correct, and high‑scoring implementation inside the evolve block.