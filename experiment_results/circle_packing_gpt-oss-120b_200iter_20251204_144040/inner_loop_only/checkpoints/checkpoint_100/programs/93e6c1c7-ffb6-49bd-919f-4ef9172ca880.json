{"id": "93e6c1c7-ffb6-49bd-919f-4ef9172ca880", "code": "# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer \u2013 fast, high\u2011score version.\n\n* Hexagonal lattice seed.\n* Radii maximised by a linear programme when SciPy is present,\n  otherwise by a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) with a tiny\n  deterministic polish.\n* Several independent restarts; the best layout is returned.\n\"\"\"\n\nimport random, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radius optimiser (LP if possible, else heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_opt(pts: np.ndarray) -> np.ndarray:\n    n = len(pts)\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    A, b = [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = row[j] = 1.0\n            A.append(row)\n            b.append(np.linalg.norm(pts[i] - pts[j]))\n    A = np.array(A) if A else None\n    b = np.array(b) if b else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur_opt(pts: np.ndarray) -> np.ndarray:\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    n = len(pts)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(pts[i] - pts[j])\n            if r[i] + r[j] > d:\n                s = d / (r[i] + r[j])\n                r[i] *= s\n                r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _HAS_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed \u2013 tight start\n# ----------------------------------------------------------------------\ndef _hex(n: int) -> np.ndarray:\n    s = 0.18\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if len(pts) < n:                     # pad centre if needed\n        pts = np.vstack([pts, np.full((n - len(pts), 2), 0.5)])\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n\n    # coarse phase\n    for _ in range(1200):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.04\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n\n    # fine phase\n    for _ in range(1800):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.012\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Tiny deterministic polish\n# ----------------------------------------------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    step = 0.008\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base = cand, val\n                        improved = True\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 6):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API (unchanged signature)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "cc043e1c-890a-40b5-8d70-746d6ab8e4cc", "generation": 8, "timestamp": 1764882685.3099709, "iteration_found": 92, "metrics": {"validity": 1.0, "sum_radii": 2.492827379666666, "target_ratio": 0.9460445463630611, "combined_score": 0.9460445463630611, "eval_time": 34.88445210456848}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "error": "Program execution failed: cannot unpack non-iterable numpy.float64 object"}, "island": 4}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.9164 \u2192 0.0000. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4148, target_ratio: 0.9164, combined_score: 0.9164, eval_time: 15.8447\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4721, target_ratio: 0.9382, combined_score: 0.9382, eval_time: 16.3862\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4738, target_ratio: 0.9388, combined_score: 0.9388, eval_time: 32.0508\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9388)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer \u2013 repaired & slightly tweaked.\n\nKey ideas\n---------\n* Start from a tight hexagonal lattice.\n* maximise radii with a linear programme when SciPy is available,\n  otherwise fall back to a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) with correct\n  bookkeeping.\n* A few extra deterministic \u201cgrid\u2011snap\u201d tweaks for polishing.\n* 6 independent restarts (fast enough for the time limit).\n\"\"\"\nimport random, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radius optimiser (LP if possible, else heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                     # pragma: no cover\n    _LP = False\n\n\ndef _lp(pts: np.ndarray) -> np.ndarray:\n    n = len(pts)\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    A, b = [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = row[j] = 1.0\n            A.append(row)\n            b.append(np.linalg.norm(pts[i] - pts[j]))\n    A = np.array(A) if A else None\n    b = np.array(b) if b else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur(pts: np.ndarray) -> np.ndarray:\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    n = len(pts)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(pts[i] - pts[j])\n            if r[i] + r[j] > d:\n                s = d / (r[i] + r[j])\n                r[i] *= s\n                r[j] *= s\n    return r\n\n\n_opt = _lp if _LP else _heur\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed \u2013 tight starting layout\n# ----------------------------------------------------------------------\ndef _hex(n: int) -> np.ndarray:\n    s = 0.18\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if len(pts) < n:                     # pad centre if needed\n        pts = np.vstack([pts, np.full((n - len(pts), 2), 0.5)])\n    return pts\n\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine)\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n\n    # ----- coarse phase -------------------------------------------------\n    for _ in range(1200):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.04\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n\n    # ----- fine phase ---------------------------------------------------\n    for _ in range(1800):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.012\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Light deterministic polishing \u2013 small axis moves\n# ----------------------------------------------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    step = 0.008\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base_val = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base_val + 1e-9:\n                        pts, base_val = cand, val\n                        improved = True\n    return pts\n\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 6):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API (unchanged signature)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4738), Performs well on target_ratio (0.9388), Performs well on combined_score (0.9388), Performs well on eval_time (32.0508)\n\n### Program 2 (Score: 0.9382)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer.\n\nStrategy\n--------\n* Start from a tight hexagonal lattice.\n* Optimise radii with a linear program (fallback to a safe heuristic).\n* Run a fast stochastic hill\u2011climber many times and keep the best layout.\n* The public API (run_packing) is unchanged.\n\"\"\"\nimport random\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  LP / heuristic radius optimiser\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                     # pragma: no cover\n    _LP = False\n\n\ndef _lp_radii(pts: np.ndarray) -> np.ndarray:\n    n = len(pts)\n    # wall limits\n    bnd = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        coeff = np.zeros(n)\n        coeff[i] = coeff[j] = 1.0\n        rows.append(coeff)\n        rhs.append(np.linalg.norm(pts[i] - pts[j]))\n    A, b = (np.array(rows), np.array(rhs)) if rows else (None, None)\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                  bounds=[(0, ub) for ub in bnd],\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else bnd\n\n\ndef _heur_radii(pts: np.ndarray) -> np.ndarray:\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    for i, j in combinations(range(len(pts)), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _opt_radii(pts: np.ndarray) -> np.ndarray:\n    return _lp_radii(pts) if _LP else _heur_radii(pts)\n\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed (tight packing)\n# ----------------------------------------------------------------------\ndef _hex_seed(n: int) -> np.ndarray:\n    s = 0.18                         # tuned spacing\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if len(pts) < n:                                 # pad centre if needed\n        pts = np.vstack([pts, np.full((n - len(pts), 2), 0.5)])\n    return pts\n\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray,\n           max_iter: int = 2500,\n           step: float = 0.025,\n           patience: int = 400) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt_radii(best).sum()\n    n = len(best)\n    stale = 0\n    for _ in range(max_iter):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * step\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n            stale = 0\n        else:\n            stale += 1\n            if stale >= patience:\n                break\n    return best\n\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(num_restarts: int = 5):\n    best_sum = -1.0\n    best_c, best_r = None, None\n    for _ in range(num_restarts):\n        seed = _hex_seed(26)\n        centres = _climb(seed)\n        radii = _opt_radii(centres)\n        total = radii.sum()\n        if total > best_sum:\n            best_sum, best_c, best_r = total, centres, radii\n    return best_c, best_r, float(best_sum)\n\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Public API\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4721), Performs well on target_ratio (0.9382), Performs well on combined_score (0.9382), Performs well on eval_time (16.3862)\n\n### Program 3 (Score: 0.9164)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nEnhanced 26\u2011circle packing.\n\nMain ideas\n-----------\n* Keep the original cheap LP / heuristic radius optimiser.\n* Use a much more aggressive stochastic hill\u2011climber:\n    \u2013 start from the hexagonal seed,\n    \u2013 perform many random \u201cjitter\u201d moves,\n    \u2013 keep any move that raises the total radius.\n* Run a few independent restarts and keep the best layout.\n* All heavy work stays in NumPy / SciPy \u2013 fast enough for the\n  evaluation harness (\u2248\u202f1\u202fs on a typical CPU).\n\nThe public API (run_packing) is unchanged.\n\"\"\"\nimport numpy as np\nfrom itertools import combinations\nimport random\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:               # pragma: no cover\n    _LP = False\n\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Seed generation \u2013 unchanged hexagonal pattern (good starting point)\n# ----------------------------------------------------------------------\ndef _hex_seed(n: int) -> np.ndarray:\n    \"\"\"Generate a compact hexagonal lattice inside the unit square.\"\"\"\n    s = 0.18                                 # spacing tuned for 26 circles\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if needed\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Radius optimisation \u2013 LP if available, otherwise safe heuristic\n# ----------------------------------------------------------------------\ndef _lp_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear programme: maximise \u03a3 r_i subject to border & pairwise constraints.\"\"\"\n    n = len(c)\n    # maximal radius limited by the four walls\n    bnd = np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        coeff = np.zeros(n)\n        coeff[i] = coeff[j] = 1.0\n        rows.append(coeff)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, b = (np.array(rows), np.array(rhs)) if rows else (None, None)\n\n    # maximise \u2192 minimise negative objective\n    res = linprog(-np.ones(n),\n                  A_ub=A, b_ub=b,\n                  bounds=[(0, ub) for ub in bnd],\n                  method='highs',\n                  options={'presolve': True})\n    return res.x if res.success else bnd\n\n\ndef _heur_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Simple pairwise scaling \u2013 always feasible, never worse than wall limits.\"\"\"\n    r = np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Choose the best available optimiser.\"\"\"\n    return _lp_radii(c) if _LP else _heur_radii(c)\n\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Stochastic hill\u2011climber (many cheap evaluations)\n# ----------------------------------------------------------------------\ndef _stochastic_hill_climb(start: np.ndarray,\n                           max_iter: int = 2000,\n                           step: float = 0.02,\n                           patience: int = 300) -> np.ndarray:\n    \"\"\"\n    Randomly jitter points; keep any move that raises total radius.\n    Parameters\n    ----------\n    start : np.ndarray\n        Initial centre positions (shape (n,2)).\n    max_iter : int\n        Upper bound on the number of attempted moves.\n    step : float\n        Maximum absolute displacement per coordinate.\n    patience : int\n        Stop early after this many consecutive rejections.\n    Returns\n    -------\n    np.ndarray\n        Optimised centre positions.\n    \"\"\"\n    best = start.copy()\n    best_sum = _opt_radii(best).sum()\n    n = len(best)\n\n    reject_counter = 0\n    for _ in range(max_iter):\n        # pick a random index and a random displacement\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * step\n        cand = best.copy()\n        cand[i] += delta\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        cand_sum = _opt_radii(cand).sum()\n        if cand_sum > best_sum + 1e-8:          # accept only genuine improvements\n            best, best_sum = cand, cand_sum\n            reject_counter = 0\n        else:\n            reject_counter += 1\n            if reject_counter >= patience:\n                break\n    return best\n\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Multi\u2011restart driver \u2013 keep the best of several independent climbs\n# ----------------------------------------------------------------------\ndef _search_best(num_restarts: int = 4) -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"\n    Run several independent hill\u2011climbs and return the layout with the\n    largest sum of radii.\n    \"\"\"\n    best_total = -1.0\n    best_centers = None\n    best_radii = None\n\n    for _ in range(num_restarts):\n        seed = _hex_seed(26)\n        centres = _stochastic_hill_climb(seed,\n                                         max_iter=2500,\n                                         step=0.025,\n                                         patience=400)\n        radii = _opt_radii(centres)\n        total = radii.sum()\n        if total > best_total:\n            best_total, best_centers, best_radii = total, centres, radii\n\n    return best_centers, best_radii, float(best_total)\n\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Public entry point (unchanged signature)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers, radii, total = _search_best(num_restarts=5)\n    return centers, radii, total\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4148), Performs well on target_ratio (0.9164), Performs well on combined_score (0.9164), Performs well on eval_time (15.8447)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.8849)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved 26\u2011circle packing: hex seed + tiny local search, LP\u2011optimised radii.\"\"\"\nimport numpy as np\nfrom itertools import combinations\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                     # pragma: no cover\n    _LP = False\n\n\ndef _hex_seed(n: int) -> np.ndarray:\n    \"\"\"Hexagonal seed (spacing tuned for 26 circles).\"\"\"\n    s = 0.18\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                         # pad centre if needed\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _lp_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"LP maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    bnd = np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n); r[i] = r[j] = 1.0\n        rows.append(r); rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, b = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b, bounds=[(0, x) for x in bnd],\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else bnd\n\n\ndef _heur_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Fallback: pairwise scaling (always feasible).\"\"\"\n    r = np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s; r[j] *= s\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    return _lp_radii(c) if _LP else _heur_radii(c)\n\n\ndef _local_search(c: np.ndarray, steps=12, delta=0.012) -> np.ndarray:\n    \"\"\"Very cheap hill\u2011climb: move each centre \u00b1\u03b4 if it raises total radius.\"\"\"\n    best = c.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for sign in (-1, 1):\n                cand = best.copy()\n                cand[i] += sign * delta\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-6:\n                    best, best_sum = cand, s\n                    improved = True\n        if not improved:\n            break\n    return best\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    seed = _hex_seed(26)\n    centers = _local_search(seed)\n    radii = _opt_radii(centers)\n    return centers, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9141)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer \u2013 fast, high\u2011score version.\n\nDesign\n------\n* Hexagonal lattice as a tight seed.\n* Radii are maximised by a linear program (SciPy) or a safe pair\u2011wise heuristic.\n* A short stochastic hill\u2011climber improves the layout.\n* Several independent restarts; the best result is returned.\n\nPublic API\n----------\nrun_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\nimport random, itertools, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radius optimiser (LP if available, otherwise heuristic)\n# ----------------------------------------------------------------------\ntry:                                   # SciPy may be missing in the sandbox\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                     # pragma: no cover\n    _LP = False\n\n\ndef _lp_radii(pts: np.ndarray) -> np.ndarray:\n    n = len(pts)\n    # wall limits\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n\n    A, b = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        coeff = np.zeros(n)\n        coeff[i] = coeff[j] = 1.0\n        A.append(coeff)\n        b.append(np.linalg.norm(pts[i] - pts[j]))\n    A = np.array(A) if A else None\n    b = np.array(b) if b else None\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                  bounds=[(0, ub) for ub in wall],\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else wall\n\n\ndef _heur_radii(pts: np.ndarray) -> np.ndarray:\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    for i, j in itertools.combinations(range(len(pts)), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _opt_radii(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Select the best available optimiser.\"\"\"\n    return _lp_radii(pts) if _LP else _heur_radii(pts)\n\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed (tight starting layout)\n# ----------------------------------------------------------------------\ndef _hex_seed(n: int) -> np.ndarray:\n    spacing = 0.18                     # tuned for 26 circles\n    dy = spacing * np.sqrt(3) / 2\n    pts = []\n    y, row = spacing / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else spacing / 2\n        x = spacing / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if len(pts) < n:                     # pad centre if needed\n        pts = np.vstack([pts, np.full((n - len(pts), 2), 0.5)])\n    return pts\n\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Stochastic hill\u2011climber (fast, early\u2011stop)\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray,\n           max_iter: int = 2000,\n           step: float = 0.025,\n           patience: int = 400) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt_radii(best).sum()\n    n = len(best)\n    stale = 0\n    for _ in range(max_iter):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * step\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n            stale = 0\n        else:\n            stale += 1\n            if stale >= patience:\n                break\n    return best\n\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(num_restarts: int = 5):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(num_restarts):\n        centres = _hex_seed(26)\n        centres = _climb(centres)\n        radii = _opt_radii(centres)\n        total = radii.sum()\n        if total > best_sum:\n            best_sum, best_c, best_r = total, centres, radii\n    return best_c, best_r, float(best_sum)\n\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Public API\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9400, Type: High-Performer)\n```python\n\"\"\"Hex\u2011lattice 26\u2011circle packing with a tiny layout search.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# --------------------------------------------------------------\n# Optional LP backend\n# --------------------------------------------------------------\ntry:                     # SciPy gives a fast exact optimiser\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:       # pragma: no cover\n    _HAS_LP = False\n\n# --------------------------------------------------------------\n# Geometry helpers\n# --------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice points with spacing *s* (clipped, padded).\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# --------------------------------------------------------------\n# Radius optimisation\n# --------------------------------------------------------------\ndef _lp_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_optimize(c) if _HAS_LP else _heur_optimize(c)\n\n# --------------------------------------------------------------\n# Layout search \u2013 try several spacings & cheap hill\u2011climb\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return the centre layout with the largest \u03a3r among a few spacings.\"\"\"\n    candidates = np.linspace(0.14, 0.22, 9)          # coarse sweep around 0.18\n    best, best_sum = None, -1.0\n    for s in candidates:\n        pts = _hex_grid(n, s)\n        rad = _opt_radii(pts)\n        total = rad.sum()\n        if total > best_sum:\n            best, best_sum = pts, total\n    return best\n\ndef _local_search(centers: np.ndarray,\n                  steps: int = 6,\n                  delta: float = 0.012) -> np.ndarray:\n    \"\"\"Very cheap hill\u2011climb: move each centre \u00b1\u03b4 if total radius grows.\"\"\"\n    best = centers.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n# --------------------------------------------------------------\n# Public constructor\n# --------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    pts = _best_layout(26)\n    pts = _local_search(pts)                     # tiny refinement\n    rad = _opt_radii(pts)\n    return pts, rad, float(rad.sum())\n\n# --------------------------------------------------------------\n# Helper / entry\u2011point (unchanged API)\n# --------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Excellent validity (1.000), Excellent sum_radii (2.477), Excellent target_ratio (0.940)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer \u2013 improved search.\n\nApproach\n--------\n* Hexagonal lattice seed (tight start).\n* Radii maximised by a linear programme when SciPy is present,\n  otherwise by a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber:\n    \u2013 coarse moves (step 0.04) for quick exploration,\n    \u2013 fine moves (step 0.012) for polishing.\n* A few extra deterministic local tweaks.\n* More restarts (8) while staying well under the time limit.\n\"\"\"\nimport random, numpy as np\ntry:    from scipy.optimize import linprog; _LP=True\nexcept Exception: _LP=False\n\ndef _lp(pts):\n    n=len(pts)\n    wall=np.minimum.reduce([pts[:,0],pts[:,1],1-pts[:,0],1-pts[:,1]])\n    A=[];b=[]\n    for i in range(n):\n        for j in range(i+1,n):\n            c=np.zeros(n);c[i]=c[j]=1.0\n            A.append(c);b.append(np.linalg.norm(pts[i]-pts[j]))\n    A=np.array(A) if A else None; b=np.array(b) if b else None\n    res=linprog(-np.ones(n),A_ub=A,b_ub=b,\n                bounds=[(0,ub) for ub in wall],\n                method='highs',options={'presolve':True})\n    return res.x if res.success else wall\n\ndef _heur(pts):\n    r=np.minimum.reduce([pts[:,0],pts[:,1],1-pts[:,0],1-pts[:,1]])\n    n=len(pts)\n    for i in range(n):\n        for j in range(i+1,n):\n            d=np.linalg.norm(pts[i]-pts[j])\n            if r[i]+r[j]>d:\n                s=d/(r[i]+r[j]); r[i]*=s; r[j]*=s\n    return r\n_opt=lambda pts: _lp(pts) if _LP else _heur(pts)\n\ndef _hex(n):\n    s=0.18; dy=s*np.sqrt(3)/2\n    pts=[]; y=s/2; row=0\n    while y<1 and len(pts)<n:\n        off=0 if row%2==0 else s/2\n        x=s/2+off\n        while x<1 and len(pts)<n:\n            pts.append([x,y]); x+=s\n        y+=dy; row+=1\n    pts=np.clip(np.array(pts[:n]),0.01,0.99)\n    if len(pts)<n:\n        pts=np.vstack([pts,np.full((n-len(pts),2),0.5)])\n    return pts\n\ndef _climb(start):\n    best=start.copy(); bestv=_opt(best).sum(); n=len(best)\n    # coarse phase\n    for _ in range(1200):\n        i=random.randrange(n); delta=(np.random.rand(2)*2-1)*0.04\n        cand=best.copy(); cand[i]=np.clip(cand[i]+delta,0.01,0.99)\n        v=_opt(cand).sum()\n        if v>bestv+1e-8: best,candv=cand,v\n    # fine phase\n    for _ in range(1800):\n        i=random.randrange(n); delta=(np.random.rand(2)*2-1)*0.012\n        cand=best.copy(); cand[i]=np.clip(cand[i]+delta,0.01,0.99)\n        v=_opt(cand).sum()\n        if v>bestv+1e-8: best,bestv=cand,v\n    return best\n\ndef _tweak(pts):\n    # one pass of axis\u2011aligned moves\n    n=len(pts); improved=True\n    while improved:\n        improved=False\n        for i in range(n):\n            for d in (-0.008,0,0.008):\n                for e in (-0.008,0,0.008):\n                    cand=pts.copy()\n                    cand[i]=np.clip(cand[i]+[d,e],0.01,0.99)\n                    v=_opt(cand).sum()\n                    if v>_opt(pts).sum()+1e-9:\n                        pts,cand=v; improved=True\n    return pts\n\ndef _search():\n    best_sum=-1; best_c=best_r=None\n    for _ in range(8):\n        c=_hex(26)\n        c=_climb(c)\n        c=_tweak(c)\n        r=_opt(c); s=r.sum()\n        if s>best_sum: best_sum,best_c,best_r=s,c,r\n    return best_c,best_r,float(best_sum)\n\ndef construct_packing():\n    \"\"\"(centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\ndef run_packing():\n    \"\"\"Entry point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n# optional visualisation (unchanged)\ndef visualize(centers,radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n    fig,ax=plt.subplots(figsize=(6,6))\n    ax.set_aspect('equal'); ax.set_xlim(0,1); ax.set_ylim(0,1); ax.grid(True)\n    for i,(c,r) in enumerate(zip(centers,radii)):\n        ax.add_patch(Circle(c,r,alpha=0.4))\n        ax.text(*c,str(i),ha='center',va='center')\n    plt.title(f'Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\nif __name__=='__main__':\n    cs,rs,total=run_packing()\n    print(f'Sum of radii: {total:.6f}')\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer \u2013 fast, high\u2011score version.\n\n* Hexagonal lattice seed.\n* Radii maximised by a linear programme when SciPy is present,\n  otherwise by a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) with a tiny\n  deterministic polish.\n* Several independent restarts; the best layout is returned.\n\"\"\"\n\nimport random, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radius optimiser (LP if possible, else heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_opt(pts: np.ndarray) -> np.ndarray:\n    n = len(pts)\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    A, b = [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = row[j] = 1.0\n            A.append(row)\n            b.append(np.linalg.norm(pts[i] - pts[j]))\n    A = np.array(A) if A else None\n    b = np.array(b) if b else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur_opt(pts: np.ndarray) -> np.ndarray:\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    n = len(pts)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(pts[i] - pts[j])\n            if r[i] + r[j] > d:\n                s = d / (r[i] + r[j])\n                r[i] *= s\n                r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _HAS_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed \u2013 tight start\n# ----------------------------------------------------------------------\ndef _hex(n: int) -> np.ndarray:\n    s = 0.18\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if len(pts) < n:                     # pad centre if needed\n        pts = np.vstack([pts, np.full((n - len(pts), 2), 0.5)])\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n\n    # coarse phase\n    for _ in range(1200):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.04\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n\n    # fine phase\n    for _ in range(1800):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.012\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Tiny deterministic polish\n# ----------------------------------------------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    step = 0.008\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base = cand, val\n                        improved = True\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 6):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API (unchanged signature)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}