{"id": "20209d05-ef1f-4afa-827b-a18a39ac77bb", "code": "# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice 26\u2011circle packing with LP\u2011based radius optimisation.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\n# try to import a fast LP solver; fall back to a simple heuristic\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _hex_positions(n: int) -> np.ndarray:\n    \"\"\"Generate \u2248\u221an rows of a triangular lattice inside the unit square.\"\"\"\n    s = 0.18                         # spacing tuned for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    # pad if the lattice produced too few points (unlikely for n=26)\n    if pts.shape[0] < n:\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\ndef _lp_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r subject to border & pairwise constraints.\"\"\"\n    n = len(centers)\n    # border limits\n    borders = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    # build pairwise rows for r_i + r_j \u2264 d_ij\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = np.array(rows) if rows else None, np.array(rhs) if rhs else None\n    c = -np.ones(n)                     # maximise \u2192 minimise -\u03a3r\n    bounds = [(0, bnd) for bnd in borders]\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _heuristic_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Iterative pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_positions(26)\n    radii = _lp_radii(centers) if _HAS_LP else _heuristic_radii(centers)\n    return centers, radii, float(radii.sum())\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout", "language": "python", "parent_id": "71e749a7-08b3-471e-ad1a-ca6c008eaa07", "generation": 2, "timestamp": 1764881071.824546, "iteration_found": 13, "metrics": {"validity": 1.0, "sum_radii": 2.1799999999999993, "target_ratio": 0.827324478178368, "combined_score": 0.827324478178368, "eval_time": 0.2084958553314209}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.074730299493188, "target_ratio": 0.7873739277013998, "combined_score": 0.7873739277013998, "eval_time": 0.06000995635986328}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.7874\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.7874\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.0747, target_ratio: 0.7874, combined_score: 0.7874, eval_time: 0.0600\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.1667, target_ratio: 0.8223, combined_score: 0.8223, eval_time: 0.2368\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.1800, target_ratio: 0.8273, combined_score: 0.8273, eval_time: 0.2122\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.8273)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice circle packing for n=26 with LP/heuristic radius optimisation.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:  # pragma: no cover\n    _LP = False\n\n\ndef _hex_positions(n):\n    \"\"\"Generate \u2248\u221an rows of a hex (triangular) lattice inside the unit square.\"\"\"\n    s = 0.18                     # lattice spacing \u2013 tuned for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    # clip to avoid boundary issues and pad if short\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\ndef _max_radii_lp(centers):\n    \"\"\"LP: maximise \u03a3r  subject to border and pairwise distance constraints.\"\"\"\n    n = len(centers)\n    borders = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                                 1 - centers[:, 0], 1 - centers[:, 1]])\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = np.array(rows) if rows else None, np.array(rhs) if rhs else None\n    c = -np.ones(n)                     # maximise \u2192 minimise -\u03a3r\n    bounds = [(0, b) for b in borders]\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _max_radii_heur(centers):\n    \"\"\"Simple pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                             1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_positions(26)\n    radii = _max_radii_lp(centers) if _LP else _max_radii_heur(centers)\n    return centers, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.1800), Performs well on target_ratio (0.8273), Performs well on combined_score (0.8273), Performs well on eval_time (0.2122)\n\n### Program 2 (Score: 0.8223)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved circle packing for n=26 using LP radii optimisation and a grid layout.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\ntry:\n    # SciPy provides a reliable linear\u2011programming solver.\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:               # pragma: no cover\n    _HAS_LP = False\n\n\ndef _grid_positions(n):\n    \"\"\"Create a simple (\u2248\u221an)\u00d7(\u2248\u221an) grid plus a centre point.\"\"\"\n    m = int(np.ceil(np.sqrt(n)))          # grid dimension\n    xs = (np.arange(m) + 0.5) / m\n    ys = (np.arange(m) + 0.5) / m\n    pts = np.array(np.meshgrid(xs, ys)).T.reshape(-1, 2)\n    if pts.shape[0] > n:                  # trim excess\n        pts = pts[:n]\n    elif pts.shape[0] < n:                # add centre if needed\n        extra = n - pts.shape[0]\n        centre = np.full((extra, 2), 0.5)\n        pts = np.vstack([pts, centre])\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _lp_max_radii(centers):\n    \"\"\"Linear\u2011programming solution: max \u03a3r_i  s.t.  r_i\u2264border, r_i+r_j\u2264dist_ij.\"\"\"\n    n = len(centers)\n    # border limits\n    borders = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                                 1 - centers[:, 0], 1 - centers[:, 1]])\n\n    # inequality matrix for pairwise constraints\n    rows = []\n    rhs = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A_ub = np.array(rows) if rows else None\n    b_ub = np.array(rhs) if rhs else None\n\n    # linprog minimises; we maximise \u03a3r_i \u2192 minimise -\u03a3r_i\n    c = -np.ones(n)\n    bounds = [(0, b) for b in borders]\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    if res.success:\n        return res.x\n    # fallback: use the border limits (still valid)\n    return borders\n\n\ndef _heuristic_radii(centers):\n    \"\"\"Simple pairwise scaling fallback when LP is unavailable.\"\"\"\n    n = len(centers)\n    radii = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                               1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if radii[i] + radii[j] > d:\n            scale = d / (radii[i] + radii[j])\n            radii[i] *= scale\n            radii[j] *= scale\n    return radii\n\n\ndef construct_packing():\n    \"\"\"\n    Build a 26\u2011circle arrangement and compute radii that maximise the total sum.\n    Returns (centers, radii, sum_of_radii).\n    \"\"\"\n    n = 26\n    # start from a deterministic grid \u2013 good baseline for diversity\n    centers = _grid_positions(n)\n\n    # optimise radii\n    radii = _lp_max_radii(centers) if _HAS_LP else _heuristic_radii(centers)\n\n    return centers, radii, np.sum(radii)\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional visualisation using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Circle packing (sum\u202f=\u202f{radii.sum():.4f})')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.1667), Performs well on target_ratio (0.8223), Performs well on combined_score (0.8223), Performs well on eval_time (0.2368)\n\n### Program 3 (Score: 0.7874)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved constructor\u2011based circle packing for n=26 circles\"\"\"\n\nimport numpy as np\nimport math\n\n\ndef construct_packing():\n    \"\"\"\n    Construct 26 circle centres in a unit square using a simple\n    triangular lattice.  Radii are then set to the largest\n    possible values that keep every circle inside the square\n    and non\u2011overlapping.\n    Returns:\n        centres (np.ndarray shape (26,2)),\n        radii   (np.ndarray shape (26,)),\n        sum_radii (float)\n    \"\"\"\n    # ---- generate 26 points on a triangular lattice -----------------\n    spacing = 0.18                     # distance between adjacent points\n    dy = spacing * math.sqrt(3) / 2    # vertical step for the lattice\n    pts = []\n    y = spacing / 2\n    while y < 0.99 and len(pts) < 26:\n        # even rows have one extra point (no horizontal offset)\n        offset = 0 if (len(pts) // 10) % 2 == 0 else spacing / 2\n        x = spacing / 2 + offset\n        while x < 0.99 and len(pts) < 26:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n    centres = np.clip(np.array(pts[:26]), 0.01, 0.99)\n\n    # ---- compute maximal radii --------------------------------------\n    radii = _max_radii(centres)\n\n    return centres, radii, float(radii.sum())\n\n\ndef _max_radii(centres: np.ndarray) -> np.ndarray:\n    \"\"\"\n    For each centre compute the largest radius that fits inside the\n    unit square and does not intersect any other circle.\n    \"\"\"\n    n = centres.shape[0]\n    # distance to the four borders\n    border = np.minimum.reduce(\n        [centres[:, 0], centres[:, 1], 1 - centres[:, 0], 1 - centres[:, 1]]\n    )\n    # start with border distances\n    rad = border.copy()\n\n    # limit by neighbours: radius \u2264 half the centre\u2011to\u2011centre distance\n    for i in range(n):\n        dists = np.linalg.norm(centres[i] - centres[i + 1 :], axis=1)\n        if dists.size:\n            rad[i] = min(rad[i], dists.min() / 2)\n            # also enforce the neighbour's limit\n            rad[i + 1 :] = np.minimum(rad[i + 1 :], dists / 2)\n    return rad\n\n\n# EVOLVE-BLOCK-END\n\n\n# ----- fixed helper code (unchanged) ---------------------------------\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Display the packing using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (n={len(centres)}, sum={radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centres, radii, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # Uncomment to see the picture:\n    # visualize(centres, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.0747), Performs well on target_ratio (0.7874), Performs well on combined_score (0.7874), Performs well on eval_time (0.0600)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.6973)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimised 26\u2011circle packing in a unit square via linear programming.\"\"\"\nimport numpy as np\n\n# ------------------------------------------------------------\n# 1\ufe0f\u20e3  Build a deterministic set of 26 centre positions\n# ------------------------------------------------------------\ndef make_centres():\n    \"\"\"5\u00d75 grid (0.1,\u2026,0.9) plus one extra point.\"\"\"\n    pts = [(i + 0.5) / 5 for i in range(5)]               # 0.1,0.3,\u2026,0.9\n    grid = np.array([[x, y] for x in pts for y in pts])   # 25 points\n    extra = np.array([[0.5, 0.25]])                       # 26th point\n    return np.vstack([grid, extra])\n\n\n# ------------------------------------------------------------\n# 2\ufe0f\u20e3  Compute the *maximum* radii for a fixed set of centres.\n#     This is a linear programme:\n#       maximise   \u03a3 r_i\n#       subject to r_i \u2264 distance to each square side\n#                  r_i + r_j \u2264 distance(centre_i, centre_j)\n# ------------------------------------------------------------\ndef optimal_radii(centres):\n    try:\n        import pulp\n    except Exception:                     # pulp not available \u2192 fall back\n        return _greedy_radii(centres)\n\n    n = len(centres)\n    prob = pulp.LpProblem(\"max_sum_radii\", pulp.LpMaximize)\n\n    # decision variables\n    r = [pulp.LpVariable(f\"r{i}\", lowBound=0) for i in range(n)]\n\n    # maximise the sum\n    prob += pulp.lpSum(r)\n\n    # border constraints\n    for i, (x, y) in enumerate(centres):\n        prob += r[i] <= x\n        prob += r[i] <= y\n        prob += r[i] <= 1 - x\n        prob += r[i] <= 1 - y\n\n    # pairwise non\u2011overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centres[i] - centres[j])\n            prob += r[i] + r[j] <= d\n\n    prob.solve(pulp.PULP_CBC_CMD(msg=False))\n    return np.array([v.varValue for v in r], dtype=float)\n\n\n# ------------------------------------------------------------\n# 3\ufe0f\u20e3  Simple greedy fallback (used only if pulp is missing)\n# ------------------------------------------------------------\ndef _greedy_radii(centres):\n    n = len(centres)\n    rad = np.full(n, np.inf)\n    # border limits first\n    for i, (x, y) in enumerate(centres):\n        rad[i] = min(x, y, 1 - x, 1 - y)\n\n    # shrink radii greedily by nearest neighbour\n    for _ in range(3):                                     # a few passes\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centres[i] - centres[j])\n                if rad[i] + rad[j] > d:\n                    s = d / (rad[i] + rad[j])\n                    rad[i] *= s\n                    rad[j] *= s\n    return rad\n\n\n# ------------------------------------------------------------\n# 4\ufe0f\u20e3  Public entry point \u2013 unchanged API\n# ------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle layout.\"\"\"\n    centres = make_centres()\n    radii = optimal_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\n# -----------------------------------------------------------------\n# Fixed helper / visualisation \u2013 untouched by the evolution engine\n# -----------------------------------------------------------------\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Quick Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"26\u2011circle packing \u2013 sum\u202fr = {radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Sum of radii: {s:.6f}\")\n    # visualise(c, r)          # uncomment to see the layout\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.6276)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Stochastic\u2011search constructor for 26 circles in a unit square.\"\"\"\n\nimport numpy as np\n\ndef _max_radii(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Largest radii that keep circles inside the square and non\u2011overlapping.\"\"\"\n    # distance to the four borders\n    rad = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    # enforce neighbour distances (radius \u2264 half centre\u2011to\u2011centre distance)\n    n = len(pts)\n    for i in range(n):\n        d = np.linalg.norm(pts[i] - pts[i + 1 :], axis=1)\n        if d.size:\n            rad[i] = min(rad[i], d.min() / 2)\n            rad[i + 1 :] = np.minimum(rad[i + 1 :], d / 2)\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_radii) for a high\u2011sum packing.\"\"\"\n    N, B, iters = 26, 0.01, 300          # circles, border margin, random tries\n    best_sum, best_pts = -1, None\n\n    # ---------- coarse random search ----------\n    for _ in range(iters):\n        pts = np.random.rand(N, 2) * (1 - 2 * B) + B   # uniform in [B,1\u2011B]\n        rad = _max_radii(pts)\n        s = rad.sum()\n        if s > best_sum:\n            best_sum, best_pts = s, pts.copy()\n\n    # ---------- local jitter refinement ----------\n    for _ in range(200):\n        i = np.random.randint(N)\n        cand = best_pts.copy()\n        cand[i] += (np.random.rand(2) - 0.5) * 0.02      # small move\n        cand[i] = np.clip(cand[i], B, 1 - B)\n        rad = _max_radii(cand)\n        s = rad.sum()\n        if s > best_sum:\n            best_sum, best_pts = s, cand\n\n    return best_pts, _max_radii(best_pts), float(best_sum)\n\n\n# EVOLVE-BLOCK-END\n\n\n# ----- fixed helper code (unchanged) ---------------------------------\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Display the packing using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (n={len(centres)}, sum={radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centres, radii, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # Uncomment to visualise:\n    # visualize(centres, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.6973, Type: Alternative)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimised 26\u2011circle packing in a unit square via linear programming.\"\"\"\nimport numpy as np\n\n# ------------------------------------------------------------\n# 1\ufe0f\u20e3  Build a deterministic set of 26 centre positions\n# ------------------------------------------------------------\ndef make_centres():\n    \"\"\"5\u00d75 grid (0.1,\u2026,0.9) plus one extra point.\"\"\"\n    pts = [(i + 0.5) / 5 for i in range(5)]               # 0.1,0.3,\u2026,0.9\n    grid = np.array([[x, y] for x in pts for y in pts])   # 25 points\n    extra = np.array([[0.5, 0.25]])                       # 26th point\n    return np.vstack([grid, extra])\n\n\n# ------------------------------------------------------------\n# 2\ufe0f\u20e3  Compute the *maximum* radii for a fixed set of centres.\n#     This is a linear programme:\n#       maximise   \u03a3 r_i\n#       subject to r_i \u2264 distance to each square side\n#                  r_i + r_j \u2264 distance(centre_i, centre_j)\n# ------------------------------------------------------------\ndef optimal_radii(centres):\n    try:\n        import pulp\n    except Exception:                     # pulp not available \u2192 fall back\n        return _greedy_radii(centres)\n\n    n = len(centres)\n    prob = pulp.LpProblem(\"max_sum_radii\", pulp.LpMaximize)\n\n    # decision variables\n    r = [pulp.LpVariable(f\"r{i}\", lowBound=0) for i in range(n)]\n\n    # maximise the sum\n    prob += pulp.lpSum(r)\n\n    # border constraints\n    for i, (x, y) in enumerate(centres):\n        prob += r[i] <= x\n        prob += r[i] <= y\n        prob += r[i] <= 1 - x\n        prob += r[i] <= 1 - y\n\n    # pairwise non\u2011overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centres[i] - centres[j])\n            prob += r[i] + r[j] <= d\n\n    prob.solve(pulp.PULP_CBC_CMD(msg=False))\n    return np.array([v.varValue for v in r], dtype=float)\n\n\n# ------------------------------------------------------------\n# 3\ufe0f\u20e3  Simple greedy fallback (used only if pulp is missing)\n# ------------------------------------------------------------\ndef _greedy_radii(centres):\n    n = len(centres)\n    rad = np.full(n, np.inf)\n    # border limits first\n    for i, (x, y) in enumerate(centres):\n        rad[i] = min(x, y, 1 - x, 1 - y)\n\n    # shrink radii greedily by nearest neighbour\n    for _ in range(3):                                     # a few passes\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centres[i] - centres[j])\n                if rad[i] + rad[j] > d:\n                    s = d / (rad[i] + rad[j])\n                    rad[i] *= s\n                    rad[j] *= s\n    return rad\n\n\n# ------------------------------------------------------------\n# 4\ufe0f\u20e3  Public entry point \u2013 unchanged API\n# ------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle layout.\"\"\"\n    centres = make_centres()\n    radii = optimal_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\n# -----------------------------------------------------------------\n# Fixed helper / visualisation \u2013 untouched by the evolution engine\n# -----------------------------------------------------------------\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Quick Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"26\u2011circle packing \u2013 sum\u202fr = {radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Sum of radii: {s:.6f}\")\n    # visualise(c, r)          # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (1.837)\n\n### Inspiration 2 (Score: 0.5337, Type: Experimental)\n```python\n\"\"\"Simple deterministic circle packing for n=26.\n\nThe constructor builds a regular grid of points inside the unit square,\nthen scales the radii so that circles stay inside the square and do not\noverlap.  No external solvers are required \u2013 only NumPy.\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Helper functions (evolve\u2011block)\n# ----------------------------------------------------------------------\ndef _grid_positions(n: int) -> np.ndarray:\n    \"\"\"Return the first *n* points of an \u2248\u221an\u00d7\u221an grid, clipped to (0,1).\"\"\"\n    m = int(np.ceil(np.sqrt(n)))            # grid side length\n    xs = (np.arange(m) + 0.5) / m\n    ys = (np.arange(m) + 0.5) / m\n    pts = np.stack(np.meshgrid(xs, ys), -1).reshape(-1, 2)\n    pts = pts[:n]                            # keep only needed points\n    return np.clip(pts, 0.01, 0.99)           # stay away from the border\n\n\ndef _heuristic_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Scale radii so that every circle fits inside the square and does not overlap.\"\"\"\n    n = len(centers)\n    # start with the distance to the four borders\n    radii = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                               1 - centers[:, 0], 1 - centers[:, 1]])\n\n    # enforce pairwise non\u2011overlap by proportional scaling\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if radii[i] + radii[j] > d:\n            scale = d / (radii[i] + radii[j])\n            radii[i] *= scale\n            radii[j] *= scale\n    return radii\n\n\n# ----------------------------------------------------------------------\n# Public API (unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"\n    Build 26 circle centres and compute radii that maximise the total sum.\n    Returns (centres, radii, sum_of_radii).\n    \"\"\"\n    n = 26\n    centres = _grid_positions(n)\n    radii = _heuristic_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional visualisation using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (sum\u202f=\u202f{radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (1.406)\n\n### Inspiration 3 (Score: 0.6276, Type: Alternative)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Stochastic\u2011search constructor for 26 circles in a unit square.\"\"\"\n\nimport numpy as np\n\ndef _max_radii(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Largest radii that keep circles inside the square and non\u2011overlapping.\"\"\"\n    # distance to the four borders\n    rad = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    # enforce neighbour distances (radius \u2264 half centre\u2011to\u2011centre distance)\n    n = len(pts)\n    for i in range(n):\n        d = np.linalg.norm(pts[i] - pts[i + 1 :], axis=1)\n        if d.size:\n            rad[i] = min(rad[i], d.min() / 2)\n            rad[i + 1 :] = np.minimum(rad[i + 1 :], d / 2)\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_radii) for a high\u2011sum packing.\"\"\"\n    N, B, iters = 26, 0.01, 300          # circles, border margin, random tries\n    best_sum, best_pts = -1, None\n\n    # ---------- coarse random search ----------\n    for _ in range(iters):\n        pts = np.random.rand(N, 2) * (1 - 2 * B) + B   # uniform in [B,1\u2011B]\n        rad = _max_radii(pts)\n        s = rad.sum()\n        if s > best_sum:\n            best_sum, best_pts = s, pts.copy()\n\n    # ---------- local jitter refinement ----------\n    for _ in range(200):\n        i = np.random.randint(N)\n        cand = best_pts.copy()\n        cand[i] += (np.random.rand(2) - 0.5) * 0.02      # small move\n        cand[i] = np.clip(cand[i], B, 1 - B)\n        rad = _max_radii(cand)\n        s = rad.sum()\n        if s > best_sum:\n            best_sum, best_pts = s, cand\n\n    return best_pts, _max_radii(best_pts), float(best_sum)\n\n\n# EVOLVE-BLOCK-END\n\n\n# ----- fixed helper code (unchanged) ---------------------------------\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Display the packing using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (n={len(centres)}, sum={radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centres, radii, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # Uncomment to visualise:\n    # visualize(centres, radii)\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (1.654)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved constructor\u2011based circle packing for n=26 circles\"\"\"\n\nimport numpy as np\nimport math\n\n\ndef construct_packing():\n    \"\"\"\n    Construct 26 circle centres in a unit square using a simple\n    triangular lattice.  Radii are then set to the largest\n    possible values that keep every circle inside the square\n    and non\u2011overlapping.\n    Returns:\n        centres (np.ndarray shape (26,2)),\n        radii   (np.ndarray shape (26,)),\n        sum_radii (float)\n    \"\"\"\n    # ---- generate 26 points on a triangular lattice -----------------\n    spacing = 0.18                     # distance between adjacent points\n    dy = spacing * math.sqrt(3) / 2    # vertical step for the lattice\n    pts = []\n    y = spacing / 2\n    while y < 0.99 and len(pts) < 26:\n        # even rows have one extra point (no horizontal offset)\n        offset = 0 if (len(pts) // 10) % 2 == 0 else spacing / 2\n        x = spacing / 2 + offset\n        while x < 0.99 and len(pts) < 26:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n    centres = np.clip(np.array(pts[:26]), 0.01, 0.99)\n\n    # ---- compute maximal radii --------------------------------------\n    radii = _max_radii(centres)\n\n    return centres, radii, float(radii.sum())\n\n\ndef _max_radii(centres: np.ndarray) -> np.ndarray:\n    \"\"\"\n    For each centre compute the largest radius that fits inside the\n    unit square and does not intersect any other circle.\n    \"\"\"\n    n = centres.shape[0]\n    # distance to the four borders\n    border = np.minimum.reduce(\n        [centres[:, 0], centres[:, 1], 1 - centres[:, 0], 1 - centres[:, 1]]\n    )\n    # start with border distances\n    rad = border.copy()\n\n    # limit by neighbours: radius \u2264 half the centre\u2011to\u2011centre distance\n    for i in range(n):\n        dists = np.linalg.norm(centres[i] - centres[i + 1 :], axis=1)\n        if dists.size:\n            rad[i] = min(rad[i], dists.min() / 2)\n            # also enforce the neighbour's limit\n            rad[i + 1 :] = np.minimum(rad[i + 1 :], dists / 2)\n    return rad\n\n\n# EVOLVE-BLOCK-END\n\n\n# ----- fixed helper code (unchanged) ---------------------------------\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Display the packing using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (n={len(centres)}, sum={radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centres, radii, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # Uncomment to see the picture:\n    # visualize(centres, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice 26\u2011circle packing with LP\u2011based radius optimisation.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\n# try to import a fast LP solver; fall back to a simple heuristic\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _hex_positions(n: int) -> np.ndarray:\n    \"\"\"Generate \u2248\u221an rows of a triangular lattice inside the unit square.\"\"\"\n    s = 0.18                         # spacing tuned for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    # pad if the lattice produced too few points (unlikely for n=26)\n    if pts.shape[0] < n:\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\ndef _lp_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r subject to border & pairwise constraints.\"\"\"\n    n = len(centers)\n    # border limits\n    borders = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    # build pairwise rows for r_i + r_j \u2264 d_ij\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = np.array(rows) if rows else None, np.array(rhs) if rhs else None\n    c = -np.ones(n)                     # maximise \u2192 minimise -\u03a3r\n    bounds = [(0, bnd) for bnd in borders]\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _heuristic_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Iterative pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_positions(26)\n    radii = _lp_radii(centers) if _HAS_LP else _heuristic_radii(centers)\n    return centers, radii, float(radii.sum())\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}