{"id": "ad1025cb-0f57-46e9-a942-5b21955fef56", "code": "\"\"\"26\u2011circle packing \u2013 tiny multi\u2011start hill\u2011climb.\n\nThe public API is unchanged:\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\nThe algorithm:\n  1. Sweep a handful of hex\u2011lattice spacings.\n  2. For each spacing launch a few jittered starts and a deterministic\n     hill\u2011climb that accepts any move raising the total radius.\n  3. Radii are maximised by a linear programme when SciPy is present,\n     otherwise by a deterministic pair\u2011wise scaling heuristic.\n  4. The layout with the largest \u03a3\u202fr is returned.\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                     # fast exact solution if available\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                       # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*).  Points are clipped and centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Choose the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n\n# ----------------------------------------------------------------------\n# deterministic hill\u2011climb\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray,\n                steps: int = 10,\n                delta: float = 0.012) -> np.ndarray:\n    \"\"\"Move each centre \u00b1\u03b4 while the total radius grows.\"\"\"\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# jittered multi\u2011start wrapper\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)   # deterministic seed\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    \"\"\"Add uniform noise \u2208[\u2011scale,\u202fscale] and clip back into the unit square.\"\"\"\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Sweep a few spacings, launch jittered hill\u2011climbs, keep the best layout.\"\"\"\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered starts\n        for _ in range(3):\n            jittered = _jitter(base)\n            cand = _hill_climb(jittered)\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout", "language": "python", "parent_id": "3c66da91-e41c-402f-b958-d55d49aa0479", "generation": 4, "timestamp": 1764882792.2722619, "iteration_found": 94, "metrics": {"validity": 1.0, "sum_radii": 2.47825973144573, "target_ratio": 0.9405160271141292, "combined_score": 0.9405160271141292, "eval_time": 46.93044185638428}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.4663987569698183, "target_ratio": 0.9360147085274453, "combined_score": 0.9360147085274453, "eval_time": 0.7587261199951172}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.9360\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.9400 \u2192 0.9360. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4768, target_ratio: 0.9400, combined_score: 0.9400, eval_time: 31.3648\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4768, target_ratio: 0.9400, combined_score: 0.9400, eval_time: 0.6535\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4783, target_ratio: 0.9405, combined_score: 0.9405, eval_time: 37.7631\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9405)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\nThe new version adds an optional exact linear\u2011programming optimiser\n(if SciPy is available) and a tiny multi\u2011start local search.  The\nbehaviour is still deterministic \u2013 a fixed RNG seed is used for any\nrandomised steps.\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                 # SciPy gives a fast, exact solution\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                   # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; points are clipped and\n    centre\u2011padded if the lattice is too short.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                         # centre\u2011pad if short\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Exact maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_optimize(c) if _HAS_LP else _heur_optimize(c)\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray,\n                steps: int = 8,\n                delta: float = 0.012) -> np.ndarray:\n    \"\"\"Move each centre \u00b1\u03b4 while the total radius grows.\"\"\"\n    best = c.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# small random perturbation (deterministic seed)\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    \"\"\"Add uniform noise \u2208[\u2011scale,\u202fscale] and clip back into the unit square.\"\"\"\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 multi\u2011start sweep + hill\u2011climb\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search a handful of hex spacings, keep the layout with the largest \u03a3r.\"\"\"\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # coarse sweep around sweet spot\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered starts\n        for _ in range(3):\n            jittered = _jitter(base)\n            cand = _hill_climb(jittered)\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4783), Performs well on target_ratio (0.9405), Performs well on combined_score (0.9405), Performs well on eval_time (37.7631)\n\n### Program 2 (Score: 0.9400)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\nThe algorithm:\n  1. Sweep a few hex\u2011lattice spacings and keep the layout with the\n     largest \u03a3\u202fr (LP\u2011optimised when SciPy is present, otherwise a cheap heuristic).\n  2. Perform a tiny deterministic hill\u2011climb on the centre positions;\n     any move that raises the total radius is kept.\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Optional linear\u2011programming backend\n# ----------------------------------------------------------------------\ntry:                         # SciPy gives a fast exact optimiser\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:           # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# Geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice points with spacing *s* (clipped, centre\u2011padded).\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# Radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_optimize(c) if _HAS_LP else _heur_optimize(c)\n\n\n# ----------------------------------------------------------------------\n# Layout search \u2013 coarse sweep + tiny hill\u2011climb\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return the centre layout with the largest \u03a3r among a few spacings.\"\"\"\n    candidates = np.linspace(0.14, 0.22, 9)          # coarse sweep around 0.18\n    best, best_sum = None, -1.0\n    for s in candidates:\n        pts = _hex_grid(n, s)\n        total = _opt_radii(pts).sum()\n        if total > best_sum:\n            best, best_sum = pts, total\n    return best\n\n\ndef _local_search(centers: np.ndarray,\n                  steps: int = 6,\n                  delta: float = 0.012) -> np.ndarray:\n    \"\"\"Very cheap hill\u2011climb: move each centre \u00b1\u03b4 if total radius grows.\"\"\"\n    best = centers.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# Public constructor\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    pts = _best_layout(26)\n    pts = _local_search(pts)               # tiny refinement\n    rad = _opt_radii(pts)\n    return pts, rad, float(rad.sum())\n\n\n# ----------------------------------------------------------------------\n# Helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4768), Performs well on target_ratio (0.9400), Performs well on combined_score (0.9400), Performs well on eval_time (0.6535)\n\n### Program 3 (Score: 0.9400)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"26\u2011circle packing \u2013 sweep of hex spacings + tiny multi\u2011start hill\u2011climb.\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# --------------------------------------------------------------\n# Optional linear\u2011programming backend (SciPy)\n# --------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# --------------------------------------------------------------\n# Geometry helpers\n# --------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice of spacing *s* (clipped, centre\u2011padded).\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# --------------------------------------------------------------\n# Radius optimisation\n# --------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"LP maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    bnd = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=bnd,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n# --------------------------------------------------------------\n# Tiny deterministic hill\u2011climb\n# --------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 6, delta: float = 0.012) -> np.ndarray:\n    \"\"\"Move each centre \u00b1\u03b4 while total radius grows.\"\"\"\n    best = c.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    \"\"\"Add uniform noise \u2208[\u2011scale,\u202fscale] and clip.\"\"\"\n    noise = (np.random.rand(*c.shape) * 2 - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n# --------------------------------------------------------------\n# Layout search \u2013 sweep spacings, jittered starts, keep best\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return centre layout with maximal \u03a3r found by a cheap multi\u2011start search.\"\"\"\n    candidates = np.linspace(0.14, 0.22, 9)          # coarse sweep around 0.18\n    best_pts, best_sum = None, -1.0\n    for s in candidates:\n        base = _hex_grid(n, s)\n\n        # pure grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best_pts, best_sum = cand, total\n\n        # a few jittered starts\n        for _ in range(3):\n            jittered = _jitter(base)\n            cand = _hill_climb(jittered)\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best_pts, best_sum = cand, total\n    return best_pts\n\n# --------------------------------------------------------------\n# Public constructor\n# --------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    pts = _best_layout(26)\n    rad = _opt_radii(pts)\n    return pts, rad, float(rad.sum())\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4768), Performs well on target_ratio (0.9400), Performs well on combined_score (0.9400), Performs well on eval_time (31.3648)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9400)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\nThe algorithm:\n  1. Sweep a few hex\u2011lattice spacings.\n  2. For each spacing run a tiny deterministic hill\u2011climb on the\n     centre positions (any move that raises the total radius is kept).\n  3. Radii are maximised by a linear programme when SciPy is present,\n     otherwise by a deterministic pair\u2011wise scaling heuristic.\n  4. Return the layout with the largest \u03a3\u202fr.\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional linear\u2011programming backend (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice points with spacing *s* (clipped, centre\u2011padded).\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_optimize(c) if _HAS_LP else _heur_optimize(c)\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(centers: np.ndarray,\n                steps: int = 6,\n                delta: float = 0.012) -> np.ndarray:\n    \"\"\"Move each centre \u00b1\u03b4 while the total radius grows.\"\"\"\n    best = centers.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep spacings, keep best after hill\u2011climb\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return the centre layout with the largest \u03a3r among a few spacings.\"\"\"\n    candidates = np.linspace(0.14, 0.22, 9)          # coarse sweep around 0.18\n    best, best_sum = None, -1.0\n    for s in candidates:\n        pts = _hex_grid(n, s)\n        pts = _hill_climb(pts)                     # cheap refinement\n        total = _opt_radii(pts).sum()\n        if total > best_sum:\n            best, best_sum = pts, total\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9400)\n```python\n\"\"\"26\u2011circle packing \u2013 richer centre optimisation.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ---------- optional LP backend ----------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ---------- geometry helpers ----------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*), clipped, centre\u2011padded if needed.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Max admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ---------- radius optimisation ----------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n# ---------- centre optimisation ----------\n_rng = np.random.default_rng(1)   # deterministic but different seed\n\n\ndef _hill_climb(c: np.ndarray, delta: float = 0.012, steps: int = 8) -> np.ndarray:\n    \"\"\"Deterministic hill\u2011climb \u2013 try \u00b1\u03b4 moves on each centre.\"\"\"\n    best = c.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-10:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\ndef _perturb(c: np.ndarray, scale: float = 0.03) -> np.ndarray:\n    \"\"\"Small random jitter, kept inside the unit square.\"\"\"\n    return np.clip(c + (2 * _rng.random(c.shape) - 1) * scale, 0.01, 0.99)\n\n\ndef _refine(base: np.ndarray, rounds: int = 4) -> np.ndarray:\n    \"\"\"Multiple jitter\u2011hill\u2011climb cycles; keep the best layout.\"\"\"\n    best = _hill_climb(base)\n    best_sum = _opt_radii(best).sum()\n    for _ in range(rounds):\n        cand = _hill_climb(_perturb(base))\n        s = _opt_radii(cand).sum()\n        if s > best_sum:\n            best, best_sum = cand, s\n    return best\n\n\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search over a handful of hex spacings, keep the best refined layout.\"\"\"\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):\n        grid = _hex_grid(n, s)\n        refined = _refine(grid)\n        total = _opt_radii(refined).sum()\n        if total > best_sum:\n            best, best_sum = refined, total\n    return best\n\n# ---------- public constructor ----------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ---------- helper / entry\u2011point ----------\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.7874, Type: Alternative)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved constructor\u2011based circle packing for n=26 circles\"\"\"\n\nimport numpy as np\nimport math\n\n\ndef construct_packing():\n    \"\"\"\n    Construct 26 circle centres in a unit square using a simple\n    triangular lattice.  Radii are then set to the largest\n    possible values that keep every circle inside the square\n    and non\u2011overlapping.\n    Returns:\n        centres (np.ndarray shape (26,2)),\n        radii   (np.ndarray shape (26,)),\n        sum_radii (float)\n    \"\"\"\n    # ---- generate 26 points on a triangular lattice -----------------\n    spacing = 0.18                     # distance between adjacent points\n    dy = spacing * math.sqrt(3) / 2    # vertical step for the lattice\n    pts = []\n    y = spacing / 2\n    while y < 0.99 and len(pts) < 26:\n        # even rows have one extra point (no horizontal offset)\n        offset = 0 if (len(pts) // 10) % 2 == 0 else spacing / 2\n        x = spacing / 2 + offset\n        while x < 0.99 and len(pts) < 26:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n    centres = np.clip(np.array(pts[:26]), 0.01, 0.99)\n\n    # ---- compute maximal radii --------------------------------------\n    radii = _max_radii(centres)\n\n    return centres, radii, float(radii.sum())\n\n\ndef _max_radii(centres: np.ndarray) -> np.ndarray:\n    \"\"\"\n    For each centre compute the largest radius that fits inside the\n    unit square and does not intersect any other circle.\n    \"\"\"\n    n = centres.shape[0]\n    # distance to the four borders\n    border = np.minimum.reduce(\n        [centres[:, 0], centres[:, 1], 1 - centres[:, 0], 1 - centres[:, 1]]\n    )\n    # start with border distances\n    rad = border.copy()\n\n    # limit by neighbours: radius \u2264 half the centre\u2011to\u2011centre distance\n    for i in range(n):\n        dists = np.linalg.norm(centres[i] - centres[i + 1 :], axis=1)\n        if dists.size:\n            rad[i] = min(rad[i], dists.min() / 2)\n            # also enforce the neighbour's limit\n            rad[i + 1 :] = np.minimum(rad[i + 1 :], dists / 2)\n    return rad\n\n\n# EVOLVE-BLOCK-END\n\n\n# ----- fixed helper code (unchanged) ---------------------------------\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Display the packing using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (n={len(centres)}, sum={radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centres, radii, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # Uncomment to see the picture:\n    # visualize(centres, radii)\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.075)\n\n### Inspiration 2 (Score: 0.5337, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Deterministic grid + pairwise scaling \u2013 fast, high\u2011sum packing for n=26.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\ndef _grid(n):\n    m = int(np.ceil(np.sqrt(n)))\n    xs = (np.arange(m)+0.5)/m\n    ys = (np.arange(m)+0.5)/m\n    pts = np.stack(np.meshgrid(xs, ys), -1).reshape(-1,2)[:n]\n    return np.clip(pts,0.01,0.99)\n\ndef _scale(pts):\n    r = np.minimum.reduce([pts[:,0],pts[:,1],1-pts[:,0],1-pts[:,1]])\n    for i,j in combinations(range(len(pts)),2):\n        d = np.linalg.norm(pts[i]-pts[j])\n        if r[i]+r[j]>d:\n            s = d/(r[i]+r[j]); r[i]*=s; r[j]*=s\n    return r\n\ndef construct_packing():\n    \"\"\"return (centres, radii, sum_of_radii).\"\"\"\n    c = _grid(26)\n    r = _scale(c)\n    return c, r, float(r.sum())\n# EVOLVE-BLOCK-END\n\ndef run_packing(): return construct_packing()\n\ndef visualize(centres, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n    fig,ax=plt.subplots(figsize=(6,6))\n    ax.set_aspect('equal');ax.set_xlim(0,1);ax.set_ylim(0,1);ax.grid(True)\n    for i,(c,rad) in enumerate(zip(centres,radii)):\n        ax.add_patch(Circle(c,rad,alpha=0.4))\n        ax.text(*c,str(i),ha='center',va='center')\n    plt.show()\n\nif __name__=='__main__':\n    cs,rs,total=run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs,rs)   # uncomment to see layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (1.406)\n\n### Inspiration 3 (Score: 0.9400, Type: High-Performer)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\nThe algorithm:\n  1. Sweep a few hex\u2011lattice spacings.\n  2. For each spacing run a cheap multi\u2011start hill\u2011climb on the centre\n     positions (tiny deterministic moves that raise the total radius).\n  3. Radii are maximised by a linear programme when SciPy is present,\n     otherwise by a deterministic pair\u2011wise scaling heuristic.\n  4. Return the layout with the largest \u03a3\u202fr.\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional LP backend (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice of spacing *s* (clipped, centre\u2011padded).\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Exact maximise \u03a3r via LP (SciPy).\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Choose the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb\n# ----------------------------------------------------------------------\ndef _hill_climb(centers: np.ndarray,\n                steps: int = 6,\n                delta: float = 0.012) -> np.ndarray:\n    \"\"\"Move each centre \u00b1\u03b4 while total radius grows.\"\"\"\n    best = centers.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n# ----------------------------------------------------------------------\n# stochastic multi\u2011start refinement\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(0)          # deterministic seed\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    \"\"\"Add uniform noise \u2208[\u2011scale,\u202fscale] and clip.\"\"\"\n    noise = ( _rng.random(c.shape) * 2 - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\ndef _refine(base: np.ndarray) -> np.ndarray:\n    \"\"\"Run a few jittered hill\u2011climbs, keep the best result.\"\"\"\n    best = _hill_climb(base)\n    best_sum = _opt_radii(best).sum()\n    for _ in range(3):                     # extra starts\n        cand = _hill_climb(_jitter(base))\n        s = _opt_radii(cand).sum()\n        if s > best_sum:\n            best, best_sum = cand, s\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep spacings, keep best refined layout\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):    # coarse sweep around sweet\u2011spot\n        pts = _hex_grid(n, s)\n        pts = _refine(pts)\n        total = _opt_radii(pts).sum()\n        if total > best_sum:\n            best, best_sum = pts, total\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.477)\n\n# Current Program\n```python\n\"\"\"Improved 26\u2011circle hex packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Optional LP support \u2013 fall back to a deterministic heuristic\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\n# ----------------------------------------------------------------------\n# Radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_optimize(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r subject to border & pairwise constraints.\"\"\"\n    n = len(centers)\n    border = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A = np.array(rows) if rows else None\n    b = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                  bounds=[(0, ub) for ub in border],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else border\n\n\ndef _heuristic_optimize(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    rad = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    for i, j in combinations(range(len(centers)), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        s = rad[i] + rad[j]\n        if s > d:\n            f = d / s\n            rad[i] *= f\n            rad[j] *= f\n    return rad\n\n\ndef _opt_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_optimize(centers) if _HAS_LP else _heuristic_optimize(centers)\n\n\n# ----------------------------------------------------------------------\n# Hex\u2011lattice generation\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, spacing: float) -> np.ndarray:\n    \"\"\"Place \u2264\u202fn points on a triangular lattice with given spacing.\"\"\"\n    dy = spacing * np.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y, row = spacing / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else spacing / 2\n        x = spacing / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if needed\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\n# ----------------------------------------------------------------------\n# Search over a few spacings and keep the best layout\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return a centre layout with the largest total radius among candidate spacings.\"\"\"\n    candidates = np.linspace(0.12, 0.24, 13)   # coarse sweep centred near 0.18\n    best_pts, best_sum = None, -1.0\n    for s in candidates:\n        pts = _hex_grid(n, s)\n        rad = _opt_radii(pts)\n        total = rad.sum()\n        if total > best_sum:\n            best_sum, best_pts = total, pts\n    return best_pts\n\n\n# ----------------------------------------------------------------------\n# Tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _local_search(centers: np.ndarray,\n                  steps: int = 8,\n                  delta: float = 0.01) -> np.ndarray:\n    \"\"\"Move each centre \u00b1\u03b4 in the four axial directions if the total radius grows.\"\"\"\n    best = centers.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum = cand, s\n                    improved = True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# Public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    pts = _best_layout(26)\n    pts = _local_search(pts)                     # cheap refinement\n    radii = _opt_radii(pts)\n    return pts, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# Helper entry\u2011point and optional visualisation (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"26\u2011circle packing \u2013 tiny multi\u2011start hill\u2011climb.\n\nThe public API is unchanged:\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\nThe algorithm:\n  1. Sweep a handful of hex\u2011lattice spacings.\n  2. For each spacing launch a few jittered starts and a deterministic\n     hill\u2011climb that accepts any move raising the total radius.\n  3. Radii are maximised by a linear programme when SciPy is present,\n     otherwise by a deterministic pair\u2011wise scaling heuristic.\n  4. The layout with the largest \u03a3\u202fr is returned.\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                     # fast exact solution if available\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                       # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*).  Points are clipped and centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Choose the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n\n# ----------------------------------------------------------------------\n# deterministic hill\u2011climb\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray,\n                steps: int = 10,\n                delta: float = 0.012) -> np.ndarray:\n    \"\"\"Move each centre \u00b1\u03b4 while the total radius grows.\"\"\"\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# jittered multi\u2011start wrapper\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)   # deterministic seed\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    \"\"\"Add uniform noise \u2208[\u2011scale,\u202fscale] and clip back into the unit square.\"\"\"\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Sweep a few spacings, launch jittered hill\u2011climbs, keep the best layout.\"\"\"\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered starts\n        for _ in range(3):\n            jittered = _jitter(base)\n            cand = _hill_climb(jittered)\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}