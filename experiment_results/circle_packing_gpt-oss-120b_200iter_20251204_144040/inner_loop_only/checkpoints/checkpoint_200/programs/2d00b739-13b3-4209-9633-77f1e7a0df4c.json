{"id": "2d00b739-13b3-4209-9633-77f1e7a0df4c", "code": "\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math, numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:  # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing s) rotated by rot rad, clipped & padded.\"\"\"\n    dy, pts, y, r = s * math.sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if r % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        r += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n)\n        r[i] = r[j] = 1.0\n        rows.append(r)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# stochastic refinement (single\u2011circle moves)\n# ----------------------------------------------------------------------\ndef _refine(start: np.ndarray, it: int = 800, step: float = .025,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best, best_val = start.copy(), _opt(start).sum()\n    for _ in range(it):\n        i = rng.randrange(len(best))\n        cand = best.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], .01, .99)\n        val = _opt(cand).sum()\n        if val > best_val:\n            best, best_val = cand, val\n    return best\n\n\n# ----------------------------------------------------------------------\n# multi\u2011restart polishing\n# ----------------------------------------------------------------------\ndef _polish(base: np.ndarray, rounds: int = 5) -> np.ndarray:\n    \"\"\"Run several short refinements from noisy copies of *base*.\"\"\"\n    best, best_val = base.copy(), _opt(base).sum()\n    for r in range(rounds):\n        # small Gaussian jitter then polish\n        jitter = np.random.normal(scale=0.01, size=base.shape)\n        start = np.clip(base + jitter, .01, .99)\n        cand = _refine(start, it=600, step=.02)\n        val = _opt(cand).sum()\n        if val > best_val:\n            best, best_val = cand, val\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 finer sweep + polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(.14, .22, 15)          # finer grid\n    rots = np.linspace(0, math.pi / 6, 7)       # more angles\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            v = _opt(pts).sum()\n            if v > best_sum:\n                best, best_sum = pts, v\n    # two\u2011stage polishing: coarse then multi\u2011restart\n    best = _refine(best, it=1200, step=.02)\n    best = _polish(best, rounds=6)\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")", "language": "python", "parent_id": "ab55c1d0-5db0-4508-95f9-40dcd54984be", "generation": 5, "timestamp": 1764884003.948742, "iteration_found": 120, "metrics": {"validity": 1.0, "sum_radii": 2.4521197070900027, "target_ratio": 0.9305957142656558, "combined_score": 0.9305957142656558, "eval_time": 8.26518201828003}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.5017372807813523, "target_ratio": 0.9494259130100009, "combined_score": 0.9494259130100009, "eval_time": 1.9336159229278564}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.9494\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness improved: 0.9476 \u2192 0.9494\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4969, target_ratio: 0.9476, combined_score: 0.9476, eval_time: 1.4793\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5017, target_ratio: 0.9494, combined_score: 0.9494, eval_time: 1.9336\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5036, target_ratio: 0.9502, combined_score: 0.9502, eval_time: 2.5573\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9502)\n```python\n\"\"\"Compact 26\u2011circle packing with a cheap stochastic refinement.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Optional linear\u2011programming backend (SciPy)\n# ----------------------------------------------------------------------\ntry:                                 # fast exact optimiser if present\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                   # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# Geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) optionally rotated by *rot* radians.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    # centre\u2011pad if the lattice is too short\n    if pts.shape[0] < n:\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    # rotate about centre (0.5,0.5)\n    if rot:\n        c = pts - 0.5\n        cs, sn = np.cos(rot), np.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n    # keep a safe distance from the walls\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# Radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible and very fast.\"\"\"\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser (LP if available, else heuristic).\"\"\"\n    return _lp_optimize(c) if _HAS_LP else _heur_optimize(c)\n\n\n# ----------------------------------------------------------------------\n# Stochastic refinement\n# ----------------------------------------------------------------------\ndef _stochastic_refine(start: np.ndarray,\n                       iters: int = 1500,\n                       step: float = 0.03,\n                       seed: int | None = None) -> np.ndarray:\n    \"\"\"Random walk that keeps the layout with the highest \u03a3r.\"\"\"\n    rng = random.Random(seed)\n    best = start.copy()\n    best_val = _opt_radii(best).sum()\n\n    for _ in range(iters):\n        # pick a circle and propose a small move\n        i = rng.randrange(len(best))\n        cand = best.copy()\n        dx = (rng.random() * 2 - 1) * step\n        dy = (rng.random() * 2 - 1) * step\n        cand[i] += (dx, dy)\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > best_val:\n            best, best_val = cand, val\n    return best\n\n\n# ----------------------------------------------------------------------\n# Layout search \u2013 coarse sweep + stochastic polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return a centre layout with a large \u03a3r after a cheap global search.\"\"\"\n    # sweep spacing and a few rotation angles\n    spacings = np.linspace(0.14, 0.22, 9)\n    rotations = np.linspace(0, np.pi / 6, 5)          # 0\u00b0 \u2026 30\u00b0\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for rot in rotations:\n            pts = _hex_grid(n, s, rot)\n            rad = _opt_radii(pts)\n            total = rad.sum()\n            if total > best_sum:\n                best, best_sum = pts, total\n\n    # a short stochastic polish (fast heuristic runs)\n    best = _stochastic_refine(best, iters=1200, step=0.025)\n    return best\n\n\n# ----------------------------------------------------------------------\n# Public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# Helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Stochastic packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5036), Performs well on target_ratio (0.9502), Performs well on combined_score (0.9502), Performs well on eval_time (2.5573)\n\n### Program 2 (Score: 0.9494)\n```python\n\"\"\"Compact 26\u2011circle packing \u2013 concise version with rotation & stochastic polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math, numpy as np\nfrom itertools import combinations\n\n# ---- optional exact optimiser -------------------------------------------------\ntry:                     # SciPy gives a fast LP solver\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:       # pragma: no cover\n    _LP = False\n\n# ---- geometry ---------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy, pts, y, r = s * math.sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if r % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        r += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ---- radius optimisation ----------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c); b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n); r[i] = r[j] = 1.0\n        rows.append(r); rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s; r[j] *= s\n    return r\n\n_opt = _lp_opt if _LP else _heur_opt\n\n# ---- stochastic refinement --------------------------------------------------\ndef _refine(start: np.ndarray, it: int = 800, step: float = .025,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best, best_val = start.copy(), _opt(start).sum()\n    for _ in range(it):\n        i = rng.randrange(len(best))\n        cand = best.copy()\n        cand[i] += (rng.random()*2-1)*step, (rng.random()*2-1)*step\n        cand[i] = np.clip(cand[i], .01, .99)\n        val = _opt(cand).sum()\n        if val > best_val:\n            best, best_val = cand, val\n    return best\n\n# ---- layout search ---------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Sweep spacings & a few rotations, keep the best, then polish.\"\"\"\n    spacings = np.linspace(.14, .22, 9)\n    rots = np.linspace(0, math.pi/6, 5)      # 0\u00b0 \u2026 30\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            v = _opt(pts).sum()\n            if v > best_sum:\n                best, best_sum = pts, v\n    return _refine(best, it=1200, step=.02)\n\n# ---- public API -------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5017), Performs well on target_ratio (0.9494), Performs well on combined_score (0.9494), Performs well on eval_time (1.9336)\n\n### Program 3 (Score: 0.9476)\n```python\n\"\"\"Compact 26\u2011circle packing with a tiny stochastic polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, numpy as np\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\n# --------------------------------------------------------------\n# Optional LP backend (SciPy)\n# --------------------------------------------------------------\ntry:                         # exact optimiser if available\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:           # pragma: no cover\n    _LP = False\n\n# --------------------------------------------------------------\n# Geometry helpers\n# --------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) optionally rotated by *rot* rad.\"\"\"\n    dy, pts, y, r = s * sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if r % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y]); x += s\n        y += dy; r += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# --------------------------------------------------------------\n# Radius optimisation\n# --------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c); b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n); r[i] = r[j] = 1.0\n        rows.append(r); rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j]); r[i] *= s; r[j] *= s\n    return r\n\n_opt = _lp_opt if _LP else _heur_opt\n\n# --------------------------------------------------------------\n# Stochastic refinement (very cheap)\n# --------------------------------------------------------------\ndef _refine(start: np.ndarray, it: int = 800, step: float = .025,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best, bestv = start.copy(), _opt(start).sum()\n    for _ in range(it):\n        i = rng.randrange(len(best))\n        cand = best.copy()\n        cand[i] += (rng.random()*2-1)*step, (rng.random()*2-1)*step\n        cand[i] = np.clip(cand[i], .01, .99)\n        v = _opt(cand).sum()\n        if v > bestv:\n            best, bestv = cand, v\n    return best\n\n# --------------------------------------------------------------\n# Layout search \u2013 spacing + a few rotations + polish\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(.14, .22, 9)\n    rots = np.linspace(0, pi/6, 4)          # 0\u00b0 \u2026 30\u00b0\n    best, bestv = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            v = _opt(pts).sum()\n            if v > bestv:\n                best, bestv = pts, v\n    return _refine(best, it=600, step=.02)\n\n# --------------------------------------------------------------\n# Public constructor\n# --------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    cs, rs, tot = run_packing()\n    print(f\"Sum of radii: {tot:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4969), Performs well on target_ratio (0.9476), Performs well on combined_score (0.9476), Performs well on eval_time (1.4793)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9400)\n```python\n\"\"\"Hex\u2011lattice 26\u2011circle packing with a tiny layout search.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# --------------------------------------------------------------\n# Optional LP backend\n# --------------------------------------------------------------\ntry:                     # SciPy gives a fast exact optimiser\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:       # pragma: no cover\n    _HAS_LP = False\n\n# --------------------------------------------------------------\n# Geometry helpers\n# --------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice points with spacing *s* (clipped, padded).\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# --------------------------------------------------------------\n# Radius optimisation\n# --------------------------------------------------------------\ndef _lp_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_optimize(c) if _HAS_LP else _heur_optimize(c)\n\n# --------------------------------------------------------------\n# Layout search \u2013 try several spacings & cheap hill\u2011climb\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return the centre layout with the largest \u03a3r among a few spacings.\"\"\"\n    candidates = np.linspace(0.14, 0.22, 9)          # coarse sweep around 0.18\n    best, best_sum = None, -1.0\n    for s in candidates:\n        pts = _hex_grid(n, s)\n        rad = _opt_radii(pts)\n        total = rad.sum()\n        if total > best_sum:\n            best, best_sum = pts, total\n    return best\n\ndef _local_search(centers: np.ndarray,\n                  steps: int = 6,\n                  delta: float = 0.012) -> np.ndarray:\n    \"\"\"Very cheap hill\u2011climb: move each centre \u00b1\u03b4 if total radius grows.\"\"\"\n    best = centers.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n# --------------------------------------------------------------\n# Public constructor\n# --------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    pts = _best_layout(26)\n    pts = _local_search(pts)                     # tiny refinement\n    rad = _opt_radii(pts)\n    return pts, rad, float(rad.sum())\n\n# --------------------------------------------------------------\n# Helper / entry\u2011point (unchanged API)\n# --------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9400, Type: High-Performer)\n```python\n\"\"\"Hex\u2011lattice 26\u2011circle packing with a tiny layout search.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# --------------------------------------------------------------\n# Optional LP backend\n# --------------------------------------------------------------\ntry:                     # SciPy gives a fast exact optimiser\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:       # pragma: no cover\n    _HAS_LP = False\n\n# --------------------------------------------------------------\n# Geometry helpers\n# --------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice points with spacing *s* (clipped, padded).\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# --------------------------------------------------------------\n# Radius optimisation\n# --------------------------------------------------------------\ndef _lp_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_optimize(c) if _HAS_LP else _heur_optimize(c)\n\n# --------------------------------------------------------------\n# Layout search \u2013 try several spacings & cheap hill\u2011climb\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return the centre layout with the largest \u03a3r among a few spacings.\"\"\"\n    candidates = np.linspace(0.14, 0.22, 9)          # coarse sweep around 0.18\n    best, best_sum = None, -1.0\n    for s in candidates:\n        pts = _hex_grid(n, s)\n        rad = _opt_radii(pts)\n        total = rad.sum()\n        if total > best_sum:\n            best, best_sum = pts, total\n    return best\n\ndef _local_search(centers: np.ndarray,\n                  steps: int = 6,\n                  delta: float = 0.012) -> np.ndarray:\n    \"\"\"Very cheap hill\u2011climb: move each centre \u00b1\u03b4 if total radius grows.\"\"\"\n    best = centers.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n# --------------------------------------------------------------\n# Public constructor\n# --------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    pts = _best_layout(26)\n    pts = _local_search(pts)                     # tiny refinement\n    rad = _opt_radii(pts)\n    return pts, rad, float(rad.sum())\n\n# --------------------------------------------------------------\n# Helper / entry\u2011point (unchanged API)\n# --------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Excellent validity (1.000), Excellent sum_radii (2.477), Excellent target_ratio (0.940)\n\n### Inspiration 2 (Score: 0.9476, Type: High-Performer)\n```python\n\"\"\"Compact 26\u2011circle packing with a tiny stochastic polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, numpy as np\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\n# --------------------------------------------------------------\n# Optional LP backend (SciPy)\n# --------------------------------------------------------------\ntry:                         # exact optimiser if available\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:           # pragma: no cover\n    _LP = False\n\n# --------------------------------------------------------------\n# Geometry helpers\n# --------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) optionally rotated by *rot* rad.\"\"\"\n    dy, pts, y, r = s * sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if r % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y]); x += s\n        y += dy; r += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# --------------------------------------------------------------\n# Radius optimisation\n# --------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c); b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n); r[i] = r[j] = 1.0\n        rows.append(r); rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j]); r[i] *= s; r[j] *= s\n    return r\n\n_opt = _lp_opt if _LP else _heur_opt\n\n# --------------------------------------------------------------\n# Stochastic refinement (very cheap)\n# --------------------------------------------------------------\ndef _refine(start: np.ndarray, it: int = 800, step: float = .025,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best, bestv = start.copy(), _opt(start).sum()\n    for _ in range(it):\n        i = rng.randrange(len(best))\n        cand = best.copy()\n        cand[i] += (rng.random()*2-1)*step, (rng.random()*2-1)*step\n        cand[i] = np.clip(cand[i], .01, .99)\n        v = _opt(cand).sum()\n        if v > bestv:\n            best, bestv = cand, v\n    return best\n\n# --------------------------------------------------------------\n# Layout search \u2013 spacing + a few rotations + polish\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(.14, .22, 9)\n    rots = np.linspace(0, pi/6, 4)          # 0\u00b0 \u2026 30\u00b0\n    best, bestv = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            v = _opt(pts).sum()\n            if v > bestv:\n                best, bestv = pts, v\n    return _refine(best, it=600, step=.02)\n\n# --------------------------------------------------------------\n# Public constructor\n# --------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    cs, rs, tot = run_packing()\n    print(f\"Sum of radii: {tot:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.497)\n\n### Inspiration 3 (Score: 0.9502, Type: High-Performer)\n```python\n\"\"\"Compact 26\u2011circle packing with a cheap stochastic refinement.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Optional linear\u2011programming backend (SciPy)\n# ----------------------------------------------------------------------\ntry:                                 # fast exact optimiser if present\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                   # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# Geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) optionally rotated by *rot* radians.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    # centre\u2011pad if the lattice is too short\n    if pts.shape[0] < n:\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    # rotate about centre (0.5,0.5)\n    if rot:\n        c = pts - 0.5\n        cs, sn = np.cos(rot), np.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n    # keep a safe distance from the walls\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# Radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible and very fast.\"\"\"\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser (LP if available, else heuristic).\"\"\"\n    return _lp_optimize(c) if _HAS_LP else _heur_optimize(c)\n\n\n# ----------------------------------------------------------------------\n# Stochastic refinement\n# ----------------------------------------------------------------------\ndef _stochastic_refine(start: np.ndarray,\n                       iters: int = 1500,\n                       step: float = 0.03,\n                       seed: int | None = None) -> np.ndarray:\n    \"\"\"Random walk that keeps the layout with the highest \u03a3r.\"\"\"\n    rng = random.Random(seed)\n    best = start.copy()\n    best_val = _opt_radii(best).sum()\n\n    for _ in range(iters):\n        # pick a circle and propose a small move\n        i = rng.randrange(len(best))\n        cand = best.copy()\n        dx = (rng.random() * 2 - 1) * step\n        dy = (rng.random() * 2 - 1) * step\n        cand[i] += (dx, dy)\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > best_val:\n            best, best_val = cand, val\n    return best\n\n\n# ----------------------------------------------------------------------\n# Layout search \u2013 coarse sweep + stochastic polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return a centre layout with a large \u03a3r after a cheap global search.\"\"\"\n    # sweep spacing and a few rotation angles\n    spacings = np.linspace(0.14, 0.22, 9)\n    rotations = np.linspace(0, np.pi / 6, 5)          # 0\u00b0 \u2026 30\u00b0\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for rot in rotations:\n            pts = _hex_grid(n, s, rot)\n            rad = _opt_radii(pts)\n            total = rad.sum()\n            if total > best_sum:\n                best, best_sum = pts, total\n\n    # a short stochastic polish (fast heuristic runs)\n    best = _stochastic_refine(best, iters=1200, step=0.025)\n    return best\n\n\n# ----------------------------------------------------------------------\n# Public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# Helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Stochastic packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.504)\n\n# Current Program\n```python\n\"\"\"Compact 26\u2011circle packing \u2013 concise version with rotation & stochastic polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math, numpy as np\nfrom itertools import combinations\n\n# ---- optional exact optimiser -------------------------------------------------\ntry:                     # SciPy gives a fast LP solver\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:       # pragma: no cover\n    _LP = False\n\n# ---- geometry ---------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy, pts, y, r = s * math.sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if r % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        r += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ---- radius optimisation ----------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c); b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n); r[i] = r[j] = 1.0\n        rows.append(r); rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s; r[j] *= s\n    return r\n\n_opt = _lp_opt if _LP else _heur_opt\n\n# ---- stochastic refinement --------------------------------------------------\ndef _refine(start: np.ndarray, it: int = 800, step: float = .025,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best, best_val = start.copy(), _opt(start).sum()\n    for _ in range(it):\n        i = rng.randrange(len(best))\n        cand = best.copy()\n        cand[i] += (rng.random()*2-1)*step, (rng.random()*2-1)*step\n        cand[i] = np.clip(cand[i], .01, .99)\n        val = _opt(cand).sum()\n        if val > best_val:\n            best, best_val = cand, val\n    return best\n\n# ---- layout search ---------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Sweep spacings & a few rotations, keep the best, then polish.\"\"\"\n    spacings = np.linspace(.14, .22, 9)\n    rots = np.linspace(0, math.pi/6, 5)      # 0\u00b0 \u2026 30\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            v = _opt(pts).sum()\n            if v > best_sum:\n                best, best_sum = pts, v\n    return _refine(best, it=1200, step=.02)\n\n# ---- public API -------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math, numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:  # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing s) rotated by rot rad, clipped & padded.\"\"\"\n    dy, pts, y, r = s * math.sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if r % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        r += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n)\n        r[i] = r[j] = 1.0\n        rows.append(r)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# stochastic refinement (single\u2011circle moves)\n# ----------------------------------------------------------------------\ndef _refine(start: np.ndarray, it: int = 800, step: float = .025,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best, best_val = start.copy(), _opt(start).sum()\n    for _ in range(it):\n        i = rng.randrange(len(best))\n        cand = best.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], .01, .99)\n        val = _opt(cand).sum()\n        if val > best_val:\n            best, best_val = cand, val\n    return best\n\n\n# ----------------------------------------------------------------------\n# multi\u2011restart polishing\n# ----------------------------------------------------------------------\ndef _polish(base: np.ndarray, rounds: int = 5) -> np.ndarray:\n    \"\"\"Run several short refinements from noisy copies of *base*.\"\"\"\n    best, best_val = base.copy(), _opt(base).sum()\n    for r in range(rounds):\n        # small Gaussian jitter then polish\n        jitter = np.random.normal(scale=0.01, size=base.shape)\n        start = np.clip(base + jitter, .01, .99)\n        cand = _refine(start, it=600, step=.02)\n        val = _opt(cand).sum()\n        if val > best_val:\n            best, best_val = cand, val\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 finer sweep + polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(.14, .22, 15)          # finer grid\n    rots = np.linspace(0, math.pi / 6, 7)       # more angles\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            v = _opt(pts).sum()\n            if v > best_sum:\n                best, best_sum = pts, v\n    # two\u2011stage polishing: coarse then multi\u2011restart\n    best = _refine(best, it=1200, step=.02)\n    best = _polish(best, rounds=6)\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}