{"id": "c9357b7f-6b73-4f98-9aa1-cbf133e1251a", "code": "# EVOLVE-BLOCK-START\n\"\"\"Compact 26\u2011circle packing with enhanced multi\u2011start search.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) clipped to the unit square.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if needed\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, else deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    if _HAS_LP:\n        res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                     bounds=[(0, bi) for bi in b],\n                     method=\"highs\", options={\"presolve\": True})\n        return res.x if res.success else b\n    # fallback \u2013 deterministic pairwise scaling\n    r = b.copy()\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\n# ----------------------------------------------------------------------\n# light physics\u2011style relaxation (spreads points a little)\n# ----------------------------------------------------------------------\ndef _relax(c: np.ndarray, iters: int = 30, step: float = 0.006) -> np.ndarray:\n    n = len(c)\n    for _ in range(iters):\n        forces = np.zeros_like(c)\n        for i, j in combinations(range(n), 2):\n            diff = c[i] - c[j]\n            d = np.linalg.norm(diff)\n            if d == 0.0:\n                continue\n            f = diff / (d * d)                 # inverse\u2011square repulsion\n            forces[i] += f\n            forces[j] -= f\n        c += step * forces\n        c = np.clip(c, 0.01, 0.99)\n    return c\n\n\n# ----------------------------------------------------------------------\n# deterministic jitter (fixed seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    return np.clip(c + (2 * _rng.random(c.shape) - 1) * scale, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense multi\u2011start + relaxation\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best_c, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweep promising spacings\n        base = _hex_grid(n, s)\n\n        # plain + relaxed\n        cand = _relax(base.copy())\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best_c, best_sum = cand, total\n\n        # jittered starts (deterministic)\n        for _ in range(6):\n            cand = _relax(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best_c, best_sum = cand, total\n    return best_c\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "937df538-5968-4bb0-9b31-62bb6c4be737", "generation": 3, "timestamp": 1764885128.7662039, "iteration_found": 175, "metrics": {"validity": 1.0, "sum_radii": 0.6722600977771351, "target_ratio": 0.25512717183192984, "combined_score": 0.25512717183192984}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.47825973144573, "target_ratio": 0.9405160271141292, "combined_score": 0.9405160271141292, "eval_time": 45.5510458946228}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.9405\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.9405\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4783, target_ratio: 0.9405, combined_score: 0.9405, eval_time: 58.7847\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4783, target_ratio: 0.9405, combined_score: 0.9405, eval_time: 48.2891\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4783, target_ratio: 0.9405, combined_score: 0.9405, eval_time: 45.5510\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9405)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; clipped & centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# deterministic jitter (fixed seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep a few spacings, keep the best layout\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered restarts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4783), Performs well on target_ratio (0.9405), Performs well on combined_score (0.9405), Performs well on eval_time (45.5510)\n\n### Program 2 (Score: 0.9405)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional LP backend\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; clipped and centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n\n# ----------------------------------------------------------------------\n# deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# jitter (deterministic seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep spacings, jittered starts, keep best\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered restarts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4783), Performs well on target_ratio (0.9405), Performs well on combined_score (0.9405), Performs well on eval_time (48.2891)\n\n### Program 3 (Score: 0.9405)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\nThe algorithm follows the best\u2011performing variants:\n  1. Sweep a few hex\u2011lattice spacings.\n  2. For each spacing launch a few jittered starts and a tiny deterministic\n     hill\u2011climb that keeps any move raising the total radius.\n  3. Radii are maximised by a linear programme when SciPy is present,\n     otherwise by a deterministic pair\u2011wise scaling heuristic.\n  4. The layout with the largest \u03a3\u202fr is returned.\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; clipped and centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# deterministic jitter (fixed seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep spacings, jittered starts, keep best\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered starts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4783), Performs well on target_ratio (0.9405), Performs well on combined_score (0.9405), Performs well on eval_time (58.7847)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9405)\n```python\n\"\"\"26\u2011circle packing \u2013 compact multi\u2011start hill\u2011climb.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----- optional exact optimiser (SciPy) ---------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----- geometry helpers -------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*), clipped and centre\u2011padded.\"\"\"\n    dy, pts, y, row = s * np.sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----- radius optimisation ---------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n, b = len(c), _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n); row[i] = row[j] = 1.0\n        rows.append(row); rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j]); r[i] *= f; r[j] *= f\n    return r\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n# ----- deterministic hill\u2011climb ----------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta,0),(-delta,0),(0,delta),(0,-delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved: break\n    return best\n\n# ----- jittered multi\u2011start --------------------------------------------\n_rng = np.random.default_rng(12345)          # deterministic seed\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n# ----- layout search ---------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweep a few spacings\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum: best, best_sum = cand, total\n\n        # a few jittered starts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum: best, best_sum = cand, total\n    return best\n\n# ----- public constructor -----------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n# ----- helper / entry\u2011point ---------------------------------------------\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9405)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Compact 26\u2011circle packing with a tiny multi\u2011start local search.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----- optional exact optimiser (SciPy) ---------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----- geometry helpers -------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) clipped to the unit square.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----- radius optimisation ---------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n# ----- tiny deterministic hill\u2011climb ------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n# ----- deterministic jitter (fixed seed) -------------------------------\n_rng = np.random.default_rng(12345)\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n# ----- layout search ----------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweep promising spacings\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered starts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n# ----- public constructor ------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n# ----- helper / entry\u2011point --------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0683, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice base with simple repulsive relaxation and LP (or fallback) radius optimisation.\n\nAPI (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Layout generation \u2013 hexagonal seed\n# ----------------------------------------------------------------------\ndef _hex_seed(n: int) -> np.ndarray:\n    \"\"\"Place \u2264\u202fn points on a triangular lattice inside the unit square.\"\"\"\n    s = 0.18                       # tuned spacing for 26 circles\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                       # pad centre if required\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Tiny physics\u2011style relaxation \u2013 spreads points a little more\n# ----------------------------------------------------------------------\ndef _relax(centers: np.ndarray, iters: int = 80, step: float = 0.006) -> np.ndarray:\n    \"\"\"Repulsive push\u2011apart iteration, keeping points inside the unit square.\"\"\"\n    n = len(centers)\n    for _ in range(iters):\n        forces = np.zeros_like(centers)\n        for i, j in combinations(range(n), 2):\n            diff = centers[i] - centers[j]\n            d = np.linalg.norm(diff)\n            if d == 0.0:\n                continue\n            # simple inverse\u2011square repulsion\n            f = diff / (d * d)\n            forces[i] += f\n            forces[j] -= f\n        centers += step * forces\n        # stay away from the border (tiny margin)\n        centers = np.clip(centers, 0.01, 0.99)\n    return centers\n\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Radius optimisation \u2013 LP if SciPy is present, otherwise heuristic\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_optimize(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear programme: maximise \u03a3r subject to border & non\u2011overlap constraints.\"\"\"\n    n = len(centers)\n    # maximal radius limited by the four sides\n    border = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = (np.array(rows) if rows else None), (np.array(rhs) if rhs else None)\n    c = -np.ones(n)                     # maximise \u2192 minimise \u2013\u03a3r\n    bounds = [(0, ub) for ub in border]\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else border\n\n\ndef _heuristic_optimize(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Pair\u2011wise scaling \u2013 always yields a feasible solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Public constructor\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_seed(26)\n    centers = _relax(centers)                     # spread them a bit more\n    radii = _lp_optimize(centers) if _HAS_LP else _heuristic_optimize(centers)\n    return centers, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Alternative sum_radii approach\n\n### Inspiration 2 (Score: 0.8273, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice 26\u2011circle packing with LP\u2011based radius optimisation.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\n# try to import a fast LP solver; fall back to a simple heuristic\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _hex_positions(n: int) -> np.ndarray:\n    \"\"\"Generate \u2248\u221an rows of a triangular lattice inside the unit square.\"\"\"\n    s = 0.18                         # spacing tuned for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    # pad if the lattice produced too few points (unlikely for n=26)\n    if pts.shape[0] < n:\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\ndef _lp_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r subject to border & pairwise constraints.\"\"\"\n    n = len(centers)\n    # border limits\n    borders = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    # build pairwise rows for r_i + r_j \u2264 d_ij\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = np.array(rows) if rows else None, np.array(rhs) if rhs else None\n    c = -np.ones(n)                     # maximise \u2192 minimise -\u03a3r\n    bounds = [(0, bnd) for bnd in borders]\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _heuristic_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Iterative pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_positions(26)\n    radii = _lp_radii(centers) if _HAS_LP else _heuristic_radii(centers)\n    return centers, radii, float(radii.sum())\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.180)\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Compact 26\u2011circle packing with a tiny multi\u2011start search.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np, itertools, random\n\n# ---------- optional exact optimiser ----------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                         # pragma: no cover\n    _LP = False\n\n# ---------- geometry helpers ----------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) clipped to the unit square.\"\"\"\n    dy, pts, y, row = s * np.sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ---------- radius optimisation ----------\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"LP if available, else deterministic pairwise scaling.\"\"\"\n    if _LP:\n        n = len(c)\n        b = _border(c)\n        rows, rhs = [], []\n        for i, j in itertools.combinations(range(n), 2):\n            row = np.zeros(n); row[i] = row[j] = 1.0\n            rows.append(row); rhs.append(np.linalg.norm(c[i] - c[j]))\n        A = np.array(rows) if rows else None\n        ub = np.array(rhs) if rhs else None\n        res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                      bounds=[(0, bi) for bi in b], method='highs')\n        return res.x if res.success else b\n    # ---- heuristic fallback ----\n    r = _border(c).copy()\n    for i, j in itertools.combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j]); r[i] *= f; r[j] *= f\n    return r\n\n# ---------- local search ----------\ndef _hill_climb(c: np.ndarray, steps: int = 5, \u03b4: float = 0.01) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((\u03b4,0),(-\u03b4,0),(0,\u03b4),(0,-\u03b4)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved: break\n    return best\n\n_rng = np.random.default_rng(12345)\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    return np.clip(c + (2*_rng.random(c.shape)-1)*scale, 0.01, 0.99)\n\n# ---------- layout search ----------\ndef _best_layout() -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):        # sweep spacings\n        base = _hex_grid(26, s)\n        for start in (base, *_jitter(base, 0.03) for _ in range(2)):\n            cand = _hill_climb(start)\n            tot = _opt_radii(cand).sum()\n            if tot > best_sum:\n                best, best_sum = cand, tot\n    return best\n\n# ---------- public constructor ----------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout()\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n# EVOLVE-BLOCK-END\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\ndef visualize(centres, radii):\n    \"\"\"Optional visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n    fig, ax = plt.subplots(figsize=(6,6))\n    ax.set_aspect('equal'); ax.set_xlim(0,1); ax.set_ylim(0,1); ax.grid(True)\n    for i,(c,r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Alternative validity approach, Alternative combined_score approach\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; clipped & centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# deterministic jitter (fixed seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep a few spacings, keep the best layout\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered restarts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Compact 26\u2011circle packing with enhanced multi\u2011start search.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) clipped to the unit square.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if needed\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, else deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    if _HAS_LP:\n        res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                     bounds=[(0, bi) for bi in b],\n                     method=\"highs\", options={\"presolve\": True})\n        return res.x if res.success else b\n    # fallback \u2013 deterministic pairwise scaling\n    r = b.copy()\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\n# ----------------------------------------------------------------------\n# light physics\u2011style relaxation (spreads points a little)\n# ----------------------------------------------------------------------\ndef _relax(c: np.ndarray, iters: int = 30, step: float = 0.006) -> np.ndarray:\n    n = len(c)\n    for _ in range(iters):\n        forces = np.zeros_like(c)\n        for i, j in combinations(range(n), 2):\n            diff = c[i] - c[j]\n            d = np.linalg.norm(diff)\n            if d == 0.0:\n                continue\n            f = diff / (d * d)                 # inverse\u2011square repulsion\n            forces[i] += f\n            forces[j] -= f\n        c += step * forces\n        c = np.clip(c, 0.01, 0.99)\n    return c\n\n\n# ----------------------------------------------------------------------\n# deterministic jitter (fixed seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    return np.clip(c + (2 * _rng.random(c.shape) - 1) * scale, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense multi\u2011start + relaxation\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best_c, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweep promising spacings\n        base = _hex_grid(n, s)\n\n        # plain + relaxed\n        cand = _relax(base.copy())\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best_c, best_sum = cand, total\n\n        # jittered starts (deterministic)\n        for _ in range(6):\n            cand = _relax(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best_c, best_sum = cand, total\n    return best_c\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}