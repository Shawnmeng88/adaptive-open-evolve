{"id": "b2e37c22-1065-4114-98de-5ecd0110902f", "code": "\"\"\"Improved 26\u2011circle packing \u2013 tighter search + three\u2011stage polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                       # fast LP if SciPy is available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:         # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(best).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps diversity\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb \u2013 final polish\n# ----------------------------------------------------------------------\ndef _local_refine(layout: np.ndarray,\n                  delta: float = 0.008,\n                  passes: int = 3) -> np.ndarray:\n    \"\"\"Move each centre by \u00b1\u03b4 while it improves the radius sum.\"\"\"\n    best = layout.copy()\n    best_val = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                val = _opt_radii(cand).sum()\n                if val > best_val + 1e-12:\n                    best, best_val = cand, val\n                    improved = True\n        if not improved:\n            break\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # very fine sweep (more points than previous versions)\n    spacings = np.linspace(0.125, 0.245, 23)       # 23 spacings\n    rotations = np.linspace(0.0, math.pi / 4, 15) # 15 rotations\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, iters=1500, step=0.036, decay=0.998, seed=41)\n    best = _anneal(best, iters=2000, step=0.018, decay=0.9995, seed=99)\n    best = _anneal(best, iters=1200, step=0.009, decay=0.9999, seed=123)\n\n    # final deterministic tweak\n    best = _local_refine(best, delta=0.006, passes=2)\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")", "language": "python", "parent_id": "4f74d431-fbe0-4ba2-99b2-7c223657d58e", "generation": 6, "timestamp": 1764885033.235563, "iteration_found": 169, "metrics": {"validity": 1.0, "sum_radii": 2.524504674488625, "target_ratio": 0.9580662901285104, "combined_score": 0.9580662901285104, "eval_time": 9.266126871109009}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.50863563868774, "target_ratio": 0.9520438856499963, "combined_score": 0.9520438856499963, "eval_time": 4.550727844238281}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.9520\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.9531 \u2192 0.9520. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5114, target_ratio: 0.9531, combined_score: 0.9531, eval_time: 6.0913\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5114, target_ratio: 0.9531, combined_score: 0.9531, eval_time: 6.5127\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5151, target_ratio: 0.9545, combined_score: 0.9545, eval_time: 5.7984\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9545)\n```python\n\"\"\"Compact 26\u2011circle packing with a two\u2011stage stochastic polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nimport numpy as np\n\n# --------------------------------------------------------------\n# Optional exact optimiser (SciPy)\n# --------------------------------------------------------------\ntry:                         # linear\u2011programming if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:           # pragma: no cover\n    _USE_LP = False\n\n# --------------------------------------------------------------\n# Geometry helpers\n# --------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) optionally rotated by *rot* rad.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# --------------------------------------------------------------\n# Radius optimisation\n# --------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _USE_LP else _heur_opt\n\n# --------------------------------------------------------------\n# Two\u2011stage stochastic polish (simulated annealing)\n# --------------------------------------------------------------\ndef _anneal(start: np.ndarray, iters: int, step: float,\n            decay: float, seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    cur = best = start.copy()\n    cur_val = best_val = _opt(cur).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n        val = _opt(cand).sum()\n        # accept if better; occasional uphill move keeps diversity\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n# --------------------------------------------------------------\n# Layout search \u2013 dense sweep + two\u2011stage polishing\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_val = None, -1.0\n    # dense sweep of spacings & rotations\n    for s in np.linspace(0.13, 0.245, 19):          # finer spacing grid\n        for r in np.linspace(0.0, math.pi / 4, 13):  # up to 45\u00b0\n            pts = _grid(n, s, r)\n            val = _opt(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n    # two\u2011stage polish: coarse then fine\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n    return best\n\n# --------------------------------------------------------------\n# Public constructor\n# --------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5151), Performs well on target_ratio (0.9545), Performs well on combined_score (0.9545), Performs well on eval_time (5.7984)\n\n### Program 2 (Score: 0.9531)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search & two\u2011stage annealing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\n\n    The lattice is clipped to the unit square and padded with centre points\n    if fewer than *n* points are generated.\n    \"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    # keep a safe margin from the walls\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, otherwise deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows: list[np.ndarray] = []\n    rhs: list[float] = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            scale = d / (r[i] + r[j])\n            r[i] *= scale\n            r[j] *= scale\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\n\n    *iters* \u2013 number of proposals,\n    *step* \u2013 max displacement per coordinate,\n    *decay* \u2013 geometric decay of *step* after each iteration.\n    \"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better, otherwise allow a tiny uphill move\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search a large space of grids and polish the best candidate.\"\"\"\n    # --- dense sweep ----------------------------------------------------\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0 in 13 steps\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # --- two\u2011stage annealing -------------------------------------------\n    # coarse polishing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    # fine polishing\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# simple demo when executed directly\n# ----------------------------------------------------------------------\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5114), Performs well on target_ratio (0.9531), Performs well on combined_score (0.9531), Performs well on eval_time (6.5127)\n\n### Program 3 (Score: 0.9531)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search + two\u2011stage anneal.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                 # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                   # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps exploration alive\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search many grids then polish the best candidate.\"\"\"\n    # dense sweep\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # two\u2011stage annealing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5114), Performs well on target_ratio (0.9531), Performs well on combined_score (0.9531), Performs well on eval_time (6.0913)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9531)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search & two\u2011stage annealing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if SciPy is available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\n\n    The lattice is clipped to the unit square and padded with centre points\n    if fewer than *n* points are generated.\n    \"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    # keep a safe margin from the walls\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, otherwise deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows: list[np.ndarray] = []\n    rhs: list[float] = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            scale = d / (r[i] + r[j])\n            r[i] *= scale\n            r[j] *= scale\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\n\n    *iters* \u2013 number of proposals,\n    *step* \u2013 max displacement per coordinate,\n    *decay* \u2013 geometric decay of *step* after each iteration.\n    \"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps exploration alive\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search a large space of grids and polish the best candidate.\"\"\"\n    # --- dense sweep ----------------------------------------------------\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0 in 13 steps\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # --- two\u2011stage annealing -------------------------------------------\n    # coarse polishing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    # fine polishing\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# simple demo when executed directly\n# ----------------------------------------------------------------------\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9521)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math, numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n)\n        r[i] = r[j] = 1.0\n        rows.append(r)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# stochastic refinement \u2013 simulated\u2011annealing style\n# ----------------------------------------------------------------------\ndef _refine(start: np.ndarray,\n            iters: int = 2500,\n            step: float = 0.04,\n            decay: float = 0.999,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = start.copy()\n    best_val = _opt_radii(best).sum()\n    cur = best.copy()\n    cur_val = best_val\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        dx = (rng.random() * 2 - 1) * step\n        dy = (rng.random() * 2 - 1) * step\n        cand[i] += (dx, dy)\n        cand[i] = np.clip(cand[i], .01, .99)\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:   # occasional uphill move\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + refinement\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(0.135, 0.235, 13)      # finer spacing grid\n    rots = np.linspace(0, math.pi / 4, 9)       # up to 45\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _hex_grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n    # two\u2011stage polishing: coarse then fine annealing\n    best = _refine(best, iters=1200, step=0.03, decay=0.998, seed=1)\n    best = _refine(best, iters=1800, step=0.015, decay=0.9995, seed=2)\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# entry\u2011point used by the evaluation harness\n# ----------------------------------------------------------------------\ndef run_packing():\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9531, Type: High-Performer)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search & two\u2011stage annealing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if SciPy is available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\n\n    The lattice is clipped to the unit square and padded with centre points\n    if fewer than *n* points are generated.\n    \"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    # keep a safe margin from the walls\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, otherwise deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows: list[np.ndarray] = []\n    rhs: list[float] = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            scale = d / (r[i] + r[j])\n            r[i] *= scale\n            r[j] *= scale\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\n\n    *iters* \u2013 number of proposals,\n    *step* \u2013 max displacement per coordinate,\n    *decay* \u2013 geometric decay of *step* after each iteration.\n    \"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps exploration alive\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search a large space of grids and polish the best candidate.\"\"\"\n    # --- dense sweep ----------------------------------------------------\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0 in 13 steps\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # --- two\u2011stage annealing -------------------------------------------\n    # coarse polishing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    # fine polishing\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# simple demo when executed directly\n# ----------------------------------------------------------------------\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.511)\n\n### Inspiration 2 (Score: 0.9521, Type: High-Performer)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math, numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n)\n        r[i] = r[j] = 1.0\n        rows.append(r)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# stochastic refinement \u2013 simulated\u2011annealing style\n# ----------------------------------------------------------------------\ndef _refine(start: np.ndarray,\n            iters: int = 2500,\n            step: float = 0.04,\n            decay: float = 0.999,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = start.copy()\n    best_val = _opt_radii(best).sum()\n    cur = best.copy()\n    cur_val = best_val\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        dx = (rng.random() * 2 - 1) * step\n        dy = (rng.random() * 2 - 1) * step\n        cand[i] += (dx, dy)\n        cand[i] = np.clip(cand[i], .01, .99)\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:   # occasional uphill move\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + refinement\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(0.135, 0.235, 13)      # finer spacing grid\n    rots = np.linspace(0, math.pi / 4, 9)       # up to 45\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _hex_grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n    # two\u2011stage polishing: coarse then fine annealing\n    best = _refine(best, iters=1200, step=0.03, decay=0.998, seed=1)\n    best = _refine(best, iters=1800, step=0.015, decay=0.9995, seed=2)\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# entry\u2011point used by the evaluation harness\n# ----------------------------------------------------------------------\ndef run_packing():\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.509)\n\n### Inspiration 3 (Score: 0.9400, Type: High-Performer)\n```python\n\"\"\"Hex\u2011lattice 26\u2011circle packing with a tiny layout search.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# --------------------------------------------------------------\n# Optional LP backend\n# --------------------------------------------------------------\ntry:                     # SciPy gives a fast exact optimiser\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:       # pragma: no cover\n    _HAS_LP = False\n\n# --------------------------------------------------------------\n# Geometry helpers\n# --------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice points with spacing *s* (clipped, padded).\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# --------------------------------------------------------------\n# Radius optimisation\n# --------------------------------------------------------------\ndef _lp_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_optimize(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_optimize(c) if _HAS_LP else _heur_optimize(c)\n\n# --------------------------------------------------------------\n# Layout search \u2013 try several spacings & cheap hill\u2011climb\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return the centre layout with the largest \u03a3r among a few spacings.\"\"\"\n    candidates = np.linspace(0.14, 0.22, 9)          # coarse sweep around 0.18\n    best, best_sum = None, -1.0\n    for s in candidates:\n        pts = _hex_grid(n, s)\n        rad = _opt_radii(pts)\n        total = rad.sum()\n        if total > best_sum:\n            best, best_sum = pts, total\n    return best\n\ndef _local_search(centers: np.ndarray,\n                  steps: int = 6,\n                  delta: float = 0.012) -> np.ndarray:\n    \"\"\"Very cheap hill\u2011climb: move each centre \u00b1\u03b4 if total radius grows.\"\"\"\n    best = centers.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n# --------------------------------------------------------------\n# Public constructor\n# --------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    pts = _best_layout(26)\n    pts = _local_search(pts)                     # tiny refinement\n    rad = _opt_radii(pts)\n    return pts, rad, float(rad.sum())\n\n# --------------------------------------------------------------\n# Helper / entry\u2011point (unchanged API)\n# --------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Excellent validity (1.000), Excellent sum_radii (2.477), Excellent target_ratio (0.940)\n\n# Current Program\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math\nimport numpy as np\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                         # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:           # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice of spacing *s* rotated by *rot* (radians).\"\"\"\n    dy = s * sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius allowed by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int = 2000,\n            step: float = 0.04,\n            decay: float = 0.999,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(best).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        dx = (rng.random() * 2 - 1) * step\n        dy = (rng.random() * 2 - 1) * step\n        cand[i] += (dx, dy)\n        cand[i] = np.clip(cand[i], .01, .99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better or with a tiny uphill probability\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 coarse sweep + two\u2011stage annealing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # broader, finer sweep than the previous version\n    spacings = np.linspace(0.13, 0.24, 15)          # 15 spacings\n    rots = np.linspace(0, pi / 4, 9)               # up to 45\u00b0\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # two\u2011stage annealing: coarse then fine\n    best = _anneal(best, iters=1200, step=0.03, decay=0.998, seed=1)\n    best = _anneal(best, iters=1800, step=0.015, decay=0.9995, seed=2)\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"Improved 26\u2011circle packing \u2013 tighter search + three\u2011stage polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                       # fast LP if SciPy is available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:         # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(best).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps diversity\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb \u2013 final polish\n# ----------------------------------------------------------------------\ndef _local_refine(layout: np.ndarray,\n                  delta: float = 0.008,\n                  passes: int = 3) -> np.ndarray:\n    \"\"\"Move each centre by \u00b1\u03b4 while it improves the radius sum.\"\"\"\n    best = layout.copy()\n    best_val = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                val = _opt_radii(cand).sum()\n                if val > best_val + 1e-12:\n                    best, best_val = cand, val\n                    improved = True\n        if not improved:\n            break\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # very fine sweep (more points than previous versions)\n    spacings = np.linspace(0.125, 0.245, 23)       # 23 spacings\n    rotations = np.linspace(0.0, math.pi / 4, 15) # 15 rotations\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, iters=1500, step=0.036, decay=0.998, seed=41)\n    best = _anneal(best, iters=2000, step=0.018, decay=0.9995, seed=99)\n    best = _anneal(best, iters=1200, step=0.009, decay=0.9999, seed=123)\n\n    # final deterministic tweak\n    best = _local_refine(best, delta=0.006, passes=2)\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nThis rewrite tightens the search (more spacings/rotations), adds a third annealing stage with a finer step, and finishes with a tiny deterministic hill\u2011climb. The public API is unchanged, but the richer optimisation pipeline typically raises the combined fitness score above the previous 0.952\u202fbaseline."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}