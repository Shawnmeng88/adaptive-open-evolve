{"id": "48ee8508-3cc7-4493-a3da-0346bee23250", "code": "# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011grid circle packing for 26 circles with LP fallback.\"\"\"\n\nimport numpy as np, itertools\n\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:\n    _LP = False\n\n\ndef _hex(n: int) -> np.ndarray:\n    \"\"\"Place \u2264\u202fn points on a triangular (hex) lattice inside the unit square.\"\"\"\n    s = 0.18                     # spacing tuned for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _lp_optimize(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & non\u2011overlap constraints.\"\"\"\n    n = len(centers)\n    borders = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    rows, rhs = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = (np.array(rows) if rows else None), (np.array(rhs) if rhs else None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                  bounds=[(0, bb) for bb in borders],\n                  method='highs')\n    return res.x if res.success else borders\n\n\ndef _heuristic_optimize(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Simple pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    rad = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    for i, j in itertools.combinations(range(len(centers)), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _hex(26)\n    radii = _lp_optimize(centres) if _LP else _heuristic_optimize(centres)\n    return centres, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (n={len(centres)}, sum={radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centres, radii, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(centres, radii)   # uncomment to see the layout", "language": "python", "parent_id": "8ae0fd03-ad32-488e-bbdc-f6b06f662e15", "generation": 3, "timestamp": 1764881201.800822, "iteration_found": 22, "metrics": {"validity": 1.0, "sum_radii": 2.1799999999999993, "target_ratio": 0.827324478178368, "combined_score": 0.827324478178368, "eval_time": 0.2036888599395752}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 1.6536418300430262, "target_ratio": 0.627568056942325, "combined_score": 0.627568056942325, "eval_time": 0.12018203735351562}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.6276\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.8273 \u2192 0.6276. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.1800, target_ratio: 0.8273, combined_score: 0.8273, eval_time: 0.2122\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.1800, target_ratio: 0.8273, combined_score: 0.8273, eval_time: 0.2085\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.1800, target_ratio: 0.8273, combined_score: 0.8273, eval_time: 0.2152\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.8273)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice circle packing for n=26 with LP (or fallback) radius optimisation.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                     # pragma: no cover\n    _LP = False\n\n\ndef _hex_positions(n):\n    \"\"\"Generate \u2248\u221an rows of a hex lattice inside the unit square.\"\"\"\n    s = 0.18                              # tuned spacing\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if needed\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\ndef _lp_radii(centers):\n    \"\"\"LP maximise \u03a3r  s.t. border and pairwise distance constraints.\"\"\"\n    n = len(centers)\n    borders = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                                1 - centers[:, 0], 1 - centers[:, 1]])\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = np.array(rows) if rows else None, np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                  bounds=[(0, b) for b in borders],\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _heuristic_radii(centers):\n    \"\"\"Simple pairwise scaling \u2013 always feasible.\"\"\"\n    rad = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                             1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(len(centers)), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_positions(26)\n    radii = _lp_radii(centers) if _LP else _heuristic_radii(centers)\n    return centers, radii, float(radii.sum())\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.1800), Performs well on target_ratio (0.8273), Performs well on combined_score (0.8273), Performs well on eval_time (0.2152)\n\n### Program 2 (Score: 0.8273)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice 26\u2011circle packing with LP\u2011based radius optimisation.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\n# try to import a fast LP solver; fall back to a simple heuristic\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _hex_positions(n: int) -> np.ndarray:\n    \"\"\"Generate \u2248\u221an rows of a triangular lattice inside the unit square.\"\"\"\n    s = 0.18                         # spacing tuned for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    # pad if the lattice produced too few points (unlikely for n=26)\n    if pts.shape[0] < n:\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\ndef _lp_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r subject to border & pairwise constraints.\"\"\"\n    n = len(centers)\n    # border limits\n    borders = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    # build pairwise rows for r_i + r_j \u2264 d_ij\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = np.array(rows) if rows else None, np.array(rhs) if rhs else None\n    c = -np.ones(n)                     # maximise \u2192 minimise -\u03a3r\n    bounds = [(0, bnd) for bnd in borders]\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _heuristic_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Iterative pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_positions(26)\n    radii = _lp_radii(centers) if _HAS_LP else _heuristic_radii(centers)\n    return centers, radii, float(radii.sum())\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.1800), Performs well on target_ratio (0.8273), Performs well on combined_score (0.8273), Performs well on eval_time (0.2085)\n\n### Program 3 (Score: 0.8273)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice circle packing for n=26 with LP/heuristic radius optimisation.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:  # pragma: no cover\n    _LP = False\n\n\ndef _hex_positions(n):\n    \"\"\"Generate \u2248\u221an rows of a hex (triangular) lattice inside the unit square.\"\"\"\n    s = 0.18                     # lattice spacing \u2013 tuned for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    # clip to avoid boundary issues and pad if short\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\ndef _max_radii_lp(centers):\n    \"\"\"LP: maximise \u03a3r  subject to border and pairwise distance constraints.\"\"\"\n    n = len(centers)\n    borders = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                                 1 - centers[:, 0], 1 - centers[:, 1]])\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = np.array(rows) if rows else None, np.array(rhs) if rhs else None\n    c = -np.ones(n)                     # maximise \u2192 minimise -\u03a3r\n    bounds = [(0, b) for b in borders]\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _max_radii_heur(centers):\n    \"\"\"Simple pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                             1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_positions(26)\n    radii = _max_radii_lp(centers) if _LP else _max_radii_heur(centers)\n    return centers, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.1800), Performs well on target_ratio (0.8273), Performs well on combined_score (0.8273), Performs well on eval_time (0.2122)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.8273)\n```python\n\"\"\"Hex\u2011lattice circle packing for n=26 with optional LP optimisation.\n\nThe API matches the original program:\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Layout generation (hexagonal / triangular lattice)\n# ----------------------------------------------------------------------\ndef _hex_positions(n: int) -> np.ndarray:\n    \"\"\"Generate \u2248\u221an rows of a hex lattice inside the unit square.\"\"\"\n    s = 0.18                     # tuned spacing for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad with centre if needed\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\n# ----------------------------------------------------------------------\n# Radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_max_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r subject to borders & non\u2011overlap.\"\"\"\n    try:\n        from scipy.optimize import linprog\n    except Exception:          # SciPy missing \u2192 fallback\n        return _heuristic_radii(centers)\n\n    n = len(centers)\n    borders = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                                1 - centers[:, 0], 1 - centers[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = (np.array(rows) if rows else None), (np.array(rhs) if rhs else None)\n\n    c = -np.ones(n)                     # maximise \u2192 minimise -\u03a3r\n    bounds = [(0, bnd) for bnd in borders]\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _heuristic_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Iterative pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                             1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\n# ----------------------------------------------------------------------\n# Public constructor\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _hex_positions(26)\n    radii = _lp_max_radii(centres)   # LP if possible, else heuristic\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# Helper / visualisation (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.8273)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice circle packing for n=26 with LP (fallback heuristic).\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# --- try to import a fast LP solver ---------------------------------\ntry:                     # SciPy is the preferred backend\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:       # pragma: no cover\n    _HAS_LP = False\n\n\ndef _hex_grid(n: int) -> np.ndarray:\n    \"\"\"Place \u2264\u202fn points on a hex\u2011triangular lattice inside the unit square.\"\"\"\n    s = 0.18                         # spacing tuned for 26 circles\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    # clip away from the border and pad if we ran short\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:\n        pad = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, pad])\n    return pts\n\n\ndef _lp_optimize(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(centers)\n    # border limits\n    b = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                          1 - centers[:, 0], 1 - centers[:, 1]])\n\n    # pairwise distance constraints: r_i + r_j \u2264 d_ij\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n\n    # linprog minimises \u2013 we maximise \u03a3r \u2192 minimise -\u03a3r\n    c = -np.ones(n)\n    bounds = [(0, b_i) for b_i in b]\n    res = linprog(c, A_ub=A, b_ub=ub, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else b\n\n\ndef _heuristic_optimize(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Simple feasible scaling \u2013 always yields a valid solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                            1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_grid(26)\n    radii = _lp_optimize(centers) if _HAS_LP else _heuristic_optimize(centers)\n    return centers, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.8273, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice circle packing for n=26 with LP/heuristic radius optimisation.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:  # pragma: no cover\n    _LP = False\n\n\ndef _hex_positions(n):\n    \"\"\"Generate \u2248\u221an rows of a hex (triangular) lattice inside the unit square.\"\"\"\n    s = 0.18                     # lattice spacing \u2013 tuned for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    # clip to avoid boundary issues and pad if short\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\ndef _max_radii_lp(centers):\n    \"\"\"LP: maximise \u03a3r  subject to border and pairwise distance constraints.\"\"\"\n    n = len(centers)\n    borders = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                                 1 - centers[:, 0], 1 - centers[:, 1]])\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = np.array(rows) if rows else None, np.array(rhs) if rhs else None\n    c = -np.ones(n)                     # maximise \u2192 minimise -\u03a3r\n    bounds = [(0, b) for b in borders]\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _max_radii_heur(centers):\n    \"\"\"Simple pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                             1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_positions(26)\n    radii = _max_radii_lp(centers) if _LP else _max_radii_heur(centers)\n    return centers, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.180)\n\n### Inspiration 2 (Score: 0.8273, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011lattice circle packing for n=26 with LP (or fallback) radius optimisation.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                     # pragma: no cover\n    _LP = False\n\n\ndef _hex_positions(n):\n    \"\"\"Generate \u2248\u221an rows of a hex lattice inside the unit square.\"\"\"\n    s = 0.18                              # tuned spacing\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if needed\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\ndef _lp_radii(centers):\n    \"\"\"LP maximise \u03a3r  s.t. border and pairwise distance constraints.\"\"\"\n    n = len(centers)\n    borders = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                                1 - centers[:, 0], 1 - centers[:, 1]])\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = np.array(rows) if rows else None, np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                  bounds=[(0, b) for b in borders],\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _heuristic_radii(centers):\n    \"\"\"Simple pairwise scaling \u2013 always feasible.\"\"\"\n    rad = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                             1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(len(centers)), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centers = _hex_positions(26)\n    radii = _lp_radii(centers) if _LP else _heuristic_radii(centers)\n    return centers, radii, float(radii.sum())\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.180)\n\n### Inspiration 3 (Score: 0.8273, Type: High-Performer)\n```python\n\"\"\"Hex\u2011lattice circle packing for n=26 with optional LP optimisation.\n\nThe API matches the original program:\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Layout generation (hexagonal / triangular lattice)\n# ----------------------------------------------------------------------\ndef _hex_positions(n: int) -> np.ndarray:\n    \"\"\"Generate \u2248\u221an rows of a hex lattice inside the unit square.\"\"\"\n    s = 0.18                     # tuned spacing for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad with centre if needed\n        extra = np.full((n - pts.shape[0], 2), 0.5)\n        pts = np.vstack([pts, extra])\n    return pts\n\n\n# ----------------------------------------------------------------------\n# Radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_max_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r subject to borders & non\u2011overlap.\"\"\"\n    try:\n        from scipy.optimize import linprog\n    except Exception:          # SciPy missing \u2192 fallback\n        return _heuristic_radii(centers)\n\n    n = len(centers)\n    borders = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                                1 - centers[:, 0], 1 - centers[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = (np.array(rows) if rows else None), (np.array(rhs) if rhs else None)\n\n    c = -np.ones(n)                     # maximise \u2192 minimise -\u03a3r\n    bounds = [(0, bnd) for bnd in borders]\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    return res.x if res.success else borders\n\n\ndef _heuristic_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Iterative pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    n = len(centers)\n    rad = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                             1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\n# ----------------------------------------------------------------------\n# Public constructor\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _hex_positions(26)\n    radii = _lp_max_radii(centres)   # LP if possible, else heuristic\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# Helper / visualisation (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Hex packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.180)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Stochastic\u2011search constructor for 26 circles in a unit square.\"\"\"\n\nimport numpy as np\n\ndef _max_radii(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Largest radii that keep circles inside the square and non\u2011overlapping.\"\"\"\n    # distance to the four borders\n    rad = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    # enforce neighbour distances (radius \u2264 half centre\u2011to\u2011centre distance)\n    n = len(pts)\n    for i in range(n):\n        d = np.linalg.norm(pts[i] - pts[i + 1 :], axis=1)\n        if d.size:\n            rad[i] = min(rad[i], d.min() / 2)\n            rad[i + 1 :] = np.minimum(rad[i + 1 :], d / 2)\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_radii) for a high\u2011sum packing.\"\"\"\n    N, B, iters = 26, 0.01, 300          # circles, border margin, random tries\n    best_sum, best_pts = -1, None\n\n    # ---------- coarse random search ----------\n    for _ in range(iters):\n        pts = np.random.rand(N, 2) * (1 - 2 * B) + B   # uniform in [B,1\u2011B]\n        rad = _max_radii(pts)\n        s = rad.sum()\n        if s > best_sum:\n            best_sum, best_pts = s, pts.copy()\n\n    # ---------- local jitter refinement ----------\n    for _ in range(200):\n        i = np.random.randint(N)\n        cand = best_pts.copy()\n        cand[i] += (np.random.rand(2) - 0.5) * 0.02      # small move\n        cand[i] = np.clip(cand[i], B, 1 - B)\n        rad = _max_radii(cand)\n        s = rad.sum()\n        if s > best_sum:\n            best_sum, best_pts = s, cand\n\n    return best_pts, _max_radii(best_pts), float(best_sum)\n\n\n# EVOLVE-BLOCK-END\n\n\n# ----- fixed helper code (unchanged) ---------------------------------\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Display the packing using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (n={len(centres)}, sum={radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centres, radii, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # Uncomment to visualise:\n    # visualize(centres, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Hex\u2011grid circle packing for 26 circles with LP fallback.\"\"\"\n\nimport numpy as np, itertools\n\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:\n    _LP = False\n\n\ndef _hex(n: int) -> np.ndarray:\n    \"\"\"Place \u2264\u202fn points on a triangular (hex) lattice inside the unit square.\"\"\"\n    s = 0.18                     # spacing tuned for 26 points\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _lp_optimize(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & non\u2011overlap constraints.\"\"\"\n    n = len(centers)\n    borders = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    rows, rhs = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b = (np.array(rows) if rows else None), (np.array(rhs) if rhs else None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                  bounds=[(0, bb) for bb in borders],\n                  method='highs')\n    return res.x if res.success else borders\n\n\ndef _heuristic_optimize(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Simple pairwise scaling \u2013 always yields a feasible solution.\"\"\"\n    rad = np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n    for i, j in itertools.combinations(range(len(centers)), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if rad[i] + rad[j] > d:\n            s = d / (rad[i] + rad[j])\n            rad[i] *= s\n            rad[j] *= s\n    return rad\n\n\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _hex(26)\n    radii = _lp_optimize(centres) if _LP else _heuristic_optimize(centres)\n    return centres, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Convenient entry\u2011point used by the harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (n={len(centres)}, sum={radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centres, radii, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(centres, radii)   # uncomment to see the layout\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}