{"id": "3a541d8f-494c-4e43-9830-70301c511371", "code": "\"\"\"Simple deterministic circle packing for n=26.\n\nThe constructor builds a regular grid of points inside the unit square,\nthen scales the radii so that circles stay inside the square and do not\noverlap.  No external solvers are required \u2013 only NumPy.\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Helper functions (evolve\u2011block)\n# ----------------------------------------------------------------------\ndef _grid_positions(n: int) -> np.ndarray:\n    \"\"\"Return the first *n* points of an \u2248\u221an\u00d7\u221an grid, clipped to (0,1).\"\"\"\n    m = int(np.ceil(np.sqrt(n)))            # grid side length\n    xs = (np.arange(m) + 0.5) / m\n    ys = (np.arange(m) + 0.5) / m\n    pts = np.stack(np.meshgrid(xs, ys), -1).reshape(-1, 2)\n    pts = pts[:n]                            # keep only needed points\n    return np.clip(pts, 0.01, 0.99)           # stay away from the border\n\n\ndef _heuristic_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Scale radii so that every circle fits inside the square and does not overlap.\"\"\"\n    n = len(centers)\n    # start with the distance to the four borders\n    radii = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                               1 - centers[:, 0], 1 - centers[:, 1]])\n\n    # enforce pairwise non\u2011overlap by proportional scaling\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if radii[i] + radii[j] > d:\n            scale = d / (radii[i] + radii[j])\n            radii[i] *= scale\n            radii[j] *= scale\n    return radii\n\n\n# ----------------------------------------------------------------------\n# Public API (unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"\n    Build 26 circle centres and compute radii that maximise the total sum.\n    Returns (centres, radii, sum_of_radii).\n    \"\"\"\n    n = 26\n    centres = _grid_positions(n)\n    radii = _heuristic_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional visualisation using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (sum\u202f=\u202f{radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout", "language": "python", "parent_id": "4ff192f1-c4c8-4399-81e6-b3cc0c6db8d1", "generation": 1, "timestamp": 1764880960.693318, "iteration_found": 7, "metrics": {"validity": 1.0, "sum_radii": 1.4063237338707741, "target_ratio": 0.5337091969149048, "combined_score": 0.5337091969149048, "eval_time": 0.05517983436584473}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 0.9597642169962064, "target_ratio": 0.36423689449571406, "combined_score": 0.36423689449571406}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.3642\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.3642\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Metrics: validity: 1.0000, sum_radii: 0.9598, target_ratio: 0.3642, combined_score: 0.3642\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.0747, target_ratio: 0.7874, combined_score: 0.7874, eval_time: 0.0600\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.1667, target_ratio: 0.8223, combined_score: 0.8223, eval_time: 0.2368\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.8223)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved circle packing for n=26 using LP radii optimisation and a grid layout.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\ntry:\n    # SciPy provides a reliable linear\u2011programming solver.\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:               # pragma: no cover\n    _HAS_LP = False\n\n\ndef _grid_positions(n):\n    \"\"\"Create a simple (\u2248\u221an)\u00d7(\u2248\u221an) grid plus a centre point.\"\"\"\n    m = int(np.ceil(np.sqrt(n)))          # grid dimension\n    xs = (np.arange(m) + 0.5) / m\n    ys = (np.arange(m) + 0.5) / m\n    pts = np.array(np.meshgrid(xs, ys)).T.reshape(-1, 2)\n    if pts.shape[0] > n:                  # trim excess\n        pts = pts[:n]\n    elif pts.shape[0] < n:                # add centre if needed\n        extra = n - pts.shape[0]\n        centre = np.full((extra, 2), 0.5)\n        pts = np.vstack([pts, centre])\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _lp_max_radii(centers):\n    \"\"\"Linear\u2011programming solution: max \u03a3r_i  s.t.  r_i\u2264border, r_i+r_j\u2264dist_ij.\"\"\"\n    n = len(centers)\n    # border limits\n    borders = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                                 1 - centers[:, 0], 1 - centers[:, 1]])\n\n    # inequality matrix for pairwise constraints\n    rows = []\n    rhs = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A_ub = np.array(rows) if rows else None\n    b_ub = np.array(rhs) if rhs else None\n\n    # linprog minimises; we maximise \u03a3r_i \u2192 minimise -\u03a3r_i\n    c = -np.ones(n)\n    bounds = [(0, b) for b in borders]\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    if res.success:\n        return res.x\n    # fallback: use the border limits (still valid)\n    return borders\n\n\ndef _heuristic_radii(centers):\n    \"\"\"Simple pairwise scaling fallback when LP is unavailable.\"\"\"\n    n = len(centers)\n    radii = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                               1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if radii[i] + radii[j] > d:\n            scale = d / (radii[i] + radii[j])\n            radii[i] *= scale\n            radii[j] *= scale\n    return radii\n\n\ndef construct_packing():\n    \"\"\"\n    Build a 26\u2011circle arrangement and compute radii that maximise the total sum.\n    Returns (centers, radii, sum_of_radii).\n    \"\"\"\n    n = 26\n    # start from a deterministic grid \u2013 good baseline for diversity\n    centers = _grid_positions(n)\n\n    # optimise radii\n    radii = _lp_max_radii(centers) if _HAS_LP else _heuristic_radii(centers)\n\n    return centers, radii, np.sum(radii)\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional visualisation using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Circle packing (sum\u202f=\u202f{radii.sum():.4f})')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.1667), Performs well on target_ratio (0.8223), Performs well on combined_score (0.8223), Performs well on eval_time (0.2368)\n\n### Program 2 (Score: 0.7874)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved constructor\u2011based circle packing for n=26 circles\"\"\"\n\nimport numpy as np\nimport math\n\n\ndef construct_packing():\n    \"\"\"\n    Construct 26 circle centres in a unit square using a simple\n    triangular lattice.  Radii are then set to the largest\n    possible values that keep every circle inside the square\n    and non\u2011overlapping.\n    Returns:\n        centres (np.ndarray shape (26,2)),\n        radii   (np.ndarray shape (26,)),\n        sum_radii (float)\n    \"\"\"\n    # ---- generate 26 points on a triangular lattice -----------------\n    spacing = 0.18                     # distance between adjacent points\n    dy = spacing * math.sqrt(3) / 2    # vertical step for the lattice\n    pts = []\n    y = spacing / 2\n    while y < 0.99 and len(pts) < 26:\n        # even rows have one extra point (no horizontal offset)\n        offset = 0 if (len(pts) // 10) % 2 == 0 else spacing / 2\n        x = spacing / 2 + offset\n        while x < 0.99 and len(pts) < 26:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n    centres = np.clip(np.array(pts[:26]), 0.01, 0.99)\n\n    # ---- compute maximal radii --------------------------------------\n    radii = _max_radii(centres)\n\n    return centres, radii, float(radii.sum())\n\n\ndef _max_radii(centres: np.ndarray) -> np.ndarray:\n    \"\"\"\n    For each centre compute the largest radius that fits inside the\n    unit square and does not intersect any other circle.\n    \"\"\"\n    n = centres.shape[0]\n    # distance to the four borders\n    border = np.minimum.reduce(\n        [centres[:, 0], centres[:, 1], 1 - centres[:, 0], 1 - centres[:, 1]]\n    )\n    # start with border distances\n    rad = border.copy()\n\n    # limit by neighbours: radius \u2264 half the centre\u2011to\u2011centre distance\n    for i in range(n):\n        dists = np.linalg.norm(centres[i] - centres[i + 1 :], axis=1)\n        if dists.size:\n            rad[i] = min(rad[i], dists.min() / 2)\n            # also enforce the neighbour's limit\n            rad[i + 1 :] = np.minimum(rad[i + 1 :], dists / 2)\n    return rad\n\n\n# EVOLVE-BLOCK-END\n\n\n# ----- fixed helper code (unchanged) ---------------------------------\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Display the packing using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (n={len(centres)}, sum={radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centres, radii, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # Uncomment to see the picture:\n    # visualize(centres, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.0747), Performs well on target_ratio (0.7874), Performs well on combined_score (0.7874), Performs well on eval_time (0.0600)\n\n### Program 3 (Score: 0.3642)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (0.9598), Performs well on target_ratio (0.3642), Performs well on combined_score (0.3642)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.8223, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved circle packing for n=26 using LP radii optimisation and a grid layout.\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\ntry:\n    # SciPy provides a reliable linear\u2011programming solver.\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:               # pragma: no cover\n    _HAS_LP = False\n\n\ndef _grid_positions(n):\n    \"\"\"Create a simple (\u2248\u221an)\u00d7(\u2248\u221an) grid plus a centre point.\"\"\"\n    m = int(np.ceil(np.sqrt(n)))          # grid dimension\n    xs = (np.arange(m) + 0.5) / m\n    ys = (np.arange(m) + 0.5) / m\n    pts = np.array(np.meshgrid(xs, ys)).T.reshape(-1, 2)\n    if pts.shape[0] > n:                  # trim excess\n        pts = pts[:n]\n    elif pts.shape[0] < n:                # add centre if needed\n        extra = n - pts.shape[0]\n        centre = np.full((extra, 2), 0.5)\n        pts = np.vstack([pts, centre])\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _lp_max_radii(centers):\n    \"\"\"Linear\u2011programming solution: max \u03a3r_i  s.t.  r_i\u2264border, r_i+r_j\u2264dist_ij.\"\"\"\n    n = len(centers)\n    # border limits\n    borders = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                                 1 - centers[:, 0], 1 - centers[:, 1]])\n\n    # inequality matrix for pairwise constraints\n    rows = []\n    rhs = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A_ub = np.array(rows) if rows else None\n    b_ub = np.array(rhs) if rhs else None\n\n    # linprog minimises; we maximise \u03a3r_i \u2192 minimise -\u03a3r_i\n    c = -np.ones(n)\n    bounds = [(0, b) for b in borders]\n\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds,\n                  method='highs', options={'presolve': True})\n    if res.success:\n        return res.x\n    # fallback: use the border limits (still valid)\n    return borders\n\n\ndef _heuristic_radii(centers):\n    \"\"\"Simple pairwise scaling fallback when LP is unavailable.\"\"\"\n    n = len(centers)\n    radii = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                               1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if radii[i] + radii[j] > d:\n            scale = d / (radii[i] + radii[j])\n            radii[i] *= scale\n            radii[j] *= scale\n    return radii\n\n\ndef construct_packing():\n    \"\"\"\n    Build a 26\u2011circle arrangement and compute radii that maximise the total sum.\n    Returns (centers, radii, sum_of_radii).\n    \"\"\"\n    n = 26\n    # start from a deterministic grid \u2013 good baseline for diversity\n    centers = _grid_positions(n)\n\n    # optimise radii\n    radii = _lp_max_radii(centers) if _HAS_LP else _heuristic_radii(centers)\n\n    return centers, radii, np.sum(radii)\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional visualisation using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Circle packing (sum\u202f=\u202f{radii.sum():.4f})')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.167)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"Simple deterministic circle packing for n=26.\n\nThe constructor builds a regular grid of points inside the unit square,\nthen scales the radii so that circles stay inside the square and do not\noverlap.  No external solvers are required \u2013 only NumPy.\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Helper functions (evolve\u2011block)\n# ----------------------------------------------------------------------\ndef _grid_positions(n: int) -> np.ndarray:\n    \"\"\"Return the first *n* points of an \u2248\u221an\u00d7\u221an grid, clipped to (0,1).\"\"\"\n    m = int(np.ceil(np.sqrt(n)))            # grid side length\n    xs = (np.arange(m) + 0.5) / m\n    ys = (np.arange(m) + 0.5) / m\n    pts = np.stack(np.meshgrid(xs, ys), -1).reshape(-1, 2)\n    pts = pts[:n]                            # keep only needed points\n    return np.clip(pts, 0.01, 0.99)           # stay away from the border\n\n\ndef _heuristic_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Scale radii so that every circle fits inside the square and does not overlap.\"\"\"\n    n = len(centers)\n    # start with the distance to the four borders\n    radii = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                               1 - centers[:, 0], 1 - centers[:, 1]])\n\n    # enforce pairwise non\u2011overlap by proportional scaling\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if radii[i] + radii[j] > d:\n            scale = d / (radii[i] + radii[j])\n            radii[i] *= scale\n            radii[j] *= scale\n    return radii\n\n\n# ----------------------------------------------------------------------\n# Public API (unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"\n    Build 26 circle centres and compute radii that maximise the total sum.\n    Returns (centres, radii, sum_of_radii).\n    \"\"\"\n    n = 26\n    centres = _grid_positions(n)\n    radii = _heuristic_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional visualisation using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (sum\u202f=\u202f{radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}