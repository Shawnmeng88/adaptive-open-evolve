{"id": "a4f46b11-0e1b-4146-a2b7-02654f7b3883", "code": "\"\"\"Improved deterministic 26\u2011circle packing.\n\nThe algorithm:\n  1. Generate a triangular (hex) lattice for several spacings.\n  2. For each layout run a tiny deterministic hill\u2011climb that moves\n     points by \u00b1\u03b4 while the total radius sum increases.\n  3. Radii are obtained by a simple pair\u2011wise scaling heuristic\n     (no external solvers required).\n  4. A few jittered restarts increase diversity; the best layout is kept.\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; clipped & centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation \u2013 deterministic pairwise scaling\n# ----------------------------------------------------------------------\ndef _heuristic_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Start from border limits then shrink pairwise until feasible.\"\"\"\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _heuristic_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _heuristic_radii(cand).sum()\n                if s > best_sum + 1e-12:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# deterministic jitter (fixed seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep a few spacings, keep the best layout\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _heuristic_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered restarts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _heuristic_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _heuristic_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray) -> None:\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout", "language": "python", "parent_id": "3a541d8f-494c-4e43-9830-70301c511371", "generation": 2, "timestamp": 1764885579.608418, "iteration_found": 197, "metrics": {"validity": 1.0, "sum_radii": 2.021872207970489, "target_ratio": 0.7673139309185917, "combined_score": 0.7673139309185917, "eval_time": 14.998362064361572}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 1.4063237338707741, "target_ratio": 0.5337091969149048, "combined_score": 0.5337091969149048, "eval_time": 0.05517983436584473}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.5337\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.9405 \u2192 0.5337. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4783, target_ratio: 0.9405, combined_score: 0.9405, eval_time: 58.7847\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4783, target_ratio: 0.9405, combined_score: 0.9405, eval_time: 48.2891\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4783, target_ratio: 0.9405, combined_score: 0.9405, eval_time: 45.5510\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9405)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; clipped & centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# deterministic jitter (fixed seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep a few spacings, keep the best layout\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered restarts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4783), Performs well on target_ratio (0.9405), Performs well on combined_score (0.9405), Performs well on eval_time (45.5510)\n\n### Program 2 (Score: 0.9405)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional LP backend\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; clipped and centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n\n# ----------------------------------------------------------------------\n# deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# jitter (deterministic seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep spacings, jittered starts, keep best\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered restarts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4783), Performs well on target_ratio (0.9405), Performs well on combined_score (0.9405), Performs well on eval_time (48.2891)\n\n### Program 3 (Score: 0.9405)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\nThe algorithm follows the best\u2011performing variants:\n  1. Sweep a few hex\u2011lattice spacings.\n  2. For each spacing launch a few jittered starts and a tiny deterministic\n     hill\u2011climb that keeps any move raising the total radius.\n  3. Radii are maximised by a linear programme when SciPy is present,\n     otherwise by a deterministic pair\u2011wise scaling heuristic.\n  4. The layout with the largest \u03a3\u202fr is returned.\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; clipped and centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# deterministic jitter (fixed seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep spacings, jittered starts, keep best\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered starts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4783), Performs well on target_ratio (0.9405), Performs well on combined_score (0.9405), Performs well on eval_time (58.7847)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9405)\n```python\n\"\"\"26\u2011circle packing \u2013 compact multi\u2011start hill\u2011climb.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----- optional exact optimiser (SciPy) ---------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----- geometry helpers -------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*), clipped and centre\u2011padded.\"\"\"\n    dy, pts, y, row = s * np.sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----- radius optimisation ---------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n, b = len(c), _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n); row[i] = row[j] = 1.0\n        rows.append(row); rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c)\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j]); r[i] *= f; r[j] *= f\n    return r\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n# ----- deterministic hill\u2011climb ----------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta,0),(-delta,0),(0,delta),(0,-delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved: break\n    return best\n\n# ----- jittered multi\u2011start --------------------------------------------\n_rng = np.random.default_rng(12345)          # deterministic seed\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n# ----- layout search ---------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweep a few spacings\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum: best, best_sum = cand, total\n\n        # a few jittered starts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum: best, best_sum = cand, total\n    return best\n\n# ----- public constructor -----------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n# ----- helper / entry\u2011point ---------------------------------------------\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9405)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Compact 26\u2011circle packing with a tiny multi\u2011start local search.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----- optional exact optimiser (SciPy) ---------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----- geometry helpers -------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) clipped to the unit square.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----- radius optimisation ---------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n# ----- tiny deterministic hill\u2011climb ------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n# ----- deterministic jitter (fixed seed) -------------------------------\n_rng = np.random.default_rng(12345)\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n# ----- layout search ----------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweep promising spacings\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered starts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n# ----- public constructor ------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n# ----- helper / entry\u2011point --------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\ndef visualize(centers: np.ndarray, radii: np.ndarray):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.7404, Type: Alternative)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) clipped to the unit square.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# Radius optimisation (deterministic pairwise scaling)\n# ----------------------------------------------------------------------\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Start with border limits then shrink pairwise until feasible.\"\"\"\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n# ----------------------------------------------------------------------\n# Tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 6, delta: float = 0.012) -> np.ndarray:\n    \"\"\"Move each centre \u00b1\u03b4 while total radius grows.\"\"\"\n    best = c.copy()\n    best_sum = _opt_radii(best).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# Layout search \u2013 sweep a few spacings, keep the best after hill\u2011climb\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Return the centre layout with the largest \u03a3r found by a cheap search.\"\"\"\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # coarse sweep around the sweet spot\n        pts = _hex_grid(n, s)\n        pts = _hill_climb(pts)\n        total = _opt_radii(pts).sum()\n        if total > best_sum:\n            best, best_sum = pts, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# Public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# Helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (1.951)\n\n### Inspiration 2 (Score: 0.9405, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; clipped & centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r under border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border_limits(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    \"\"\"Deterministic pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\ndef _opt_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Pick the best available optimiser.\"\"\"\n    return _lp_opt(c) if _HAS_LP else _heur_opt(c)\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _opt_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _opt_radii(cand).sum()\n                if s > best_sum + 1e-9:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# deterministic jitter (fixed seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep a few spacings, keep the best layout\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _opt_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered restarts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _opt_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# helper / entry\u2011point (unchanged API)\n# ----------------------------------------------------------------------\ndef run_packing():\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.478)\n\n### Inspiration 3 (Score: 0.5337, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Compact circle\u2011packing for n=26 using a deterministic grid and\npairwise\u2011scaling radii optimisation (no external solvers).\"\"\"\nimport numpy as np\nfrom itertools import combinations\n\ndef _grid_positions(n: int) -> np.ndarray:\n    \"\"\"Create \u2248\u221an\u00d7\u221an grid, pad with centre if needed.\"\"\"\n    m = int(np.ceil(np.sqrt(n)))\n    xs = (np.arange(m) + 0.5) / m\n    ys = (np.arange(m) + 0.5) / m\n    pts = np.stack(np.meshgrid(xs, ys), -1).reshape(-1, 2)\n    if pts.shape[0] < n:                     # add centre points\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return np.clip(pts[:n], 0.01, 0.99)\n\ndef _max_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Start with border limits then shrink pairwise until feasible.\"\"\"\n    # border distances\n    rad = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                             1 - centers[:, 0], 1 - centers[:, 1]]).copy()\n    # iterative pairwise scaling\n    for i, j in combinations(range(len(centers)), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        s = rad[i] + rad[j]\n        if s > d:\n            scale = d / s\n            rad[i] *= scale\n            rad[j] *= scale\n    return rad\n\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    n = 26\n    centers = _grid_positions(n)\n    radii = _max_radii(centers)\n    return centers, radii, float(radii.sum())\n# EVOLVE-BLOCK-END\n\ndef run_packing():\n    \"\"\"Convenient wrapper used by the harness.\"\"\"\n    return construct_packing()\n\ndef visualize(centers, radii):\n    \"\"\"Optional Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (1.406)\n\n# Current Program\n```python\n\"\"\"Simple deterministic circle packing for n=26.\n\nThe constructor builds a regular grid of points inside the unit square,\nthen scales the radii so that circles stay inside the square and do not\noverlap.  No external solvers are required \u2013 only NumPy.\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# Helper functions (evolve\u2011block)\n# ----------------------------------------------------------------------\ndef _grid_positions(n: int) -> np.ndarray:\n    \"\"\"Return the first *n* points of an \u2248\u221an\u00d7\u221an grid, clipped to (0,1).\"\"\"\n    m = int(np.ceil(np.sqrt(n)))            # grid side length\n    xs = (np.arange(m) + 0.5) / m\n    ys = (np.arange(m) + 0.5) / m\n    pts = np.stack(np.meshgrid(xs, ys), -1).reshape(-1, 2)\n    pts = pts[:n]                            # keep only needed points\n    return np.clip(pts, 0.01, 0.99)           # stay away from the border\n\n\ndef _heuristic_radii(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Scale radii so that every circle fits inside the square and does not overlap.\"\"\"\n    n = len(centers)\n    # start with the distance to the four borders\n    radii = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                               1 - centers[:, 0], 1 - centers[:, 1]])\n\n    # enforce pairwise non\u2011overlap by proportional scaling\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if radii[i] + radii[j] > d:\n            scale = d / (radii[i] + radii[j])\n            radii[i] *= scale\n            radii[j] *= scale\n    return radii\n\n\n# ----------------------------------------------------------------------\n# Public API (unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"\n    Build 26 circle centres and compute radii that maximise the total sum.\n    Returns (centres, radii, sum_of_radii).\n    \"\"\"\n    n = 26\n    centres = _grid_positions(n)\n    radii = _heuristic_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Optional visualisation using matplotlib.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Circle packing (sum\u202f=\u202f{radii.sum():.4f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"Improved deterministic 26\u2011circle packing.\n\nThe algorithm:\n  1. Generate a triangular (hex) lattice for several spacings.\n  2. For each layout run a tiny deterministic hill\u2011climb that moves\n     points by \u00b1\u03b4 while the total radius sum increases.\n  3. Radii are obtained by a simple pair\u2011wise scaling heuristic\n     (no external solvers required).\n  4. A few jittered restarts increase diversity; the best layout is kept.\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float) -> np.ndarray:\n    \"\"\"Triangular lattice with spacing *s*; clipped & centre\u2011padded.\"\"\"\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\ndef _border_limits(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation \u2013 deterministic pairwise scaling\n# ----------------------------------------------------------------------\ndef _heuristic_radii(c: np.ndarray) -> np.ndarray:\n    \"\"\"Start from border limits then shrink pairwise until feasible.\"\"\"\n    r = _border_limits(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            f = d / (r[i] + r[j])\n            r[i] *= f\n            r[j] *= f\n    return r\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb on centre positions\n# ----------------------------------------------------------------------\ndef _hill_climb(c: np.ndarray, steps: int = 8, delta: float = 0.012) -> np.ndarray:\n    best, best_sum = c.copy(), _heuristic_radii(c).sum()\n    for _ in range(steps):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                s = _heuristic_radii(cand).sum()\n                if s > best_sum + 1e-12:\n                    best, best_sum, improved = cand, s, True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# deterministic jitter (fixed seed) for multi\u2011start\n# ----------------------------------------------------------------------\n_rng = np.random.default_rng(12345)\n\n\ndef _jitter(c: np.ndarray, scale: float = 0.025) -> np.ndarray:\n    noise = (2 * _rng.random(c.shape) - 1) * scale\n    return np.clip(c + noise, 0.01, 0.99)\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 sweep a few spacings, keep the best layout\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_sum = None, -1.0\n    for s in np.linspace(0.14, 0.22, 9):          # sweet\u2011spot sweep\n        base = _hex_grid(n, s)\n\n        # plain grid\n        cand = _hill_climb(base)\n        total = _heuristic_radii(cand).sum()\n        if total > best_sum:\n            best, best_sum = cand, total\n\n        # a few jittered restarts\n        for _ in range(3):\n            cand = _hill_climb(_jitter(base))\n            total = _heuristic_radii(cand).sum()\n            if total > best_sum:\n                best, best_sum = cand, total\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor (API unchanged)\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    centres = _best_layout(26)\n    radii = _heuristic_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Convenient wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centers: np.ndarray, radii: np.ndarray) -> None:\n    \"\"\"Optional Matplotlib visualisation (not required for scoring).\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n    # visualize(cs, rs)   # uncomment to see the layout\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}