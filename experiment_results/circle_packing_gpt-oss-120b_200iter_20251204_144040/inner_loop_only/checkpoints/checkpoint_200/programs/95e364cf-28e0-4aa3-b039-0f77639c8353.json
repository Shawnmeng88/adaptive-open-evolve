{"id": "95e364cf-28e0-4aa3-b039-0f77639c8353", "code": "\"\"\"Optimised 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                           # linear\u2011programming if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:             # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\",\n                  options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing refinement (three\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:   # occasional uphill\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic polish after annealing\n# ----------------------------------------------------------------------\ndef _local_refine(layout: np.ndarray,\n                  delta: float = 0.006,\n                  passes: int = 2) -> np.ndarray:\n    best = layout.copy()\n    best_val = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                val = _opt_radii(cand).sum()\n                if val > best_val + 1e-12:\n                    best, best_val = cand, val\n                    improved = True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # denser sweep than previous versions\n    spacings = np.linspace(0.125, 0.245, 23)          # 23 spacings\n    rotations = np.linspace(0.0, math.pi / 4, 15)    # 15 rotations\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # three annealing passes (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, iters=1500, step=0.036, decay=0.998, seed=41)\n    best = _anneal(best, iters=2000, step=0.018, decay=0.9995, seed=99)\n    best = _anneal(best, iters=1200, step=0.009, decay=0.9999, seed=123)\n\n    # final deterministic tweak\n    best = _local_refine(best, delta=0.006, passes=2)\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")", "language": "python", "parent_id": "187bc932-e4f8-4c2c-a508-07cb34fc4b28", "generation": 7, "timestamp": 1764885107.012058, "iteration_found": 173, "metrics": {"validity": 1.0, "sum_radii": 2.524504674488625, "target_ratio": 0.9580662901285104, "combined_score": 0.9580662901285104, "eval_time": 9.161906003952026}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.511417403102053, "target_ratio": 0.9530995837199442, "combined_score": 0.9530995837199442, "eval_time": 6.557754993438721}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.9531\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.9531\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5114, target_ratio: 0.9531, combined_score: 0.9531, eval_time: 6.5127\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5151, target_ratio: 0.9545, combined_score: 0.9545, eval_time: 5.7984\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5245, target_ratio: 0.9581, combined_score: 0.9581, eval_time: 9.2661\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9581)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 tighter search + three\u2011stage polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                       # fast LP if SciPy is available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:         # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(best).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps diversity\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb \u2013 final polish\n# ----------------------------------------------------------------------\ndef _local_refine(layout: np.ndarray,\n                  delta: float = 0.008,\n                  passes: int = 3) -> np.ndarray:\n    \"\"\"Move each centre by \u00b1\u03b4 while it improves the radius sum.\"\"\"\n    best = layout.copy()\n    best_val = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                val = _opt_radii(cand).sum()\n                if val > best_val + 1e-12:\n                    best, best_val = cand, val\n                    improved = True\n        if not improved:\n            break\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # very fine sweep (more points than previous versions)\n    spacings = np.linspace(0.125, 0.245, 23)       # 23 spacings\n    rotations = np.linspace(0.0, math.pi / 4, 15) # 15 rotations\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, iters=1500, step=0.036, decay=0.998, seed=41)\n    best = _anneal(best, iters=2000, step=0.018, decay=0.9995, seed=99)\n    best = _anneal(best, iters=1200, step=0.009, decay=0.9999, seed=123)\n\n    # final deterministic tweak\n    best = _local_refine(best, delta=0.006, passes=2)\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5245), Performs well on target_ratio (0.9581), Performs well on combined_score (0.9581), Performs well on eval_time (9.2661)\n\n### Program 2 (Score: 0.9545)\n```python\n\"\"\"Compact 26\u2011circle packing with a two\u2011stage stochastic polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nimport numpy as np\n\n# --------------------------------------------------------------\n# Optional exact optimiser (SciPy)\n# --------------------------------------------------------------\ntry:                         # linear\u2011programming if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:           # pragma: no cover\n    _USE_LP = False\n\n# --------------------------------------------------------------\n# Geometry helpers\n# --------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) optionally rotated by *rot* rad.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# --------------------------------------------------------------\n# Radius optimisation\n# --------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _USE_LP else _heur_opt\n\n# --------------------------------------------------------------\n# Two\u2011stage stochastic polish (simulated annealing)\n# --------------------------------------------------------------\ndef _anneal(start: np.ndarray, iters: int, step: float,\n            decay: float, seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    cur = best = start.copy()\n    cur_val = best_val = _opt(cur).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n        val = _opt(cand).sum()\n        # accept if better; occasional uphill move keeps diversity\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n# --------------------------------------------------------------\n# Layout search \u2013 dense sweep + two\u2011stage polishing\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    best, best_val = None, -1.0\n    # dense sweep of spacings & rotations\n    for s in np.linspace(0.13, 0.245, 19):          # finer spacing grid\n        for r in np.linspace(0.0, math.pi / 4, 13):  # up to 45\u00b0\n            pts = _grid(n, s, r)\n            val = _opt(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n    # two\u2011stage polish: coarse then fine\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n    return best\n\n# --------------------------------------------------------------\n# Public constructor\n# --------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5151), Performs well on target_ratio (0.9545), Performs well on combined_score (0.9545), Performs well on eval_time (5.7984)\n\n### Program 3 (Score: 0.9531)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search & two\u2011stage annealing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\n\n    The lattice is clipped to the unit square and padded with centre points\n    if fewer than *n* points are generated.\n    \"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    # keep a safe margin from the walls\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, otherwise deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows: list[np.ndarray] = []\n    rhs: list[float] = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            scale = d / (r[i] + r[j])\n            r[i] *= scale\n            r[j] *= scale\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\n\n    *iters* \u2013 number of proposals,\n    *step* \u2013 max displacement per coordinate,\n    *decay* \u2013 geometric decay of *step* after each iteration.\n    \"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better, otherwise allow a tiny uphill move\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search a large space of grids and polish the best candidate.\"\"\"\n    # --- dense sweep ----------------------------------------------------\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0 in 13 steps\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # --- two\u2011stage annealing -------------------------------------------\n    # coarse polishing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    # fine polishing\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# simple demo when executed directly\n# ----------------------------------------------------------------------\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5114), Performs well on target_ratio (0.9531), Performs well on combined_score (0.9531), Performs well on eval_time (6.5127)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9531)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search & two\u2011stage annealing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if SciPy is available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\n\n    The lattice is clipped to the unit square and padded with centre points\n    if fewer than *n* points are generated.\n    \"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    # keep a safe margin from the walls\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, otherwise deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows: list[np.ndarray] = []\n    rhs: list[float] = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            scale = d / (r[i] + r[j])\n            r[i] *= scale\n            r[j] *= scale\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\n\n    *iters* \u2013 number of proposals,\n    *step* \u2013 max displacement per coordinate,\n    *decay* \u2013 geometric decay of *step* after each iteration.\n    \"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps exploration alive\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search a large space of grids and polish the best candidate.\"\"\"\n    # --- dense sweep ----------------------------------------------------\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0 in 13 steps\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # --- two\u2011stage annealing -------------------------------------------\n    # coarse polishing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    # fine polishing\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# simple demo when executed directly\n# ----------------------------------------------------------------------\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9531)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search + two\u2011stage anneal.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                 # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                   # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps exploration alive\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search many grids then polish the best candidate.\"\"\"\n    # dense sweep\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # two\u2011stage annealing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9392, Type: High-Performer)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 denser sweep + two\u2011stage anneal.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nimport numpy as np\nfrom itertools import combinations\n\n# ----- optional exact optimiser ------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:          # pragma: no cover\n    _USE_LP = False\n\n# ----- geometry helpers -------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                       # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----- radius optimisation ----------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n); row[i] = row[j] = 1.0\n        rows.append(row); rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s; r[j] *= s\n    return r\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----- simulated\u2011annealing refinement ----------------------------------------\ndef _anneal(start: np.ndarray, iters: int, step: float,\n            decay: float, seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    cur = best = start.copy()\n    cur_val = best_val = _opt_radii(cur).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], .01, .99)\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:   # tiny uphill chance\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n# ----- layout search ---------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Dense sweep of spacings/rotations + two\u2011stage anneal.\"\"\"\n    spacings = np.linspace(.12, .26, 23)           # finer spacing grid\n    rotations = np.linspace(0, math.pi / 3, 13)   # up to 60\u00b0\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n    # two\u2011stage polishing: coarse then fine\n    best = _anneal(best, iters=1800, step=0.04, decay=0.998, seed=7)\n    best = _anneal(best, iters=2500, step=0.018, decay=0.9995, seed=11)\n    return best\n\n# ----- public constructor -----------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.475)\n\n### Inspiration 2 (Score: 0.9013, Type: High-Performer)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math, random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                      # centre\u2011pad if short\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, otherwise deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    \"\"\"Simple anneal: accept better solutions, otherwise with exp\u2011probability.\"\"\"\n    rng = random.Random(seed)\n    cur = best = start.copy()\n    cur_val = best_val = _opt_radii(cur).sum()\n    T = step                     # temperature tied to step size\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < math.exp((val - cur_val) / max(T, 1e-12)):\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n        T *= decay\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # dense sweep of spacings & rotations\n    spacings = np.linspace(0.13, 0.245, 15)          # finer spacing grid\n    rots = np.linspace(0.0, math.pi / 4, 9)        # up to 45\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # two\u2011stage annealing: coarse then fine\n    best = _anneal(best, iters=1200, step=0.04, decay=0.998, seed=42)\n    best = _anneal(best, iters=1800, step=0.015, decay=0.9995, seed=99)\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.375)\n\n### Inspiration 3 (Score: 0.9521, Type: High-Performer)\n```python\n\"\"\"Compact 26\u2011circle packing \u2013 rewritten for higher fitness.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nimport numpy as np\nfrom itertools import combinations\n\n# ---------- optional exact optimiser (SciPy) ----------\ntry:                                 # fast linear programming if available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                   # pragma: no cover\n    _USE_LP = False\n\n# ---------- geometry helpers ----------\ndef _hex_grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* (rad).\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (four walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ---------- radius optimisation ----------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ---------- stochastic refinement (two\u2011stage) ----------\ndef _refine(start: np.ndarray,\n            iters: int = 1200,\n            step: float = 0.03,\n            decay: float = 0.998,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], .01, .99)\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:          # occasional uphill move\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n# ---------- layout search ----------\ndef _best_layout(n: int) -> np.ndarray:\n    # finer sweep than the original version\n    spacings = np.linspace(0.135, 0.235, 13)   # 13 spacings\n    rots = np.linspace(0, math.pi / 4, 9)     # up to 45\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _hex_grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # two\u2011stage polishing: coarse then fine annealing\n    best = _refine(best, iters=1200, step=0.03, decay=0.998, seed=1)\n    best = _refine(best, iters=1800, step=0.015, decay=0.9995, seed=2)\n    return best\n\n# ---------- public constructor ----------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.509)\n\n# Current Program\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search & two\u2011stage annealing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if SciPy is available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\n\n    The lattice is clipped to the unit square and padded with centre points\n    if fewer than *n* points are generated.\n    \"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    # keep a safe margin from the walls\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, otherwise deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows: list[np.ndarray] = []\n    rhs: list[float] = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            scale = d / (r[i] + r[j])\n            r[i] *= scale\n            r[j] *= scale\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\n\n    *iters* \u2013 number of proposals,\n    *step* \u2013 max displacement per coordinate,\n    *decay* \u2013 geometric decay of *step* after each iteration.\n    \"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps exploration alive\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search a large space of grids and polish the best candidate.\"\"\"\n    # --- dense sweep ----------------------------------------------------\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0 in 13 steps\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # --- two\u2011stage annealing -------------------------------------------\n    # coarse polishing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    # fine polishing\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# simple demo when executed directly\n# ----------------------------------------------------------------------\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"Optimised 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                           # linear\u2011programming if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:             # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\",\n                  options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing refinement (three\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:   # occasional uphill\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic polish after annealing\n# ----------------------------------------------------------------------\ndef _local_refine(layout: np.ndarray,\n                  delta: float = 0.006,\n                  passes: int = 2) -> np.ndarray:\n    best = layout.copy()\n    best_val = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                val = _opt_radii(cand).sum()\n                if val > best_val + 1e-12:\n                    best, best_val = cand, val\n                    improved = True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # denser sweep than previous versions\n    spacings = np.linspace(0.125, 0.245, 23)          # 23 spacings\n    rotations = np.linspace(0.0, math.pi / 4, 15)    # 15 rotations\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # three annealing passes (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, iters=1500, step=0.036, decay=0.998, seed=41)\n    best = _anneal(best, iters=2000, step=0.018, decay=0.9995, seed=99)\n    best = _anneal(best, iters=1200, step=0.009, decay=0.9999, seed=123)\n\n    # final deterministic tweak\n    best = _local_refine(best, delta=0.006, passes=2)\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}