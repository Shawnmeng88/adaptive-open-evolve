{"id": "d2e3550d-92b5-4848-94f8-925eb7a8de45", "code": "# EVOLVE-BLOCK-START\n\"\"\"Optimised 26\u2011circle packing in a unit square via linear programming.\"\"\"\nimport numpy as np\n\n# ------------------------------------------------------------\n# 1\ufe0f\u20e3  Build a deterministic set of 26 centre positions\n# ------------------------------------------------------------\ndef make_centres():\n    \"\"\"5\u00d75 grid (0.1,\u2026,0.9) plus one extra point.\"\"\"\n    pts = [(i + 0.5) / 5 for i in range(5)]               # 0.1,0.3,\u2026,0.9\n    grid = np.array([[x, y] for x in pts for y in pts])   # 25 points\n    extra = np.array([[0.5, 0.25]])                       # 26th point\n    return np.vstack([grid, extra])\n\n\n# ------------------------------------------------------------\n# 2\ufe0f\u20e3  Compute the *maximum* radii for a fixed set of centres.\n#     This is a linear programme:\n#       maximise   \u03a3 r_i\n#       subject to r_i \u2264 distance to each square side\n#                  r_i + r_j \u2264 distance(centre_i, centre_j)\n# ------------------------------------------------------------\ndef optimal_radii(centres):\n    try:\n        import pulp\n    except Exception:                     # pulp not available \u2192 fall back\n        return _greedy_radii(centres)\n\n    n = len(centres)\n    prob = pulp.LpProblem(\"max_sum_radii\", pulp.LpMaximize)\n\n    # decision variables\n    r = [pulp.LpVariable(f\"r{i}\", lowBound=0) for i in range(n)]\n\n    # maximise the sum\n    prob += pulp.lpSum(r)\n\n    # border constraints\n    for i, (x, y) in enumerate(centres):\n        prob += r[i] <= x\n        prob += r[i] <= y\n        prob += r[i] <= 1 - x\n        prob += r[i] <= 1 - y\n\n    # pairwise non\u2011overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centres[i] - centres[j])\n            prob += r[i] + r[j] <= d\n\n    prob.solve(pulp.PULP_CBC_CMD(msg=False))\n    return np.array([v.varValue for v in r], dtype=float)\n\n\n# ------------------------------------------------------------\n# 3\ufe0f\u20e3  Simple greedy fallback (used only if pulp is missing)\n# ------------------------------------------------------------\ndef _greedy_radii(centres):\n    n = len(centres)\n    rad = np.full(n, np.inf)\n    # border limits first\n    for i, (x, y) in enumerate(centres):\n        rad[i] = min(x, y, 1 - x, 1 - y)\n\n    # shrink radii greedily by nearest neighbour\n    for _ in range(3):                                     # a few passes\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centres[i] - centres[j])\n                if rad[i] + rad[j] > d:\n                    s = d / (rad[i] + rad[j])\n                    rad[i] *= s\n                    rad[j] *= s\n    return rad\n\n\n# ------------------------------------------------------------\n# 4\ufe0f\u20e3  Public entry point \u2013 unchanged API\n# ------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle layout.\"\"\"\n    centres = make_centres()\n    radii = optimal_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\n# -----------------------------------------------------------------\n# Fixed helper / visualisation \u2013 untouched by the evolution engine\n# -----------------------------------------------------------------\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Quick Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"26\u2011circle packing \u2013 sum\u202fr = {radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Sum of radii: {s:.6f}\")\n    # visualise(c, r)          # uncomment to see the layout", "language": "python", "parent_id": "4ff192f1-c4c8-4399-81e6-b3cc0c6db8d1", "generation": 1, "timestamp": 1764880964.490324, "iteration_found": 5, "metrics": {"validity": 1.0, "sum_radii": 1.8373581089021616, "target_ratio": 0.6972896048964561, "combined_score": 0.6972896048964561, "eval_time": 0.09652996063232422}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 0.9597642169962064, "target_ratio": 0.36423689449571406, "combined_score": 0.36423689449571406}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.3642\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness unchanged at 0.3642\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: validity: 1.0000, sum_radii: 0.9598, target_ratio: 0.3642, combined_score: 0.3642\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.3642)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (0.9598), Performs well on target_ratio (0.3642), Performs well on combined_score (0.3642)\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimised 26\u2011circle packing in a unit square via linear programming.\"\"\"\nimport numpy as np\n\n# ------------------------------------------------------------\n# 1\ufe0f\u20e3  Build a deterministic set of 26 centre positions\n# ------------------------------------------------------------\ndef make_centres():\n    \"\"\"5\u00d75 grid (0.1,\u2026,0.9) plus one extra point.\"\"\"\n    pts = [(i + 0.5) / 5 for i in range(5)]               # 0.1,0.3,\u2026,0.9\n    grid = np.array([[x, y] for x in pts for y in pts])   # 25 points\n    extra = np.array([[0.5, 0.25]])                       # 26th point\n    return np.vstack([grid, extra])\n\n\n# ------------------------------------------------------------\n# 2\ufe0f\u20e3  Compute the *maximum* radii for a fixed set of centres.\n#     This is a linear programme:\n#       maximise   \u03a3 r_i\n#       subject to r_i \u2264 distance to each square side\n#                  r_i + r_j \u2264 distance(centre_i, centre_j)\n# ------------------------------------------------------------\ndef optimal_radii(centres):\n    try:\n        import pulp\n    except Exception:                     # pulp not available \u2192 fall back\n        return _greedy_radii(centres)\n\n    n = len(centres)\n    prob = pulp.LpProblem(\"max_sum_radii\", pulp.LpMaximize)\n\n    # decision variables\n    r = [pulp.LpVariable(f\"r{i}\", lowBound=0) for i in range(n)]\n\n    # maximise the sum\n    prob += pulp.lpSum(r)\n\n    # border constraints\n    for i, (x, y) in enumerate(centres):\n        prob += r[i] <= x\n        prob += r[i] <= y\n        prob += r[i] <= 1 - x\n        prob += r[i] <= 1 - y\n\n    # pairwise non\u2011overlap constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centres[i] - centres[j])\n            prob += r[i] + r[j] <= d\n\n    prob.solve(pulp.PULP_CBC_CMD(msg=False))\n    return np.array([v.varValue for v in r], dtype=float)\n\n\n# ------------------------------------------------------------\n# 3\ufe0f\u20e3  Simple greedy fallback (used only if pulp is missing)\n# ------------------------------------------------------------\ndef _greedy_radii(centres):\n    n = len(centres)\n    rad = np.full(n, np.inf)\n    # border limits first\n    for i, (x, y) in enumerate(centres):\n        rad[i] = min(x, y, 1 - x, 1 - y)\n\n    # shrink radii greedily by nearest neighbour\n    for _ in range(3):                                     # a few passes\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centres[i] - centres[j])\n                if rad[i] + rad[j] > d:\n                    s = d / (rad[i] + rad[j])\n                    rad[i] *= s\n                    rad[j] *= s\n    return rad\n\n\n# ------------------------------------------------------------\n# 4\ufe0f\u20e3  Public entry point \u2013 unchanged API\n# ------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle layout.\"\"\"\n    centres = make_centres()\n    radii = optimal_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# EVOLVE-BLOCK-END\n\n\n# -----------------------------------------------------------------\n# Fixed helper / visualisation \u2013 untouched by the evolution engine\n# -----------------------------------------------------------------\ndef run_packing():\n    \"\"\"Run the circle\u2011packing constructor for n=26.\"\"\"\n    return construct_packing()\n\n\ndef visualize(centres, radii):\n    \"\"\"Quick Matplotlib visualisation.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.5))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"26\u2011circle packing \u2013 sum\u202fr = {radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Sum of radii: {s:.6f}\")\n    # visualise(c, r)          # uncomment to see the layout\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}