{"id": "5c82465d-4c2e-40a2-9dff-f1d0feb5723b", "code": "\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\nimport numpy as np\n\n# --------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# --------------------------------------------------------------\ntry:                         # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:           # pragma: no cover\n    _USE_LP = False\n\n# --------------------------------------------------------------\n# geometry helpers\n# --------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice of spacing *s* rotated by *rot* radians.\"\"\"\n    dy = s * sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius allowed by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# --------------------------------------------------------------\n# radius optimisation\n# --------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\",\n                  options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# --------------------------------------------------------------\n# simulated\u2011annealing refinement (two\u2011stage)\n# --------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    cur = best = start.copy()\n    cur_val = best_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:   # tiny uphill chance\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# --------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # dense sweep (more candidates than the original)\n    spacings = np.linspace(0.12, 0.26, 23)          # 23 spacings\n    rotations = np.linspace(0, pi / 3, 13)         # up to 60\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # two\u2011stage annealing: coarse then fine\n    best = _anneal(best, iters=1800, step=0.04, decay=0.998, seed=7)\n    best = _anneal(best, iters=2500, step=0.018, decay=0.9995, seed=11)\n    return best\n\n\n# --------------------------------------------------------------\n# public constructor\n# --------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")", "language": "python", "parent_id": "552df79a-1e99-46b0-8fd6-bf25196b419f", "generation": 5, "timestamp": 1764884862.421765, "iteration_found": 160, "metrics": {"validity": 1.0, "sum_radii": 2.4746810417112237, "target_ratio": 0.9391578905924949, "combined_score": 0.9391578905924949, "eval_time": 8.710308074951172}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.4969120208857447, "target_ratio": 0.9475946948332997, "combined_score": 0.9475946948332997, "eval_time": 1.4793429374694824}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.9476\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.9531 \u2192 0.9476. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5114, target_ratio: 0.9531, combined_score: 0.9531, eval_time: 6.0913\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5114, target_ratio: 0.9531, combined_score: 0.9531, eval_time: 6.5578\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5114, target_ratio: 0.9531, combined_score: 0.9531, eval_time: 6.5127\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9531)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search & two\u2011stage annealing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\n\n    The lattice is clipped to the unit square and padded with centre points\n    if fewer than *n* points are generated.\n    \"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    # keep a safe margin from the walls\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, otherwise deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows: list[np.ndarray] = []\n    rhs: list[float] = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            scale = d / (r[i] + r[j])\n            r[i] *= scale\n            r[j] *= scale\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\n\n    *iters* \u2013 number of proposals,\n    *step* \u2013 max displacement per coordinate,\n    *decay* \u2013 geometric decay of *step* after each iteration.\n    \"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better, otherwise allow a tiny uphill move\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search a large space of grids and polish the best candidate.\"\"\"\n    # --- dense sweep ----------------------------------------------------\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0 in 13 steps\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # --- two\u2011stage annealing -------------------------------------------\n    # coarse polishing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    # fine polishing\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# simple demo when executed directly\n# ----------------------------------------------------------------------\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5114), Performs well on target_ratio (0.9531), Performs well on combined_score (0.9531), Performs well on eval_time (6.5127)\n\n### Program 2 (Score: 0.9531)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search & two\u2011stage annealing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if SciPy is available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\n\n    The lattice is clipped to the unit square and padded with centre points\n    if fewer than *n* points are generated.\n    \"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y = s / 2\n    row = 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    # keep a safe margin from the walls\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, otherwise deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows: list[np.ndarray] = []\n    rhs: list[float] = []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            scale = d / (r[i] + r[j])\n            r[i] *= scale\n            r[j] *= scale\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\n\n    *iters* \u2013 number of proposals,\n    *step* \u2013 max displacement per coordinate,\n    *decay* \u2013 geometric decay of *step* after each iteration.\n    \"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps exploration alive\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search a large space of grids and polish the best candidate.\"\"\"\n    # --- dense sweep ----------------------------------------------------\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0 in 13 steps\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # --- two\u2011stage annealing -------------------------------------------\n    # coarse polishing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    # fine polishing\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# simple demo when executed directly\n# ----------------------------------------------------------------------\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5114), Performs well on target_ratio (0.9531), Performs well on combined_score (0.9531), Performs well on eval_time (6.5578)\n\n### Program 3 (Score: 0.9531)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 richer search + two\u2011stage anneal.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                 # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                   # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts: list[list[float]] = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        rot_m = np.array([[cs, -sn], [sn, cs]])\n        pts = (c @ rot_m) + 0.5\n\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing refinement (two\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(\n    start: np.ndarray,\n    iters: int,\n    step: float,\n    decay: float,\n    seed: int | None = None,\n) -> np.ndarray:\n    \"\"\"Return a layout with (hopefully) larger \u03a3r.\"\"\"\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps exploration alive\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n\n        step *= decay\n\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Search many grids then polish the best candidate.\"\"\"\n    # dense sweep\n    spacings = np.linspace(0.125, 0.245, 17)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 13)    # up to 45\u00b0\n    best, best_sum = None, -1.0\n\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # two\u2011stage annealing\n    best = _anneal(best, iters=1500, step=0.035, decay=0.998, seed=42)\n    best = _anneal(best, iters=2000, step=0.015, decay=0.9995, seed=99)\n\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5114), Performs well on target_ratio (0.9531), Performs well on combined_score (0.9531), Performs well on eval_time (6.0913)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9521)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math, numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _hex_grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n)\n        r[i] = r[j] = 1.0\n        rows.append(r)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ----------------------------------------------------------------------\n# stochastic refinement \u2013 simulated\u2011annealing style\n# ----------------------------------------------------------------------\ndef _refine(start: np.ndarray,\n            iters: int = 2500,\n            step: float = 0.04,\n            decay: float = 0.999,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = start.copy()\n    best_val = _opt_radii(best).sum()\n    cur = best.copy()\n    cur_val = best_val\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        dx = (rng.random() * 2 - 1) * step\n        dy = (rng.random() * 2 - 1) * step\n        cand[i] += (dx, dy)\n        cand[i] = np.clip(cand[i], .01, .99)\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:   # occasional uphill move\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + refinement\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(0.135, 0.235, 13)      # finer spacing grid\n    rots = np.linspace(0, math.pi / 4, 9)       # up to 45\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _hex_grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n    # two\u2011stage polishing: coarse then fine annealing\n    best = _refine(best, iters=1200, step=0.03, decay=0.998, seed=1)\n    best = _refine(best, iters=1800, step=0.015, decay=0.9995, seed=2)\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\n# ----------------------------------------------------------------------\n# entry\u2011point used by the evaluation harness\n# ----------------------------------------------------------------------\ndef run_packing():\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9529)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 more exhaustive search & deeper anneal.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math\nimport numpy as np\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\n# ------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ------------------------------------------------------------\ntry:                         # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:           # pragma: no cover\n    _USE_LP = False\n\n# ------------------------------------------------------------\n# geometry helpers\n# ------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy = s * sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ------------------------------------------------------------\n# radius optimisation\n# ------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ------------------------------------------------------------\n# simulated\u2011annealing refinement (two\u2011stage)\n# ------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    cur = best = start.copy()\n    cur_val = best_val = _opt_radii(cur).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:          # tiny uphill chance\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n# ------------------------------------------------------------\n# layout search \u2013 dense sweep + deeper anneal\n# ------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # finer, broader sweep\n    spacings = np.linspace(0.12, 0.26, 25)          # 25 spacings\n    rots = np.linspace(0, pi / 3, 13)             # up to 60\u00b0\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # two\u2011stage annealing \u2013 coarse then fine\n    best = _anneal(best, iters=2000, step=0.04, decay=0.998, seed=7)\n    best = _anneal(best, iters=3000, step=0.018, decay=0.9995, seed=11)\n    return best\n\n# ------------------------------------------------------------\n# public constructor\n# ------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9494, Type: High-Performer)\n```python\n\"\"\"Compact 26\u2011circle packing \u2013 concise version with rotation & stochastic polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math, numpy as np\nfrom itertools import combinations\n\n# ---- optional exact optimiser -------------------------------------------------\ntry:                     # SciPy gives a fast LP solver\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:       # pragma: no cover\n    _LP = False\n\n# ---- geometry ---------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy, pts, y, r = s * math.sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if r % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        r += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ---- radius optimisation ----------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c); b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n); r[i] = r[j] = 1.0\n        rows.append(r); rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s; r[j] *= s\n    return r\n\n_opt = _lp_opt if _LP else _heur_opt\n\n# ---- stochastic refinement --------------------------------------------------\ndef _refine(start: np.ndarray, it: int = 800, step: float = .025,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best, best_val = start.copy(), _opt(start).sum()\n    for _ in range(it):\n        i = rng.randrange(len(best))\n        cand = best.copy()\n        cand[i] += (rng.random()*2-1)*step, (rng.random()*2-1)*step\n        cand[i] = np.clip(cand[i], .01, .99)\n        val = _opt(cand).sum()\n        if val > best_val:\n            best, best_val = cand, val\n    return best\n\n# ---- layout search ---------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    \"\"\"Sweep spacings & a few rotations, keep the best, then polish.\"\"\"\n    spacings = np.linspace(.14, .22, 9)\n    rots = np.linspace(0, math.pi/6, 5)      # 0\u00b0 \u2026 30\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            v = _opt(pts).sum()\n            if v > best_sum:\n                best, best_sum = pts, v\n    return _refine(best, it=1200, step=.02)\n\n# ---- public API -------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.502)\n\n### Inspiration 2 (Score: 0.9520, Type: High-Performer)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math\nimport numpy as np\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                         # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:           # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice of spacing *s* rotated by *rot* (radians).\"\"\"\n    dy = s * sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius allowed by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int = 2000,\n            step: float = 0.04,\n            decay: float = 0.999,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(best).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        dx = (rng.random() * 2 - 1) * step\n        dy = (rng.random() * 2 - 1) * step\n        cand[i] += (dx, dy)\n        cand[i] = np.clip(cand[i], .01, .99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better or with a tiny uphill probability\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 coarse sweep + two\u2011stage annealing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # broader, finer sweep than the previous version\n    spacings = np.linspace(0.13, 0.24, 15)          # 15 spacings\n    rots = np.linspace(0, pi / 4, 9)               # up to 45\u00b0\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # two\u2011stage annealing: coarse then fine\n    best = _anneal(best, iters=1200, step=0.03, decay=0.998, seed=1)\n    best = _anneal(best, iters=1800, step=0.015, decay=0.9995, seed=2)\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.509)\n\n### Inspiration 3 (Score: 0.9481, Type: High-Performer)\n```python\n\"\"\"Compact 26\u2011circle packing \u2013 richer multi\u2011start search & probabilistic anneal.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math\nimport numpy as np\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\n# ---------- optional exact optimiser (SciPy) ----------\ntry:\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:  # pragma: no cover\n    _USE_LP = False\n\n# ---------- geometry helpers ----------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy = s * sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                      # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ---------- radius optimisation ----------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# ---------- probabilistic annealing ----------\ndef _anneal(start: np.ndarray,\n            iters: int = 2500,\n            step: float = 0.04,\n            temp0: float = 1e-3,\n            decay: float = 0.9995,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    cur = best = start.copy()\n    cur_val = best_val = _opt_radii(cur).sum()\n    T = temp0\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < math.exp((val - cur_val) / max(T, 1e-12)):\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n        T *= decay\n    return best\n\n\n# ---------- multi\u2011start layout search ----------\ndef _best_layout(n: int) -> np.ndarray:\n    # dense sweep of spacings & rotations\n    spacings = np.linspace(0.115, 0.255, 28)          # finer spacing grid\n    rots = np.linspace(0, pi / 2, 17)               # up to 90\u00b0\n    candidates = []\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            candidates.append((val, pts))\n    # keep a few elite seeds\n    candidates.sort(key=lambda x: x[0], reverse=True)\n    elite = [c for _, c in candidates[:5]]\n\n    # anneal each elite and keep the best result\n    best, best_val = None, -1.0\n    for idx, seed in enumerate(elite):\n        refined = _anneal(seed,\n                         iters=3000,\n                         step=0.035,\n                         temp0=1e-3,\n                         decay=0.9993,\n                         seed=idx * 13 + 7)\n        val = _opt_radii(refined).sum()\n        if val > best_val:\n            best, best_val = refined, val\n    return best\n\n\n# ---------- public constructor ----------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.498)\n\n# Current Program\n```python\n\"\"\"Compact 26\u2011circle packing with a tiny stochastic polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, numpy as np\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\n# --------------------------------------------------------------\n# Optional LP backend (SciPy)\n# --------------------------------------------------------------\ntry:                         # exact optimiser if available\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:           # pragma: no cover\n    _LP = False\n\n# --------------------------------------------------------------\n# Geometry helpers\n# --------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) optionally rotated by *rot* rad.\"\"\"\n    dy, pts, y, r = s * sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if r % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y]); x += s\n        y += dy; r += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# --------------------------------------------------------------\n# Radius optimisation\n# --------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c); b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        r = np.zeros(n); r[i] = r[j] = 1.0\n        rows.append(r); rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j]); r[i] *= s; r[j] *= s\n    return r\n\n_opt = _lp_opt if _LP else _heur_opt\n\n# --------------------------------------------------------------\n# Stochastic refinement (very cheap)\n# --------------------------------------------------------------\ndef _refine(start: np.ndarray, it: int = 800, step: float = .025,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best, bestv = start.copy(), _opt(start).sum()\n    for _ in range(it):\n        i = rng.randrange(len(best))\n        cand = best.copy()\n        cand[i] += (rng.random()*2-1)*step, (rng.random()*2-1)*step\n        cand[i] = np.clip(cand[i], .01, .99)\n        v = _opt(cand).sum()\n        if v > bestv:\n            best, bestv = cand, v\n    return best\n\n# --------------------------------------------------------------\n# Layout search \u2013 spacing + a few rotations + polish\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(.14, .22, 9)\n    rots = np.linspace(0, pi/6, 4)          # 0\u00b0 \u2026 30\u00b0\n    best, bestv = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            v = _opt(pts).sum()\n            if v > bestv:\n                best, bestv = pts, v\n    return _refine(best, it=600, step=.02)\n\n# --------------------------------------------------------------\n# Public constructor\n# --------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    cs, rs, tot = run_packing()\n    print(f\"Sum of radii: {tot:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\nimport numpy as np\n\n# --------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# --------------------------------------------------------------\ntry:                         # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:           # pragma: no cover\n    _USE_LP = False\n\n# --------------------------------------------------------------\n# geometry helpers\n# --------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice of spacing *s* rotated by *rot* radians.\"\"\"\n    dy = s * sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius allowed by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# --------------------------------------------------------------\n# radius optimisation\n# --------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\",\n                  options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# --------------------------------------------------------------\n# simulated\u2011annealing refinement (two\u2011stage)\n# --------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    cur = best = start.copy()\n    cur_val = best_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:   # tiny uphill chance\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# --------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # dense sweep (more candidates than the original)\n    spacings = np.linspace(0.12, 0.26, 23)          # 23 spacings\n    rotations = np.linspace(0, pi / 3, 13)         # up to 60\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # two\u2011stage annealing: coarse then fine\n    best = _anneal(best, iters=1800, step=0.04, decay=0.998, seed=7)\n    best = _anneal(best, iters=2500, step=0.018, decay=0.9995, seed=11)\n    return best\n\n\n# --------------------------------------------------------------\n# public constructor\n# --------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nThis version expands the search space (more spacings & rotations) and adds a two\u2011stage annealing polish, which typically yields a larger total radius sum and therefore a higher fitness score while keeping the original API unchanged."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}