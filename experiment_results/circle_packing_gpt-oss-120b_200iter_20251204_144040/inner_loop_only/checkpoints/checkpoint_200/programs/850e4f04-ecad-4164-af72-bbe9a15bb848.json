{"id": "850e4f04-ecad-4164-af72-bbe9a15bb848", "code": "\"\"\"Improved 26\u2011circle packing \u2013 dense sweep + three\u2011stage anneal + polish.\n\nPublic API\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:  # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius allowed by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing (single pass)\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray, it: int, step: float,\n            decay: float, seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    bestv = curv = _opt_radii(cur).sum()\n    for _ in range(it):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > curv or rng.random() < 0.001:\n            cur, curv = cand, val\n            if val > bestv:\n                best, bestv = cand, val\n        step *= decay\n    return best\n\n# ----------------------------------------------------------------------\n# tiny deterministic polish\n# ----------------------------------------------------------------------\ndef _refine(layout: np.ndarray, delta: float = 0.006, passes: int = 2) -> np.ndarray:\n    best = layout.copy()\n    bestv = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                v = _opt_radii(cand).sum()\n                if v > bestv + 1e-12:\n                    best, bestv = cand, v\n                    improved = True\n        if not improved:\n            break\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage anneal + polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(0.125, 0.245, 23)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 15)    # 0\u201145\u00b0 in 15 steps\n    best, bestv = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            v = _opt_radii(pts).sum()\n            if v > bestv:\n                best, bestv = pts, v\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, 1500, 0.036, 0.998, 41)\n    best = _anneal(best, 2000, 0.018, 0.9995, 99)\n    best = _anneal(best, 1200, 0.009, 0.9999, 123)\n\n    # final deterministic tweak\n    return _refine(best, 0.006, 2)\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")", "language": "python", "parent_id": "4f74d431-fbe0-4ba2-99b2-7c223657d58e", "generation": 6, "timestamp": 1764885675.795657, "iteration_found": 200, "metrics": {"validity": 1.0, "sum_radii": 2.524504674488625, "target_ratio": 0.9580662901285104, "combined_score": 0.9580662901285104, "eval_time": 9.482553958892822}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.50863563868774, "target_ratio": 0.9520438856499963, "combined_score": 0.9520438856499963, "eval_time": 4.550727844238281}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.9520\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.9581 \u2192 0.9520. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5245, target_ratio: 0.9581, combined_score: 0.9581, eval_time: 9.2794\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5245, target_ratio: 0.9581, combined_score: 0.9581, eval_time: 8.9278\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5245, target_ratio: 0.9581, combined_score: 0.9581, eval_time: 9.1567\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9581)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 dense sweep + three\u2011stage anneal + polish.\n\nPublic API\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:  # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius allowed by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing (single pass)\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray, it: int, step: float,\n            decay: float, seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    bestv = curv = _opt_radii(cur).sum()\n    for _ in range(it):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > curv or rng.random() < 0.001:\n            cur, curv = cand, val\n            if val > bestv:\n                best, bestv = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic polish\n# ----------------------------------------------------------------------\ndef _refine(layout: np.ndarray, delta: float = 0.006, passes: int = 2) -> np.ndarray:\n    best = layout.copy()\n    bestv = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                v = _opt_radii(cand).sum()\n                if v > bestv + 1e-12:\n                    best, bestv = cand, v\n                    improved = True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage anneal + polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(0.125, 0.245, 23)      # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 15)  # 0\u201145\u00b0 in 15 steps\n    best, bestv = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            v = _opt_radii(pts).sum()\n            if v > bestv:\n                best, bestv = pts, v\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, 1500, 0.036, 0.998, 41)\n    best = _anneal(best, 2000, 0.018, 0.9995, 99)\n    best = _anneal(best, 1200, 0.009, 0.9999, 123)\n\n    # final deterministic tweak\n    return _refine(best, 0.006, 2)\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5245), Performs well on target_ratio (0.9581), Performs well on combined_score (0.9581), Performs well on eval_time (9.1567)\n\n### Program 2 (Score: 0.9581)\n```python\n\"\"\"26\u2011circle packing \u2013 compact version with three\u2011stage annealing.\n\nPublic API\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                   # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                     # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing s) rotated by rot (rad).\"\"\"\n    dy, pts, y, r = s * math.sqrt(3) / 2, [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if r % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        r += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                 bounds=[(0, bi) for bi in b],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing (single pass)\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray, it: int, step: float,\n            decay: float, seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    bestv = curv = _opt_radii(cur).sum()\n    for _ in range(it):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > curv or rng.random() < 0.001:\n            cur, curv = cand, val\n            if val > bestv:\n                best, bestv = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic polish\n# ----------------------------------------------------------------------\ndef _refine(layout: np.ndarray, delta: float = 0.006, passes: int = 2) -> np.ndarray:\n    best = layout.copy()\n    bestv = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                val = _opt_radii(cand).sum()\n                if val > bestv + 1e-12:\n                    best, bestv = cand, val\n                    improved = True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage annealing + polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(0.125, 0.245, 23)      # 23 spacings\n    rotations = np.linspace(0.0, math.pi / 4, 15)  # 15 rotations\n    best, bestv = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            v = _opt_radii(pts).sum()\n            if v > bestv:\n                best, bestv = pts, v\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, 1500, 0.036, 0.998, 41)\n    best = _anneal(best, 2000, 0.018, 0.9995, 99)\n    best = _anneal(best, 1200, 0.009, 0.9999, 123)\n\n    # final deterministic tweak\n    return _refine(best, 0.006, 2)\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5245), Performs well on target_ratio (0.9581), Performs well on combined_score (0.9581), Performs well on eval_time (8.9278)\n\n### Program 3 (Score: 0.9581)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math, random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                                 # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:                   # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* radians.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre (four walls).\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation (LP if available, otherwise deterministic heuristic)\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(\n        -np.ones(n),\n        A_ub=A,\n        b_ub=ub,\n        bounds=[(0, bi) for bi in b],\n        method=\"highs\",\n        options={\"presolve\": True},\n    )\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing refinement (three\u2011stage)\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(cur).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:   # occasional uphill move\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic polish after annealing\n# ----------------------------------------------------------------------\ndef _local_refine(layout: np.ndarray,\n                  delta: float = 0.006,\n                  passes: int = 2) -> np.ndarray:\n    best = layout.copy()\n    best_val = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                val = _opt_radii(cand).sum()\n                if val > best_val + 1e-12:\n                    best, best_val = cand, val\n                    improved = True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # dense sweep (more points than earlier versions)\n    spacings = np.linspace(0.125, 0.245, 23)       # 23 spacings\n    rotations = np.linspace(0.0, math.pi / 4, 15) # 15 rotations\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # three\u2011stage annealing\n    best = _anneal(best, iters=1500, step=0.036, decay=0.998, seed=41)\n    best = _anneal(best, iters=2000, step=0.018, decay=0.9995, seed=99)\n    best = _anneal(best, iters=1200, step=0.009, decay=0.9999, seed=123)\n\n    # final deterministic tweak\n    best = _local_refine(best, delta=0.006, passes=2)\n    return best\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5245), Performs well on target_ratio (0.9581), Performs well on combined_score (0.9581), Performs well on eval_time (9.2794)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9581)\n```python\n\"\"\"26\u2011circle packing \u2013 compact, fast, and high\u2011scoring.\n\nPublic API\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random, itertools\nimport numpy as np\n\n# ----- optional exact optimiser ------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:  # pragma: no cover\n    _LP = False\n\n# ----- geometry helpers -------------------------------------------------------\ndef _grid(n, s, r=0.0):\n    \"\"\"Triangular lattice (spacing s) rotated by r rad.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if r:\n        c = pts - 0.5\n        cs, sn = math.cos(r), math.sin(r)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c):\n    \"\"\"Max radius limited by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----- radius optimisation ----------------------------------------------------\ndef _lp_opt(c):\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c):\n    r = _border(c).copy()\n    for i, j in itertools.combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _LP else _heur_opt\n\n\n# ----- simulated\u2011annealing refinement -----------------------------------------\ndef _anneal(start, it, step, decay, seed):\n    rng = random.Random(seed)\n    cur = best = start.copy()\n    curv = bestv = _opt(cur).sum()\n    for _ in range(it):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > curv or rng.random() < 0.001:\n            cur, curv = cand, val\n            if val > bestv:\n                best, bestv = cand, val\n        step *= decay\n    return best\n\n\n# ----- tiny deterministic polish ---------------------------------------------\ndef _refine(layout, delta=0.006, passes=2):\n    best = layout.copy()\n    bestv = _opt(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                val = _opt(cand).sum()\n                if val > bestv + 1e-12:\n                    best, bestv = cand, val\n                    improved = True\n        if not improved:\n            break\n    return best\n\n\n# ----- layout search ---------------------------------------------------------\ndef _best_layout(n):\n    # dense sweep\n    spacings = np.linspace(0.125, 0.245, 23)\n    rotations = np.linspace(0.0, math.pi / 4, 15)\n    best, bestv = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            v = _opt(pts).sum()\n            if v > bestv:\n                best, bestv = pts, v\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, 1500, 0.036, 0.998, 41)\n    best = _anneal(best, 2000, 0.018, 0.9995, 99)\n    best = _anneal(best, 1200, 0.009, 0.9999, 123)\n\n    # final deterministic tweak\n    return _refine(best, 0.006, 2)\n\n\n# ----- public constructor -----------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9581)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 tighter search + three\u2011stage polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                       # fast LP if SciPy is available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:         # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(best).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps diversity\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb \u2013 final polish\n# ----------------------------------------------------------------------\ndef _local_refine(layout: np.ndarray,\n                  delta: float = 0.008,\n                  passes: int = 3) -> np.ndarray:\n    \"\"\"Move each centre by \u00b1\u03b4 while it improves the radius sum.\"\"\"\n    best = layout.copy()\n    best_val = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                val = _opt_radii(cand).sum()\n                if val > best_val + 1e-12:\n                    best, best_val = cand, val\n                    improved = True\n        if not improved:\n            break\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # very fine sweep (more points than previous versions)\n    spacings = np.linspace(0.125, 0.245, 23)       # 23 spacings\n    rotations = np.linspace(0.0, math.pi / 4, 15) # 15 rotations\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, iters=1500, step=0.036, decay=0.998, seed=41)\n    best = _anneal(best, iters=2000, step=0.018, decay=0.9995, seed=99)\n    best = _anneal(best, iters=1200, step=0.009, decay=0.9999, seed=123)\n\n    # final deterministic tweak\n    best = _local_refine(best, delta=0.006, passes=2)\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9392, Type: High-Performer)\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\nimport numpy as np\n\n# --------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# --------------------------------------------------------------\ntry:                         # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:           # pragma: no cover\n    _USE_LP = False\n\n# --------------------------------------------------------------\n# geometry helpers\n# --------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice of spacing *s* rotated by *rot* radians.\"\"\"\n    dy = s * sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n\n    if rot:\n        c = pts - 0.5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius allowed by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# --------------------------------------------------------------\n# radius optimisation\n# --------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\",\n                  options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n\n# --------------------------------------------------------------\n# simulated\u2011annealing refinement (two\u2011stage)\n# --------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    cur = best = start.copy()\n    cur_val = best_val = _opt_radii(cur).sum()\n\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        if val > cur_val or rng.random() < 0.001:   # tiny uphill chance\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# --------------------------------------------------------------\n# layout search \u2013 dense sweep + two\u2011stage polishing\n# --------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # dense sweep (more candidates than the original)\n    spacings = np.linspace(0.12, 0.26, 23)          # 23 spacings\n    rotations = np.linspace(0, pi / 3, 13)         # up to 60\u00b0\n    best, best_sum = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_sum:\n                best, best_sum = pts, val\n\n    # two\u2011stage annealing: coarse then fine\n    best = _anneal(best, iters=1800, step=0.04, decay=0.998, seed=7)\n    best = _anneal(best, iters=2500, step=0.018, decay=0.9995, seed=11)\n    return best\n\n\n# --------------------------------------------------------------\n# public constructor\n# --------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centers, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.475)\n\n### Inspiration 2 (Score: 0.9581, Type: High-Performer)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 dense sweep + three\u2011stage anneal + polish.\n\nPublic API\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\n\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:  # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius allowed by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing (single pass)\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray, it: int, step: float,\n            decay: float, seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    bestv = curv = _opt_radii(cur).sum()\n    for _ in range(it):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > curv or rng.random() < 0.001:\n            cur, curv = cand, val\n            if val > bestv:\n                best, bestv = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic polish\n# ----------------------------------------------------------------------\ndef _refine(layout: np.ndarray, delta: float = 0.006, passes: int = 2) -> np.ndarray:\n    best = layout.copy()\n    bestv = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                v = _opt_radii(cand).sum()\n                if v > bestv + 1e-12:\n                    best, bestv = cand, v\n                    improved = True\n        if not improved:\n            break\n    return best\n\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage anneal + polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(0.125, 0.245, 23)      # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 15)  # 0\u201145\u00b0 in 15 steps\n    best, bestv = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            v = _opt_radii(pts).sum()\n            if v > bestv:\n                best, bestv = pts, v\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, 1500, 0.036, 0.998, 41)\n    best = _anneal(best, 2000, 0.018, 0.9995, 99)\n    best = _anneal(best, 1200, 0.009, 0.9999, 123)\n\n    # final deterministic tweak\n    return _refine(best, 0.006, 2)\n\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.525)\n\n### Inspiration 3 (Score: 0.9581, Type: High-Performer)\n```python\n\"\"\"Improved 26\u2011circle packing \u2013 tighter search + three\u2011stage polish.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                       # fast LP if SciPy is available\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:         # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum admissible radius for each centre limited by the walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int,\n            step: float,\n            decay: float,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(best).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better; occasional uphill move keeps diversity\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n\n# ----------------------------------------------------------------------\n# tiny deterministic hill\u2011climb \u2013 final polish\n# ----------------------------------------------------------------------\ndef _local_refine(layout: np.ndarray,\n                  delta: float = 0.008,\n                  passes: int = 3) -> np.ndarray:\n    \"\"\"Move each centre by \u00b1\u03b4 while it improves the radius sum.\"\"\"\n    best = layout.copy()\n    best_val = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                val = _opt_radii(cand).sum()\n                if val > best_val + 1e-12:\n                    best, best_val = cand, val\n                    improved = True\n        if not improved:\n            break\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # very fine sweep (more points than previous versions)\n    spacings = np.linspace(0.125, 0.245, 23)       # 23 spacings\n    rotations = np.linspace(0.0, math.pi / 4, 15) # 15 rotations\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, iters=1500, step=0.036, decay=0.998, seed=41)\n    best = _anneal(best, iters=2000, step=0.018, decay=0.9995, seed=99)\n    best = _anneal(best, iters=1200, step=0.009, decay=0.9999, seed=123)\n\n    # final deterministic tweak\n    best = _local_refine(best, delta=0.006, passes=2)\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.525)\n\n# Current Program\n```python\n\"\"\"Improved 26\u2011circle packing.\n\nPublic API (unchanged):\n    construct_packing() \u2192 (centers, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport random, math\nimport numpy as np\nfrom itertools import combinations\nfrom math import cos, sin, pi, sqrt\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:                         # fast LP if SciPy is present\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:           # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice of spacing *s* rotated by *rot* (radians).\"\"\"\n    dy = s * sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), .5)])\n    if rot:\n        c = pts - .5\n        cs, sn = cos(rot), sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + .5\n    return np.clip(pts, .01, .99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius allowed by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A, ub = (np.array(rows), np.array(rhs)) if rows else (None, None)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing style refinement\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray,\n            iters: int = 2000,\n            step: float = 0.04,\n            decay: float = 0.999,\n            seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    best_val = cur_val = _opt_radii(best).sum()\n    for _ in range(iters):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        dx = (rng.random() * 2 - 1) * step\n        dy = (rng.random() * 2 - 1) * step\n        cand[i] += (dx, dy)\n        cand[i] = np.clip(cand[i], .01, .99)\n\n        val = _opt_radii(cand).sum()\n        # accept if better or with a tiny uphill probability\n        if val > cur_val or rng.random() < 0.001:\n            cur, cur_val = cand, val\n            if val > best_val:\n                best, best_val = cand, val\n        step *= decay\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 coarse sweep + two\u2011stage annealing\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    # broader, finer sweep than the previous version\n    spacings = np.linspace(0.13, 0.24, 15)          # 15 spacings\n    rots = np.linspace(0, pi / 4, 9)               # up to 45\u00b0\n    best, best_val = None, -1.0\n    for s in spacings:\n        for r in rots:\n            pts = _grid(n, s, r)\n            val = _opt_radii(pts).sum()\n            if val > best_val:\n                best, best_val = pts, val\n\n    # two\u2011stage annealing: coarse then fine\n    best = _anneal(best, iters=1200, step=0.03, decay=0.998, seed=1)\n    best = _anneal(best, iters=1800, step=0.015, decay=0.9995, seed=2)\n    return best\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"Improved 26\u2011circle packing \u2013 dense sweep + three\u2011stage anneal + polish.\n\nPublic API\n    construct_packing() \u2192 (centres, radii, sum_of_radii)\n\"\"\"\n\nfrom __future__ import annotations\nimport math, random\nfrom itertools import combinations\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# optional exact optimiser (SciPy)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _USE_LP = True\nexcept Exception:  # pragma: no cover\n    _USE_LP = False\n\n# ----------------------------------------------------------------------\n# geometry helpers\n# ----------------------------------------------------------------------\ndef _grid(n: int, s: float, rot: float = 0.0) -> np.ndarray:\n    \"\"\"Triangular lattice (spacing *s*) rotated by *rot* rad, clipped & padded.\"\"\"\n    dy = s * math.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0.0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.array(pts[:n])\n    if pts.shape[0] < n:                     # centre\u2011pad if short\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    if rot:\n        c = pts - 0.5\n        cs, sn = math.cos(rot), math.sin(rot)\n        pts = (c @ np.array([[cs, -sn], [sn, cs]])) + 0.5\n    return np.clip(pts, 0.01, 0.99)\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius allowed by the four walls.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n# ----------------------------------------------------------------------\n# radius optimisation\n# ----------------------------------------------------------------------\ndef _lp_opt(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    A = np.array(rows) if rows else None\n    ub = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=ub,\n                  bounds=[(0, bi) for bi in b],\n                  method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else b\n\n\ndef _heur_opt(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_opt if _USE_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# simulated\u2011annealing (single pass)\n# ----------------------------------------------------------------------\ndef _anneal(start: np.ndarray, it: int, step: float,\n            decay: float, seed: int | None = None) -> np.ndarray:\n    rng = random.Random(seed)\n    best = cur = start.copy()\n    bestv = curv = _opt_radii(cur).sum()\n    for _ in range(it):\n        i = rng.randrange(len(cur))\n        cand = cur.copy()\n        cand[i] += (rng.random() * 2 - 1) * step, (rng.random() * 2 - 1) * step\n        cand[i] = np.clip(cand[i], 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > curv or rng.random() < 0.001:\n            cur, curv = cand, val\n            if val > bestv:\n                best, bestv = cand, val\n        step *= decay\n    return best\n\n# ----------------------------------------------------------------------\n# tiny deterministic polish\n# ----------------------------------------------------------------------\ndef _refine(layout: np.ndarray, delta: float = 0.006, passes: int = 2) -> np.ndarray:\n    best = layout.copy()\n    bestv = _opt_radii(best).sum()\n    for _ in range(passes):\n        improved = False\n        for i in range(len(best)):\n            for dx, dy in ((delta, 0), (-delta, 0), (0, delta), (0, -delta)):\n                cand = best.copy()\n                cand[i] += (dx, dy)\n                cand[i] = np.clip(cand[i], 0.01, 0.99)\n                v = _opt_radii(cand).sum()\n                if v > bestv + 1e-12:\n                    best, bestv = cand, v\n                    improved = True\n        if not improved:\n            break\n    return best\n\n# ----------------------------------------------------------------------\n# layout search \u2013 dense sweep + three\u2011stage anneal + polish\n# ----------------------------------------------------------------------\ndef _best_layout(n: int) -> np.ndarray:\n    spacings = np.linspace(0.125, 0.245, 23)          # finer spacing grid\n    rotations = np.linspace(0.0, math.pi / 4, 15)    # 0\u201145\u00b0 in 15 steps\n    best, bestv = None, -1.0\n    for s in spacings:\n        for r in rotations:\n            pts = _grid(n, s, r)\n            v = _opt_radii(pts).sum()\n            if v > bestv:\n                best, bestv = pts, v\n\n    # three\u2011stage annealing (coarse \u2192 medium \u2192 fine)\n    best = _anneal(best, 1500, 0.036, 0.998, 41)\n    best = _anneal(best, 2000, 0.018, 0.9995, 99)\n    best = _anneal(best, 1200, 0.009, 0.9999, 123)\n\n    # final deterministic tweak\n    return _refine(best, 0.006, 2)\n\n# ----------------------------------------------------------------------\n# public constructor\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for the 26\u2011circle problem.\"\"\"\n    centres = _best_layout(26)\n    radii = _opt_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}