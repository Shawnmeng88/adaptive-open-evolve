{"id": "5ea620b3-23aa-4d40-8cd8-d65904b8f7f3", "code": "# EVOLVE-BLOCK-START\n\"\"\"\nImproved 26\u2011circle packer.\n\nKey ideas\n---------\n* Hexagonal lattice seed with a tiny random jitter (adds diversity).\n* Radii maximisation via LP when SciPy is present, otherwise a safe\n  pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine).\n* Two\u2011stage deterministic polish: a \u201cgrid\u2011snap\u201d (0.008) followed by a\n  finer \u201cmicro\u2011snap\u201d (0.004).\n* More restarts (12) while staying well within the time budget.\n\"\"\"\n\nimport random, itertools, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radii optimiser \u2013 LP if available, else heuristic\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_opt(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Maximise \u03a3 r_i subject to wall & pairwise distance constraints.\"\"\"\n    n = len(pts)\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        coeff = np.zeros(n)\n        coeff[i] = coeff[j] = 1.0\n        rows.append(coeff)\n        rhs.append(np.linalg.norm(pts[i] - pts[j]))\n\n    A = np.array(rows) if rows else None\n    b = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur_opt(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Iterative pair\u2011wise scaling \u2013 always feasible.\"\"\"\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    n = len(pts)\n    for i, j in itertools.combinations(range(n), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _HAS_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed with jitter\n# ----------------------------------------------------------------------\ndef _hex_jitter(n: int) -> np.ndarray:\n    \"\"\"Compact hexagonal lattice + \u00b10.01 random jitter.\"\"\"\n    spacing = 0.18\n    dy = spacing * np.sqrt(3) / 2\n    pts = []\n    y, row = spacing / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else spacing / 2\n        x = spacing / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n        row += 1\n\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    # centre padding if lattice is short\n    if pts.shape[0] < n:\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n\n    # tiny jitter to break symmetry\n    jitter = (np.random.rand(*pts.shape) - 0.5) * 0.02\n    pts = np.clip(pts + jitter, 0.01, 0.99)\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n\n    for step, iters in ((0.04, 1200), (0.012, 1800)):\n        for _ in range(iters):\n            i = random.randrange(n)\n            delta = (np.random.rand(2) * 2 - 1) * step\n            cand = best.copy()\n            cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n            val = _opt(cand).sum()\n            if val > best_val + 1e-9:\n                best, best_val = cand, val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Two\u2011stage deterministic polish\n# ----------------------------------------------------------------------\ndef _grid_snap(pts: np.ndarray, step: float) -> np.ndarray:\n    \"\"\"8\u2011neighbour local search with given step size.\"\"\"\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base, improved = cand, val, True\n    return pts\n\n\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Coarse grid\u2011snap followed by a finer micro\u2011snap.\"\"\"\n    pts = _grid_snap(pts, 0.008)\n    pts = _grid_snap(pts, 0.004)\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 12):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex_jitter(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END", "language": "python", "parent_id": "e6a49eea-5245-4730-9bc9-f3d43c71dd0c", "generation": 7, "timestamp": 1764885721.29925, "iteration_found": 196, "metrics": {"validity": 1.0, "sum_radii": 2.4932098061203956, "target_ratio": 0.9461896797420857, "combined_score": 0.9461896797420857, "eval_time": 89.73563480377197}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.426277948183266, "target_ratio": 0.9207885951359643, "combined_score": 0.9207885951359643, "eval_time": 32.79876089096069}, "island": 4}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.9208\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.9460 \u2192 0.9208. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4928, target_ratio: 0.9460, combined_score: 0.9460, eval_time: 34.8845\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4936, target_ratio: 0.9463, combined_score: 0.9463, eval_time: 103.4059\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4944, target_ratio: 0.9466, combined_score: 0.9466, eval_time: 34.9315\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9466)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer \u2013 repaired & slightly tuned.\n\nKey ideas\n---------\n* Hexagonal lattice seed (tight start).\n* Radii maximisation via a linear programme when SciPy is present,\n  otherwise a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) with a tiny\n  deterministic \u201cgrid\u2011snap\u201d polish.\n* Six (or more) independent restarts \u2013 still comfortably under the\n  time limit.\n* Fixed a bug that broke the hill\u2011climber in the previous version.\n\"\"\"\n\nimport random\nimport itertools\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Linear\u2011program / heuristic radii optimiser\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                 # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_opt(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Linear programme: maximise \u03a3 r_i subject to wall & pairwise constraints.\"\"\"\n    n = len(pts)\n    # maximal radii limited by the four walls\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        coeff = np.zeros(n)\n        coeff[i] = coeff[j] = 1.0\n        rows.append(coeff)\n        rhs.append(np.linalg.norm(pts[i] - pts[j]))\n\n    A = np.array(rows) if rows else None\n    b = np.array(rhs) if rhs else None\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur_opt(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Pair\u2011wise scaling \u2013 always feasible, never worse than the wall limits.\"\"\"\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    for i, j in itertools.combinations(range(len(pts)), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _HAS_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed \u2013 tight start\n# ----------------------------------------------------------------------\ndef _hex_seed(n: int) -> np.ndarray:\n    \"\"\"Generate a compact hexagonal lattice inside the unit square.\"\"\"\n    spacing = 0.18                     # empirically good for 26 circles\n    dy = spacing * np.sqrt(3) / 2\n    pts = []\n    y, row = spacing / 2, 0\n    while y < 1 and len(pts) < n:\n        offset = 0 if row % 2 == 0 else spacing / 2\n        x = spacing / 2 + offset\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n        row += 1\n\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    # If the lattice is too small, pad the centre.\n    if pts.shape[0] < n:\n        pts = np.vstack([pts,\n                        np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    \"\"\"Coarse \u2192 fine random jitter, keeping only improving moves.\"\"\"\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n\n    for step, iters in ((0.04, 1200), (0.012, 1800)):\n        for _ in range(iters):\n            i = random.randrange(n)\n            delta = (np.random.rand(2) * 2 - 1) * step\n            cand = best.copy()\n            cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n\n            cand_val = _opt(cand).sum()\n            if cand_val > best_val + 1e-9:\n                best = cand\n                best_val = cand_val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Tiny deterministic polish (grid\u2011snap)\n# ----------------------------------------------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Exhaustive 8\u2011neighbour local search until no improvement.\"\"\"\n    step = 0.008\n    n = len(pts)\n    improved = True\n\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts = cand\n                        base = val\n                        improved = True\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 6):\n    \"\"\"Run several independent restarts and keep the best layout.\"\"\"\n    best_sum = -1.0\n    best_centers = best_radii = None\n\n    for _ in range(restarts):\n        centers = _hex_seed(26)\n        centers = _climb(centers)\n        centers = _polish(centers)\n\n        radii = _opt(centers)\n        total = radii.sum()\n\n        if total > best_sum:\n            best_sum = total\n            best_centers = centers\n            best_radii = radii\n\n    return best_centers, best_radii, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API (unchanged signature)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4944), Performs well on target_ratio (0.9466), Performs well on combined_score (0.9466), Performs well on eval_time (34.9315)\n\n### Program 2 (Score: 0.9463)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer \u2013 more restarts & finer search.\n\nKey ideas\n---------\n* Hexagonal seed with a tiny random jitter per restart.\n* Radii maximisation via LP when SciPy is present, otherwise a safe\n  pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) with a bit more\n  iterations and larger steps.\n* Two\u2011stage deterministic polish: a \u201cgrid\u2011snap\u201d (0.008) followed by a\n  finer \u201cmicro\u2011snap\u201d (0.004).\n* 12 independent restarts \u2013 still comfortably under the time limit.\n\"\"\"\n\nimport random, itertools, numpy as np\n\n# ---------- radii optimiser ----------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_opt(pts: np.ndarray) -> np.ndarray:\n    n = len(pts)\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    A, b = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        row = np.zeros(n); row[i] = row[j] = 1.0\n        A.append(row); b.append(np.linalg.norm(pts[i] - pts[j]))\n    A = np.array(A) if A else None\n    b = np.array(b) if b else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur_opt(pts: np.ndarray) -> np.ndarray:\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    for i, j in itertools.combinations(range(len(pts)), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j]); r[i] *= s; r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _HAS_LP else _heur_opt\n\n# ---------- seed ----------\ndef _hex_seed(n: int) -> np.ndarray:\n    \"\"\"Hexagonal lattice + \u00b10.01 jitter.\"\"\"\n    s = 0.18\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy; row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # centre padding\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    # jitter\n    pts += (np.random.rand(*pts.shape) - 0.5) * 0.02\n    np.clip(pts, 0.01, 0.99, out=pts)\n    return pts\n\n# ---------- hill\u2011climber ----------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n    for step, iters in ((0.045, 1500), (0.015, 2500)):\n        for _ in range(iters):\n            i = random.randrange(n)\n            delta = (np.random.rand(2) * 2 - 1) * step\n            cand = best.copy()\n            cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n            val = _opt(cand).sum()\n            if val > best_val + 1e-9:\n                best, best_val = cand, val\n    return best\n\n# ---------- deterministic polish ----------\ndef _polish(pts: np.ndarray, step: float) -> np.ndarray:\n    \"\"\"8\u2011neighbour local search with given step size.\"\"\"\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0: continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base = cand, val\n                        improved = True\n    return pts\n\n\ndef _polish_all(pts: np.ndarray) -> np.ndarray:\n    pts = _polish(pts, 0.008)   # grid\u2011snap\n    pts = _polish(pts, 0.004)   # micro\u2011snap\n    return pts\n\n# ---------- multi\u2011restart driver ----------\ndef _search(restarts: int = 12):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex_seed(26)\n        c = _climb(c)\n        c = _polish_all(c)\n        r = _opt(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ---------- public API ----------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ---------- optional visualisation ----------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1); ax.set_ylim(0, 1); ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4936), Performs well on target_ratio (0.9463), Performs well on combined_score (0.9463), Performs well on eval_time (103.4059)\n\n### Program 3 (Score: 0.9460)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer \u2013 fast, high\u2011score version.\n\n* Hexagonal lattice seed.\n* Radii maximised by a linear programme when SciPy is present,\n  otherwise by a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) with a tiny\n  deterministic polish.\n* Several independent restarts; the best layout is returned.\n\"\"\"\n\nimport random, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radius optimiser (LP if possible, else heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_opt(pts: np.ndarray) -> np.ndarray:\n    n = len(pts)\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    A, b = [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = row[j] = 1.0\n            A.append(row)\n            b.append(np.linalg.norm(pts[i] - pts[j]))\n    A = np.array(A) if A else None\n    b = np.array(b) if b else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur_opt(pts: np.ndarray) -> np.ndarray:\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    n = len(pts)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(pts[i] - pts[j])\n            if r[i] + r[j] > d:\n                s = d / (r[i] + r[j])\n                r[i] *= s\n                r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _HAS_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed \u2013 tight start\n# ----------------------------------------------------------------------\ndef _hex(n: int) -> np.ndarray:\n    s = 0.18\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if len(pts) < n:                     # pad centre if needed\n        pts = np.vstack([pts, np.full((n - len(pts), 2), 0.5)])\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n\n    # coarse phase\n    for _ in range(1200):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.04\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n\n    # fine phase\n    for _ in range(1800):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.012\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Tiny deterministic polish\n# ----------------------------------------------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    step = 0.008\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base = cand, val\n                        improved = True\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 6):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API (unchanged signature)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4928), Performs well on target_ratio (0.9460), Performs well on combined_score (0.9460), Performs well on eval_time (34.8845)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9432)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved 26\u2011circle packer.\n\nKey ideas\n---------\n* Tight hexagonal seed.\n* Radii maximised by a linear programme when SciPy is available,\n  otherwise by a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) plus a tiny\n  deterministic \u201cgrid\u2011snap\u201d polish.\n* Six independent restarts \u2013 still comfortably under the time limit.\n\"\"\"\n\nimport random, itertools, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radius optimiser (LP if possible, else heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog          # may be missing in the sandbox\n    _HAS_LP = True\nexcept Exception:                              # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_radii(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Linear programme: maximise \u03a3 r_i subject to wall and pairwise constraints.\"\"\"\n    n = len(pts)\n    # maximal radii limited by the four walls\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        coeff = np.zeros(n)\n        coeff[i] = coeff[j] = 1.0\n        rows.append(coeff)\n        rhs.append(np.linalg.norm(pts[i] - pts[j]))\n    A = np.array(rows) if rows else None\n    b = np.array(rhs) if rhs else None\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur_radii(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Pair\u2011wise scaling \u2013 always feasible, never worse than the wall limits.\"\"\"\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    for i, j in itertools.combinations(range(len(pts)), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_radii if _HAS_LP else _heur_radii\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed \u2013 tight start\n# ----------------------------------------------------------------------\ndef _hex_seed(n: int) -> np.ndarray:\n    spacing = 0.18                     # tuned for 26 circles\n    dy = spacing * np.sqrt(3) / 2\n    pts = []\n    y, row = spacing / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else spacing / 2\n        x = spacing / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if len(pts) < n:                     # pad centre if needed\n        pts = np.vstack([pts, np.full((n - len(pts), 2), 0.5)])\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    \"\"\"Coarse \u2192 fine random jitter, always keeping improving moves.\"\"\"\n    best = start.copy()\n    best_val = _opt_radii(best).sum()\n    n = len(best)\n\n    # ---- coarse phase --------------------------------------------------\n    for _ in range(1200):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.04\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n\n    # ---- fine phase ----------------------------------------------------\n    for _ in range(1800):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.012\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Tiny deterministic polish (grid\u2011snap)\n# ----------------------------------------------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    step = 0.008\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt_radii(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt_radii(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base = cand, val\n                        improved = True\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 6):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex_seed(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt_radii(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API (unchanged signature)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9445)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved 26\u2011circle packer.\n\nKey ideas\n---------\n* Hexagonal lattice seed (tight start).\n* Radii maximisation via a linear programme when SciPy is present,\n  otherwise a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) followed by a tiny\n  deterministic \u201cgrid\u2011snap\u201d polish.\n* Six independent restarts \u2013 still well under the time limit.\n\"\"\"\nimport random, itertools, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radius optimiser (LP if possible, else heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                     # pragma: no cover\n    _LP = False\n\n\ndef _lp_radii(pts: np.ndarray) -> np.ndarray:\n    n = len(pts)\n    # wall limits\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        coeff = np.zeros(n)\n        coeff[i] = coeff[j] = 1.0\n        rows.append(coeff)\n        rhs.append(np.linalg.norm(pts[i] - pts[j]))\n    A = np.array(rows) if rows else None\n    b = np.array(rhs) if rhs else None\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method='highs', options={'presolve': True})\n    return res.x if res.success else wall\n\n\ndef _heur_radii(pts: np.ndarray) -> np.ndarray:\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    for i, j in itertools.combinations(range(len(pts)), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt_radii = _lp_radii if _LP else _heur_radii\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed \u2013 compact start\n# ----------------------------------------------------------------------\ndef _hex_seed(n: int) -> np.ndarray:\n    s = 0.18                                 # tuned spacing\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if len(pts) < n:                         # pad centre if needed\n        pts = np.vstack([pts, np.full((n - len(pts), 2), 0.5)])\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt_radii(best).sum()\n    n = len(best)\n\n    # ----- coarse phase -------------------------------------------------\n    for _ in range(1200):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.04\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n\n    # ----- fine phase ---------------------------------------------------\n    for _ in range(1800):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.012\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt_radii(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Tiny deterministic polish (grid\u2011snap)\n# ----------------------------------------------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    step = 0.008\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt_radii(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt_radii(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base = cand, val\n                        improved = True\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 6):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex_seed(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt_radii(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API (unchanged signature)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, total = run_packing()\n    print(f'Sum of radii: {total:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9424, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer \u2013 tuned for higher fitness.\n\nKey ideas\n---------\n* Tight hexagonal lattice seed (the most effective start).\n* Radii maximisation via a linear programme when SciPy is present,\n  otherwise a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) with a tiny\n  deterministic \u201cgrid\u2011snap\u201d polish.\n* Six independent restarts \u2013 still comfortably under the time limit.\n\"\"\"\n\nimport random, itertools, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radii optimiser (LP if available, else heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_opt(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Linear programme: maximise \u03a3 r_i subject to walls and pairwise distances.\"\"\"\n    n = len(pts)\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        coeff = np.zeros(n)\n        coeff[i] = coeff[j] = 1.0\n        rows.append(coeff)\n        rhs.append(np.linalg.norm(pts[i] - pts[j]))\n\n    A = np.array(rows) if rows else None\n    b = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur_opt(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Pair\u2011wise scaling \u2013 always feasible, never worse than wall limits.\"\"\"\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    for i, j in itertools.combinations(range(len(pts)), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _HAS_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed \u2013 tight start\n# ----------------------------------------------------------------------\ndef _hex_seed(n: int) -> np.ndarray:\n    \"\"\"Generate a compact hexagonal lattice inside the unit square.\"\"\"\n    s = 0.18                     # tuned spacing for 26 circles\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if needed\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    \"\"\"Coarse \u2192 fine jitter, keeping only improving moves.\"\"\"\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n\n    for step, iters in ((0.04, 1200), (0.012, 1800)):\n        for _ in range(iters):\n            i = random.randrange(n)\n            delta = (np.random.rand(2) * 2 - 1) * step\n            cand = best.copy()\n            cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n            val = _opt(cand).sum()\n            if val > best_val + 1e-9:\n                best, best_val = cand, val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Tiny deterministic polish (grid\u2011snap)\n# ----------------------------------------------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Exhaustive 8\u2011neighbour local search until no improvement.\"\"\"\n    step = 0.008\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base, improved = cand, val, True\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 6):\n    \"\"\"Run several independent restarts and keep the best layout.\"\"\"\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex_seed(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.483)\n\n### Inspiration 2 (Score: 0.9422, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer.\n* Hexagonal seed \u2192 two\u2011phase stochastic hill\u2011climber \u2192 tiny grid polish.\n* Radii via LP (SciPy) or safe pair\u2011wise heuristic.\n* 6 restarts, pure NumPy \u2192 fast and high\u2011score.\n\"\"\"\nimport random, itertools, numpy as np\n\n# ----- LP / heuristic radii optimiser ---------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                     # pragma: no cover\n    _LP = False\n\n\ndef _lp(pts: np.ndarray) -> np.ndarray:\n    n = len(pts)\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    A, b = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        A.append(row)\n        b.append(np.linalg.norm(pts[i] - pts[j]))\n    res = linprog(-np.ones(n), A_ub=A or None, b_ub=b or None,\n                  bounds=[(0, ub) for ub in wall], method=\"highs\")\n    return res.x if res.success else wall\n\n\ndef _heur(pts: np.ndarray) -> np.ndarray:\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    for i, j in itertools.combinations(range(len(pts)), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp if _LP else _heur\n\n# ----- Hexagonal seed --------------------------------------------------\ndef _seed(n: int) -> np.ndarray:\n    s = 0.18\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:                     # pad centre if needed\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n# ----- Two\u2011phase stochastic hill\u2011climber -----------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n    for step, iters in ((0.04, 1200), (0.012, 1800)):\n        for _ in range(iters):\n            i = random.randrange(n)\n            delta = (np.random.rand(2) * 2 - 1) * step\n            cand = best.copy()\n            cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n            val = _opt(cand).sum()\n            if val > best_val + 1e-9:\n                best, best_val = cand, val\n    return best\n\n# ----- Tiny deterministic grid polish ---------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    step = 0.008\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base, improved = cand, val, True\n    return pts\n\n# ----- Multi\u2011restart driver -------------------------------------------\ndef _search(restarts: int = 6):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _seed(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ----- Public API ------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----- Optional visualisation -------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.483)\n\n### Inspiration 3 (Score: 0.9189, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved 26\u2011circle packer.\n\nKey ideas\n---------\n* Tight hexagonal seed (spacing tuned for 26 circles).\n* Radii maximised by a linear programme when SciPy is present,\n  otherwise by a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) plus a tiny\n  deterministic grid\u2011polish.\n* Six independent restarts \u2013 stays well within the time limit.\n\"\"\"\n\nimport random, itertools, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radii optimiser (LP if available, else heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                     # pragma: no cover\n    _LP = False\n\n\ndef _lp(pts: np.ndarray) -> np.ndarray:\n    n = len(pts)\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    A, b = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        A.append(row)\n        b.append(np.linalg.norm(pts[i] - pts[j]))\n    A = np.array(A) if A else None\n    b = np.array(b) if b else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur(pts: np.ndarray) -> np.ndarray:\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    for i, j in itertools.combinations(range(len(pts)), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp if _LP else _heur\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed \u2013 tight start\n# ----------------------------------------------------------------------\ndef _hex(n: int) -> np.ndarray:\n    s = 0.18\n    dy = s * np.sqrt(3) / 2\n    pts = []\n    y, row = s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if len(pts) < n:                     # pad centre if needed\n        pts = np.vstack([pts, np.full((n - len(pts), 2), 0.5)])\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n\n    # coarse phase\n    for _ in range(1200):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.04\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n\n    # fine phase\n    for _ in range(1800):\n        i = random.randrange(n)\n        delta = (np.random.rand(2) * 2 - 1) * 0.012\n        cand = best.copy()\n        cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n        val = _opt(cand).sum()\n        if val > best_val + 1e-8:\n            best, best_val = cand, val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Tiny deterministic polish (grid\u2011snap)\n# ----------------------------------------------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    step = 0.008\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base, improved = cand, val, True\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 6):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.421)\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nCompact 26\u2011circle packer \u2013 fast, high\u2011score version.\n\nKey ideas\n---------\n* Hexagonal lattice seed \u2013 a tight deterministic start.\n* Radii maximisation via a linear programme when SciPy is available,\n  otherwise a safe pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine) with a fixed number\n  of iterations \u2013 fast and reliable.\n* Tiny deterministic \u201cgrid\u2011snap\u201d polish that exhaustively checks the\n  8\u2011neighbour moves until no improvement.\n* Six independent restarts (well under the time limit).\n* Public API unchanged: run_packing() \u2192 (centers, radii, sum_of_radii).\n\"\"\"\n\nimport random\nimport itertools\nimport numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radii optimiser \u2013 LP when possible, otherwise a heuristic\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:               # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_opt(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Linear programme: maximise \u03a3 r_i subject to wall & pairwise constraints.\"\"\"\n    n = len(pts)\n    # wall limits \u2013 distance to the four sides of the unit square\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        coeff = np.zeros(n)\n        coeff[i] = coeff[j] = 1.0\n        rows.append(coeff)\n        rhs.append(np.linalg.norm(pts[i] - pts[j]))\n\n    A = np.array(rows) if rows else None\n    b = np.array(rhs) if rhs else None\n\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur_opt(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Pair\u2011wise scaling \u2013 always feasible and never worse than the wall limits.\"\"\"\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    n = len(pts)\n    for i, j in itertools.combinations(range(n), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _HAS_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed \u2013 compact deterministic start\n# ----------------------------------------------------------------------\ndef _hex_seed(n: int) -> np.ndarray:\n    \"\"\"Generate a tight hexagonal lattice inside the unit square.\"\"\"\n    spacing = 0.18                     # empirically good for 26 circles\n    dy = spacing * np.sqrt(3) / 2\n    pts = []\n    y, row = spacing / 2, 0\n    while y < 1 and len(pts) < n:\n        offset = 0 if row % 2 == 0 else spacing / 2\n        x = spacing / 2 + offset\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n        row += 1\n\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n\n    # If the lattice is too small (unlikely for n=26) pad the centre.\n    if pts.shape[0] < n:\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    \"\"\"Coarse \u2192 fine random jitter, keeping only improving moves.\"\"\"\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n\n    # (step size, number of iterations)\n    for step, iters in ((0.04, 1200), (0.012, 1800)):\n        for _ in range(iters):\n            i = random.randrange(n)\n            delta = (np.random.rand(2) * 2 - 1) * step\n            cand = best.copy()\n            cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n\n            cand_val = _opt(cand).sum()\n            if cand_val > best_val + 1e-9:\n                best = cand\n                best_val = cand_val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Tiny deterministic polish (grid\u2011snap)\n# ----------------------------------------------------------------------\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Exhaustive 8\u2011neighbour local search until no improvement.\"\"\"\n    step = 0.008\n    n = len(pts)\n    improved = True\n\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts = cand\n                        base = val\n                        improved = True\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 6):\n    \"\"\"Run several independent restarts and keep the best layout.\"\"\"\n    best_sum = -1.0\n    best_centers = best_radii = None\n\n    for _ in range(restarts):\n        centers = _hex_seed(26)          # deterministic seed\n        centers = _climb(centers)        # stochastic hill\u2011climber\n        centers = _polish(centers)       # tiny deterministic polish\n\n        radii = _opt(centers)\n        total = radii.sum()\n\n        if total > best_sum:\n            best_sum = total\n            best_centers = centers\n            best_radii = radii\n\n    return best_centers, best_radii, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API (unchanged signature)\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"\nImproved 26\u2011circle packer.\n\nKey ideas\n---------\n* Hexagonal lattice seed with a tiny random jitter (adds diversity).\n* Radii maximisation via LP when SciPy is present, otherwise a safe\n  pair\u2011wise scaling heuristic.\n* Two\u2011phase stochastic hill\u2011climber (coarse \u2192 fine).\n* Two\u2011stage deterministic polish: a \u201cgrid\u2011snap\u201d (0.008) followed by a\n  finer \u201cmicro\u2011snap\u201d (0.004).\n* More restarts (12) while staying well within the time budget.\n\"\"\"\n\nimport random, itertools, numpy as np\n\n# ----------------------------------------------------------------------\n# 1\ufe0f\u20e3  Radii optimiser \u2013 LP if available, else heuristic\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _HAS_LP = True\nexcept Exception:                     # pragma: no cover\n    _HAS_LP = False\n\n\ndef _lp_opt(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Maximise \u03a3 r_i subject to wall & pairwise distance constraints.\"\"\"\n    n = len(pts)\n    wall = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n\n    rows, rhs = [], []\n    for i, j in itertools.combinations(range(n), 2):\n        coeff = np.zeros(n)\n        coeff[i] = coeff[j] = 1.0\n        rows.append(coeff)\n        rhs.append(np.linalg.norm(pts[i] - pts[j]))\n\n    A = np.array(rows) if rows else None\n    b = np.array(rhs) if rhs else None\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                 bounds=[(0, ub) for ub in wall],\n                 method=\"highs\", options={\"presolve\": True})\n    return res.x if res.success else wall\n\n\ndef _heur_opt(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Iterative pair\u2011wise scaling \u2013 always feasible.\"\"\"\n    r = np.minimum.reduce([pts[:, 0], pts[:, 1], 1 - pts[:, 0], 1 - pts[:, 1]])\n    n = len(pts)\n    for i, j in itertools.combinations(range(n), 2):\n        d = np.linalg.norm(pts[i] - pts[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\n_opt = _lp_opt if _HAS_LP else _heur_opt\n\n# ----------------------------------------------------------------------\n# 2\ufe0f\u20e3  Hexagonal seed with jitter\n# ----------------------------------------------------------------------\ndef _hex_jitter(n: int) -> np.ndarray:\n    \"\"\"Compact hexagonal lattice + \u00b10.01 random jitter.\"\"\"\n    spacing = 0.18\n    dy = spacing * np.sqrt(3) / 2\n    pts = []\n    y, row = spacing / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else spacing / 2\n        x = spacing / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += spacing\n        y += dy\n        row += 1\n\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    # centre padding if lattice is short\n    if pts.shape[0] < n:\n        pts = np.vstack([pts,\n                         np.full((n - pts.shape[0], 2), 0.5)])\n\n    # tiny jitter to break symmetry\n    jitter = (np.random.rand(*pts.shape) - 0.5) * 0.02\n    pts = np.clip(pts + jitter, 0.01, 0.99)\n    return pts\n\n# ----------------------------------------------------------------------\n# 3\ufe0f\u20e3  Two\u2011phase stochastic hill\u2011climber\n# ----------------------------------------------------------------------\ndef _climb(start: np.ndarray) -> np.ndarray:\n    best = start.copy()\n    best_val = _opt(best).sum()\n    n = len(best)\n\n    for step, iters in ((0.04, 1200), (0.012, 1800)):\n        for _ in range(iters):\n            i = random.randrange(n)\n            delta = (np.random.rand(2) * 2 - 1) * step\n            cand = best.copy()\n            cand[i] = np.clip(cand[i] + delta, 0.01, 0.99)\n            val = _opt(cand).sum()\n            if val > best_val + 1e-9:\n                best, best_val = cand, val\n    return best\n\n# ----------------------------------------------------------------------\n# 4\ufe0f\u20e3  Two\u2011stage deterministic polish\n# ----------------------------------------------------------------------\ndef _grid_snap(pts: np.ndarray, step: float) -> np.ndarray:\n    \"\"\"8\u2011neighbour local search with given step size.\"\"\"\n    n = len(pts)\n    improved = True\n    while improved:\n        improved = False\n        base = _opt(pts).sum()\n        for i in range(n):\n            for dx in (-step, 0, step):\n                for dy in (-step, 0, step):\n                    if dx == dy == 0:\n                        continue\n                    cand = pts.copy()\n                    cand[i] = np.clip(cand[i] + [dx, dy], 0.01, 0.99)\n                    val = _opt(cand).sum()\n                    if val > base + 1e-9:\n                        pts, base, improved = cand, val, True\n    return pts\n\n\ndef _polish(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Coarse grid\u2011snap followed by a finer micro\u2011snap.\"\"\"\n    pts = _grid_snap(pts, 0.008)\n    pts = _grid_snap(pts, 0.004)\n    return pts\n\n# ----------------------------------------------------------------------\n# 5\ufe0f\u20e3  Multi\u2011restart driver\n# ----------------------------------------------------------------------\ndef _search(restarts: int = 12):\n    best_sum = -1.0\n    best_c = best_r = None\n    for _ in range(restarts):\n        c = _hex_jitter(26)\n        c = _climb(c)\n        c = _polish(c)\n        r = _opt(c)\n        s = r.sum()\n        if s > best_sum:\n            best_sum, best_c, best_r = s, c, r\n    return best_c, best_r, float(best_sum)\n\n# ----------------------------------------------------------------------\n# 6\ufe0f\u20e3  Public API\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centers, radii, sum_of_radii) for 26 circles.\"\"\"\n    return _search()\n\n\ndef run_packing():\n    \"\"\"Entry\u2011point used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 7\ufe0f\u20e3  Optional visualisation (unchanged)\n# ----------------------------------------------------------------------\ndef visualize(centers, radii):\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n\n    for i, (c, r) in enumerate(zip(centers, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Packing \u2013 sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, total = run_packing()\n    print(f\"Sum of radii: {total:.6f}\")\n# EVOLVE-BLOCK-END\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}