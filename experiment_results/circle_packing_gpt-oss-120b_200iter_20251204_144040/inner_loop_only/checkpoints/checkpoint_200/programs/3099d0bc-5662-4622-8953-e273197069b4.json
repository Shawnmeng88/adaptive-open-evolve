{"id": "3099d0bc-5662-4622-8953-e273197069b4", "code": "\"\"\"Improved hex\u2011lattice circle packing (n=26).\n\nPublic API\n    centres, radii, total = run_packing()\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1.  Deterministic hexagonal seed\n# ----------------------------------------------------------------------\ndef _seed_hex(n: int) -> np.ndarray:\n    \"\"\"Compact hexagonal grid inside the unit square.\"\"\"\n    s = 0.18                      # spacing tuned for 26 circles\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:                     # pad centre if we run short\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n\n# ----------------------------------------------------------------------\n# 2.  Radius optimisation \u2013 LP when available, otherwise cheap heuristic\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _CAN_LP = True\nexcept Exception:                         # pragma: no cover\n    _CAN_LP = False\n\n\ndef _border(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the unit\u2011square border.\"\"\"\n    return np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n\n\ndef _optimise_lp(centers: np.ndarray) -> np.ndarray:\n    n = len(centers)\n    b = _border(centers)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b_ = np.array(rows), np.array(rhs)\n    res = linprog(\n        -np.ones(n), A_ub=A, b_ub=b_, bounds=[(0, lim) for lim in b], method=\"highs\"\n    )\n    return res.x if res.success else b\n\n\ndef _optimise_heur(centers: np.ndarray) -> np.ndarray:\n    r = _border(centers).copy()\n    for i, j in combinations(range(len(centers)), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(centers: np.ndarray) -> np.ndarray:\n    return _optimise_lp(centers) if _CAN_LP else _optimise_heur(centers)\n\n\n# ----------------------------------------------------------------------\n# 3.  Aggressive multi\u2011restart hill\u2011climb with final polish\n# ----------------------------------------------------------------------\ndef _hill(start: np.ndarray, iters: int, step: float, rng: np.random.Generator):\n    \"\"\"Single hill\u2011climb run \u2013 keep a move only if total radius grows.\"\"\"\n    best_c = start.copy()\n    best_r = _optimise_radii(best_c)\n    best_score = best_r.sum()\n    for _ in range(iters):\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(\n            cand[i] + (rng.random(2) - 0.5) * step, 0.01, 0.99\n        )\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best_score:\n            best_c, best_r, best_score = cand, r, s\n    return best_c, best_r, best_score\n\n\ndef _optimise_layout(seed: np.ndarray,\n                    restarts: int = 12,\n                    iters: int = 6000,\n                    step: float = 0.07,\n                    refine_iters: int = 2000,\n                    refine_step: float = 0.02) -> np.ndarray:\n    \"\"\"Multi\u2011restart search + a short refinement pass.\"\"\"\n    rng = np.random.default_rng(42)\n    best_c, best_r, best_score = None, None, -1.0\n\n    for _ in range(restarts):\n        jitter = (rng.random(seed.shape) - 0.5) * step\n        start = np.clip(seed + jitter, 0.01, 0.99)\n        c, r, s = _hill(start, iters, step, rng)\n        if s > best_score:\n            best_c, best_r, best_score = c, r, s\n\n    # final fine\u2011grained polish\n    c, r, s = _hill(best_c, refine_iters, refine_step, rng)\n    return c\n\n\n# ----------------------------------------------------------------------\n# 4.  Public entry point\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    seed = _seed_hex(26)\n    centres = _optimise_layout(seed)\n    radii = _optimise_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 5.  Optional visualiser (not required for scoring)\n# ----------------------------------------------------------------------\ndef visualize(centres, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, tot = run_packing()\n    print(f\"Sum of radii: {tot:.6f}\")\n    # visualize(cs, rs)", "language": "python", "parent_id": "c0c574ef-33db-419a-af74-25390d740770", "generation": 5, "timestamp": 1764885426.173169, "iteration_found": 179, "metrics": {"validity": 1.0, "sum_radii": 2.467060876204603, "target_ratio": 0.9362659871744226, "combined_score": 0.9362659871744226, "eval_time": 117.2480456829071}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.277415611985736, "target_ratio": 0.8642943498997101, "combined_score": 0.8642943498997101, "eval_time": 0.6347792148590088}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert software developer tasked with iteratively improving a codebase.\nYour goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.\nThe system maintains a collection of diverse programs - both high fitness AND diversity are valuable.", "user": "# Current Program Information\n- Fitness: 0.8643\n- Feature coordinates: No feature coordinates\n- Focus areas: - Fitness declined: 0.9383 \u2192 0.8643. Consider revising recent changes.\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4723, target_ratio: 0.9383, combined_score: 0.9383, eval_time: 94.1601\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4759, target_ratio: 0.9396, combined_score: 0.9396, eval_time: 111.8404\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4778, target_ratio: 0.9403, combined_score: 0.9403, eval_time: 202.3892\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9403)\n```python\n\"\"\"Hex\u2011lattice circle packing for 26 circles \u2013 compact, fast and higher\u2011quality.\n\nPublic API\n    centres, radii, total = run_packing()\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1.  Deterministic hexagonal seed\n# ----------------------------------------------------------------------\ndef _seed(n: int) -> np.ndarray:\n    s, dy = 0.18, 0.18 * 3**0.5 / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:                     # pad centre if we run short\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n\n# ----------------------------------------------------------------------\n# 2.  Radii optimisation (LP when available, otherwise cheap heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                         # pragma: no cover\n    _LP = False\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\ndef _r_lp(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    res = linprog(-np.ones(n), A_ub=np.array(rows), b_ub=np.array(rhs),\n                  bounds=[(0, lim) for lim in b], method='highs')\n    return res.x if res.success else b\n\n\ndef _r_heur(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(c: np.ndarray) -> np.ndarray:\n    return _r_lp(c) if _LP else _r_heur(c)\n\n\n# ----------------------------------------------------------------------\n# 3.  Aggressive hill\u2011climb (multi\u2011restart + final refinement)\n# ----------------------------------------------------------------------\ndef _hill(start: np.ndarray, it: int, step: float, rng) -> tuple[np.ndarray, np.ndarray, float]:\n    best_c, best_r = start, _optimise_radii(start)\n    best = best_r.sum()\n    for k in range(it):\n        cur = step * (0.99 ** (k // 250))\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(cand[i] + (rng.random(2) - 0.5) * cur,\n                         0.01, 0.99)\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best:\n            best_c, best_r, best = cand, r, s\n    return best_c, best_r, best\n\n\ndef _refine(best_c: np.ndarray, rng, it: int = 2000, step: float = 0.02) -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"A short, fine\u2011grained hill\u2011climb starting from the current best layout.\"\"\"\n    return _hill(best_c, it, step, rng)\n\n\ndef _optimise_layout(seed: np.ndarray,\n                    restarts: int = 15,\n                    iters: int = 8000,\n                    step: float = 0.07) -> tuple[np.ndarray, np.ndarray, float]:\n    rng = np.random.default_rng(42)\n    best_c, best_r, best_s = None, None, -1.0\n    for _ in range(restarts):\n        jitter = (rng.random(seed.shape) - 0.5) * step\n        start = np.clip(seed + jitter, 0.01, 0.99)\n        c, r, s = _hill(start, iters, step, rng)\n        if s > best_s:\n            best_c, best_r, best_s = c, r, s\n    # final fine\u2011tuning\n    best_c, best_r, best_s = _refine(best_c, rng)\n    return best_c, best_r, best_s\n\n\n# ----------------------------------------------------------------------\n# 4.  Public entry point\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    seed = _seed(26)\n    c, r, s = _optimise_layout(seed)\n    return c, r, float(s)\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 5.  Optional visualiser (not required for scoring)\n# ----------------------------------------------------------------------\ndef visualize(centres: np.ndarray, radii: np.ndarray) -> None:\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Optimised packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, tot = run_packing()\n    print(f'Sum of radii: {tot:.6f}')\n    # visualize(cs, rs)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4778), Performs well on target_ratio (0.9403), Performs well on combined_score (0.9403), Performs well on eval_time (202.3892)\n\n### Program 2 (Score: 0.9396)\n```python\n\"\"\"Hex\u2011lattice circle packing (n=26) \u2013 higher\u2011quality multi\u2011restart hill\u2011climb.\n\nPublic API\n    centres, radii, total = run_packing()\n\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1.  Deterministic hexagonal seed\n# ----------------------------------------------------------------------\ndef _seed(n: int) -> np.ndarray:\n    \"\"\"Compact hex\u2011grid inside the unit square.\"\"\"\n    s = 0.18                     # spacing tuned for 26 circles\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:                     # pad centre if grid is short\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n\n# ----------------------------------------------------------------------\n# 2.  Radius optimisation (LP when available, else cheap heuristic)\n# ----------------------------------------------------------------------\ntry:                     # SciPy may be missing in the execution sandbox\n    from scipy.optimize import linprog\n    _CAN_LP = True\nexcept Exception:       # pragma: no cover\n    _CAN_LP = False\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited only by the unit\u2011square border.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\ndef _lp(c: np.ndarray) -> np.ndarray:\n    \"\"\"Linear\u2011programming maximise \u03a3r subject to border & pairwise constraints.\"\"\"\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    res = linprog(-np.ones(n), A_ub=np.array(rows), b_ub=np.array(rhs),\n                  bounds=[(0, lim) for lim in b], method='highs')\n    return res.x if res.success else b\n\n\ndef _heur(c: np.ndarray) -> np.ndarray:\n    \"\"\"Iterative pairwise scaling \u2013 always feasible.\"\"\"\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(c: np.ndarray) -> np.ndarray:\n    return _lp(c) if _CAN_LP else _heur(c)\n\n\n# ----------------------------------------------------------------------\n# 3.  Hill\u2011climb (single run) and final refinement\n# ----------------------------------------------------------------------\ndef _hill(start: np.ndarray,\n          iters: int,\n          step: float,\n          rng: np.random.Generator) -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Classic hill\u2011climb \u2013 keep a move only if total radius grows.\"\"\"\n    best_c = start.copy()\n    best_r = _optimise_radii(best_c)\n    best_score = best_r.sum()\n    stagnant = 0\n\n    for k in range(iters):\n        cur = step * (0.99 ** (k // 250))          # gradual step decay\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(cand[i] + (rng.random(2) - 0.5) * cur,\n                         0.01, 0.99)\n\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best_score:\n            best_c, best_r, best_score = cand, r, s\n            stagnant = 0\n        else:\n            stagnant += 1\n\n        if stagnant > 1000:                       # early stop on stagnation\n            break\n    return best_c, best_r, best_score\n\n\ndef _refine(best_c: np.ndarray,\n            rng: np.random.Generator,\n            iters: int = 2000,\n            step: float = 0.02) -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Fine\u2011grained hill\u2011climb starting from the current best layout.\"\"\"\n    return _hill(best_c, iters, step, rng)\n\n\n# ----------------------------------------------------------------------\n# 4.  Multi\u2011restart optimisation\n# ----------------------------------------------------------------------\ndef _optimise_layout(seed: np.ndarray,\n                     restarts: int = 12,\n                     iters: int = 6000,\n                     step: float = 0.07) -> tuple[np.ndarray, np.ndarray, float]:\n    rng = np.random.default_rng(42)\n    best = (None, None, -1.0)\n\n    for _ in range(restarts):\n        jitter = (rng.random(seed.shape) - 0.5) * step\n        start = np.clip(seed + jitter, 0.01, 0.99)\n        c, r, s = _hill(start, iters, step, rng)\n        if s > best[2]:\n            best = (c, r, s)\n\n    # a short, high\u2011resolution polish\n    c, r, s = _refine(best[0], rng)\n    return c, r, s\n\n\n# ----------------------------------------------------------------------\n# 5.  Public entry point\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    seed = _seed(26)\n    c, r, s = _optimise_layout(seed)\n    return c, r, float(s)\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 6.  Optional visualiser (unchanged API)\n# ----------------------------------------------------------------------\ndef visualize(centres: np.ndarray, radii: np.ndarray) -> None:\n    \"\"\"Matplotlib visualisation \u2013 not required for scoring.\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Optimised packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, tot = run_packing()\n    print(f'Sum of radii: {tot:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4759), Performs well on target_ratio (0.9396), Performs well on combined_score (0.9396), Performs well on eval_time (111.8404)\n\n### Program 3 (Score: 0.9383)\n```python\n\"\"\"Hex\u2011lattice circle packing (n=26) \u2013 enhanced multi\u2011restart hill\u2011climb.\n\nPublic API\n    centres, radii, total = run_packing()\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1.  Deterministic hexagonal seed\n# ----------------------------------------------------------------------\ndef _seed(n: int) -> np.ndarray:\n    s = 0.18                     # spacing tuned for 26 circles\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:                     # pad centre if needed\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n\n# ----------------------------------------------------------------------\n# 2.  Radius optimisation (LP when available, otherwise cheap heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _CAN_LP = True\nexcept Exception:                         # pragma: no cover\n    _CAN_LP = False\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited only by the unit\u2011square border.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\ndef _r_lp(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    res = linprog(-np.ones(n), A_ub=np.array(rows), b_ub=np.array(rhs),\n                  bounds=[(0, lim) for lim in b], method='highs')\n    return res.x if res.success else b\n\n\ndef _r_heur(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(c: np.ndarray) -> np.ndarray:\n    return _r_lp(c) if _CAN_LP else _r_heur(c)\n\n\n# ----------------------------------------------------------------------\n# 3.  Aggressive multi\u2011restart hill\u2011climb\n# ----------------------------------------------------------------------\ndef _hill(start: np.ndarray, iters: int, step: float,\n          rng: np.random.Generator) -> tuple[np.ndarray, np.ndarray, float]:\n    best_c, best_r = start, _optimise_radii(start)\n    best = best_r.sum()\n    for k in range(iters):\n        cur = step * (0.99 ** (k // 250))          # decay a bit slower\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(cand[i] + (rng.random(2) - 0.5) * cur,\n                          0.01, 0.99)\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best:\n            best_c, best_r, best = cand, r, s\n    return best_c, best_r, best\n\n\ndef _optimise_layout(seed: np.ndarray,\n                    restarts: int = 10,\n                    iters: int = 5000,\n                    step: float = 0.05) -> tuple[np.ndarray, np.ndarray, float]:\n    rng = np.random.default_rng(42)\n    best = (None, None, -1.0)\n    for _ in range(restarts):\n        jitter = (rng.random(seed.shape) - 0.5) * step\n        start = np.clip(seed + jitter, 0.01, 0.99)\n        c, r, s = _hill(start, iters, step, rng)\n        if s > best[2]:\n            best = (c, r, s)\n    return best\n\n\n# ----------------------------------------------------------------------\n# 4.  Public entry point\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    seed = _seed(26)\n    centres, radii, total = _optimise_layout(seed)\n    return centres, radii, float(total)\n\n\ndef run_packing():\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 5.  Optional visualiser (not required for scoring)\n# ----------------------------------------------------------------------\ndef visualize(centres, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, tot = run_packing()\n    print(f'Sum of radii: {tot:.6f}')\n    # visualize(cs, rs)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4723), Performs well on target_ratio (0.9383), Performs well on combined_score (0.9383), Performs well on eval_time (94.1601)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9383)\n```python\n\"\"\"Improved hex\u2011lattice circle packing (n=26).\n\nPublic API\n    centres, radii, total = run_packing()\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1.  Seed \u2013 compact hexagonal grid\n# ----------------------------------------------------------------------\ndef _seed(n: int) -> np.ndarray:\n    s, dy = 0.18, 0.18 * 3**0.5 / 2\n    pts, y, r = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if r % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        r += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n# ----------------------------------------------------------------------\n# 2.  Radius optimisation\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                     # pragma: no cover\n    _LP = False\n\n\ndef _border(c):                     # max radius from the square border\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\ndef _r_lp(c):\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    res = linprog(-np.ones(n), A_ub=np.array(rows), b_ub=np.array(rhs),\n                  bounds=[(0, lim) for lim in b], method='highs')\n    return res.x if res.success else b\n\n\ndef _r_heur(c):\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(c):\n    return _r_lp(c) if _LP else _r_heur(c)\n\n# ----------------------------------------------------------------------\n# 3.  Layout optimisation \u2013 aggressive multi\u2011restart hill\u2011climb\n# ----------------------------------------------------------------------\ndef _hill(start, it, step, rng):\n    best_c, best_r = start, _optimise_radii(start)\n    best = best_r.sum()\n    for k in range(it):\n        cur = step * (0.99 ** (k // 250))\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(cand[i] + (rng.random(2) - 0.5) * cur, 0.01, 0.99)\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best:\n            best_c, best_r, best = cand, r, s\n    return best_c, best_r, best\n\n\ndef _optimise_layout(seed):\n    rng = np.random.default_rng(42)\n    best = (None, None, -1.0)\n    for _ in range(10):                     # more restarts\n        jitter = (rng.random(seed.shape) - 0.5) * 0.05\n        start = np.clip(seed + jitter, 0.01, 0.99)\n        c, r, s = _hill(start, 5000, 0.05, rng)   # longer search\n        if s > best[2]:\n            best = (c, r, s)\n    return best\n\n# ----------------------------------------------------------------------\n# 4.  Public entry point\n# ----------------------------------------------------------------------\ndef construct_packing():\n    seed = _seed(26)\n    c, r, s = _optimise_layout(seed)\n    return c, r, float(s)\n\n\ndef run_packing():\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 5.  Optional visualiser (not required for scoring)\n# ----------------------------------------------------------------------\ndef visualize(centres, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, tot = run_packing()\n    print(f'Sum of radii: {tot:.6f}')\n    # visualize(cs, rs)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9328)\n```python\n\"\"\"Hex\u2011lattice circle packing (n=26) \u2013 multi\u2011restart hill\u2011climb + LP radii.\n\nPublic API\n    centres, radii, total = run_packing()\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# -------------------------------------------------------------\n# 1.  Deterministic hexagonal seed\n# -------------------------------------------------------------\ndef _seed(n: int) -> np.ndarray:\n    s = 0.18\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:                     # pad centre if needed\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n\n# -------------------------------------------------------------\n# 2.  Radius optimisation (LP when available, else cheap heuristic)\n# -------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                         # pragma: no cover\n    _LP = False\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\ndef _r_lp(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    res = linprog(-np.ones(n), A_ub=np.array(rows), b_ub=np.array(rhs),\n                  bounds=[(0, lim) for lim in b], method=\"highs\")\n    return res.x if res.success else b\n\n\ndef _r_heur(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(c: np.ndarray) -> np.ndarray:\n    return _r_lp(c) if _LP else _r_heur(c)\n\n\n# -------------------------------------------------------------\n# 3.  Aggressive multi\u2011restart hill\u2011climb\n# -------------------------------------------------------------\ndef _hill(start: np.ndarray, iters: int, step: float, rng) -> tuple[np.ndarray, float]:\n    best_c, best_r = start, _optimise_radii(start)\n    best = best_r.sum()\n    for k in range(iters):\n        cur = step * (0.99 ** (k // 200))               # decay\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(cand[i] + (rng.random(2) - 0.5) * cur,\n                          0.01, 0.99)\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best:\n            best_c, best, = cand, s\n            best_r = r\n    return best_c, best\n\n\ndef _optimise_layout(seed: np.ndarray,\n                    restarts: int = 9,\n                    iters: int = 4000,\n                    step: float = 0.05) -> np.ndarray:\n    rng = np.random.default_rng(42)\n    best_c, best_score = None, -1.0\n    for _ in range(restarts):\n        jitter = (rng.random(seed.shape) - 0.5) * step\n        start = np.clip(seed + jitter, 0.01, 0.99)\n        c, s = _hill(start, iters, step, rng)\n        if s > best_score:\n            best_c, best_score = c, s\n    return best_c\n\n\n# -------------------------------------------------------------\n# 4.  Public entry point\n# -------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    seed = _seed(26)\n    centres = _optimise_layout(seed)\n    radii = _optimise_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# -------------------------------------------------------------\n# 5.  Optional visualiser (not required for scoring)\n# -------------------------------------------------------------\ndef visualize(centres, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, tot = run_packing()\n    print(f\"Sum of radii: {tot:.6f}\")\n    # visualize(cs, rs)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9328, Type: High-Performer)\n```python\n\"\"\"Hex\u2011lattice circle packing (n=26) \u2013 multi\u2011restart hill\u2011climb + LP radii.\n\nPublic API\n    centres, radii, total = run_packing()\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# -------------------------------------------------------------\n# 1.  Deterministic hexagonal seed\n# -------------------------------------------------------------\ndef _seed(n: int) -> np.ndarray:\n    s = 0.18\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:                     # pad centre if needed\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n\n# -------------------------------------------------------------\n# 2.  Radius optimisation (LP when available, else cheap heuristic)\n# -------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                         # pragma: no cover\n    _LP = False\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\ndef _r_lp(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    res = linprog(-np.ones(n), A_ub=np.array(rows), b_ub=np.array(rhs),\n                  bounds=[(0, lim) for lim in b], method=\"highs\")\n    return res.x if res.success else b\n\n\ndef _r_heur(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(c: np.ndarray) -> np.ndarray:\n    return _r_lp(c) if _LP else _r_heur(c)\n\n\n# -------------------------------------------------------------\n# 3.  Aggressive multi\u2011restart hill\u2011climb\n# -------------------------------------------------------------\ndef _hill(start: np.ndarray, iters: int, step: float, rng) -> tuple[np.ndarray, float]:\n    best_c, best_r = start, _optimise_radii(start)\n    best = best_r.sum()\n    for k in range(iters):\n        cur = step * (0.99 ** (k // 200))               # decay\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(cand[i] + (rng.random(2) - 0.5) * cur,\n                          0.01, 0.99)\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best:\n            best_c, best, = cand, s\n            best_r = r\n    return best_c, best\n\n\ndef _optimise_layout(seed: np.ndarray,\n                    restarts: int = 9,\n                    iters: int = 4000,\n                    step: float = 0.05) -> np.ndarray:\n    rng = np.random.default_rng(42)\n    best_c, best_score = None, -1.0\n    for _ in range(restarts):\n        jitter = (rng.random(seed.shape) - 0.5) * step\n        start = np.clip(seed + jitter, 0.01, 0.99)\n        c, s = _hill(start, iters, step, rng)\n        if s > best_score:\n            best_c, best_score = c, s\n    return best_c\n\n\n# -------------------------------------------------------------\n# 4.  Public entry point\n# -------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    seed = _seed(26)\n    centres = _optimise_layout(seed)\n    radii = _optimise_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# -------------------------------------------------------------\n# 5.  Optional visualiser (not required for scoring)\n# -------------------------------------------------------------\ndef visualize(centres, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, tot = run_packing()\n    print(f\"Sum of radii: {tot:.6f}\")\n    # visualize(cs, rs)\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.458)\n\n### Inspiration 2 (Score: 0.9403, Type: High-Performer)\n```python\n\"\"\"Hex\u2011lattice circle packing for 26 circles \u2013 compact, fast and higher\u2011quality.\n\nPublic API\n    centres, radii, total = run_packing()\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1.  Deterministic hexagonal seed\n# ----------------------------------------------------------------------\ndef _seed(n: int) -> np.ndarray:\n    s, dy = 0.18, 0.18 * 3**0.5 / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:                     # pad centre if we run short\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n\n# ----------------------------------------------------------------------\n# 2.  Radii optimisation (LP when available, otherwise cheap heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _LP = True\nexcept Exception:                         # pragma: no cover\n    _LP = False\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\ndef _r_lp(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    res = linprog(-np.ones(n), A_ub=np.array(rows), b_ub=np.array(rhs),\n                  bounds=[(0, lim) for lim in b], method='highs')\n    return res.x if res.success else b\n\n\ndef _r_heur(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(c: np.ndarray) -> np.ndarray:\n    return _r_lp(c) if _LP else _r_heur(c)\n\n\n# ----------------------------------------------------------------------\n# 3.  Aggressive hill\u2011climb (multi\u2011restart + final refinement)\n# ----------------------------------------------------------------------\ndef _hill(start: np.ndarray, it: int, step: float, rng) -> tuple[np.ndarray, np.ndarray, float]:\n    best_c, best_r = start, _optimise_radii(start)\n    best = best_r.sum()\n    for k in range(it):\n        cur = step * (0.99 ** (k // 250))\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(cand[i] + (rng.random(2) - 0.5) * cur,\n                         0.01, 0.99)\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best:\n            best_c, best_r, best = cand, r, s\n    return best_c, best_r, best\n\n\ndef _refine(best_c: np.ndarray, rng, it: int = 2000, step: float = 0.02) -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"A short, fine\u2011grained hill\u2011climb starting from the current best layout.\"\"\"\n    return _hill(best_c, it, step, rng)\n\n\ndef _optimise_layout(seed: np.ndarray,\n                    restarts: int = 15,\n                    iters: int = 8000,\n                    step: float = 0.07) -> tuple[np.ndarray, np.ndarray, float]:\n    rng = np.random.default_rng(42)\n    best_c, best_r, best_s = None, None, -1.0\n    for _ in range(restarts):\n        jitter = (rng.random(seed.shape) - 0.5) * step\n        start = np.clip(seed + jitter, 0.01, 0.99)\n        c, r, s = _hill(start, iters, step, rng)\n        if s > best_s:\n            best_c, best_r, best_s = c, r, s\n    # final fine\u2011tuning\n    best_c, best_r, best_s = _refine(best_c, rng)\n    return best_c, best_r, best_s\n\n\n# ----------------------------------------------------------------------\n# 4.  Public entry point\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    seed = _seed(26)\n    c, r, s = _optimise_layout(seed)\n    return c, r, float(s)\n\n\ndef run_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 5.  Optional visualiser (not required for scoring)\n# ----------------------------------------------------------------------\ndef visualize(centres: np.ndarray, radii: np.ndarray) -> None:\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Optimised packing \u2013 sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, tot = run_packing()\n    print(f'Sum of radii: {tot:.6f}')\n    # visualize(cs, rs)\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.478)\n\n### Inspiration 3 (Score: 0.9383, Type: High-Performer)\n```python\n\"\"\"Hex\u2011lattice circle packing (n=26) \u2013 enhanced multi\u2011restart hill\u2011climb.\n\nPublic API\n    centres, radii, total = run_packing()\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1.  Deterministic hexagonal seed\n# ----------------------------------------------------------------------\ndef _seed(n: int) -> np.ndarray:\n    s = 0.18                     # spacing tuned for 26 circles\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:                     # pad centre if needed\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n\n# ----------------------------------------------------------------------\n# 2.  Radius optimisation (LP when available, otherwise cheap heuristic)\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _CAN_LP = True\nexcept Exception:                         # pragma: no cover\n    _CAN_LP = False\n\n\ndef _border(c: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited only by the unit\u2011square border.\"\"\"\n    return np.minimum.reduce([c[:, 0], c[:, 1], 1 - c[:, 0], 1 - c[:, 1]])\n\n\ndef _r_lp(c: np.ndarray) -> np.ndarray:\n    n = len(c)\n    b = _border(c)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(c[i] - c[j]))\n    res = linprog(-np.ones(n), A_ub=np.array(rows), b_ub=np.array(rhs),\n                  bounds=[(0, lim) for lim in b], method='highs')\n    return res.x if res.success else b\n\n\ndef _r_heur(c: np.ndarray) -> np.ndarray:\n    r = _border(c).copy()\n    for i, j in combinations(range(len(c)), 2):\n        d = np.linalg.norm(c[i] - c[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(c: np.ndarray) -> np.ndarray:\n    return _r_lp(c) if _CAN_LP else _r_heur(c)\n\n\n# ----------------------------------------------------------------------\n# 3.  Aggressive multi\u2011restart hill\u2011climb\n# ----------------------------------------------------------------------\ndef _hill(start: np.ndarray, iters: int, step: float,\n          rng: np.random.Generator) -> tuple[np.ndarray, np.ndarray, float]:\n    best_c, best_r = start, _optimise_radii(start)\n    best = best_r.sum()\n    for k in range(iters):\n        cur = step * (0.99 ** (k // 250))          # decay a bit slower\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(cand[i] + (rng.random(2) - 0.5) * cur,\n                          0.01, 0.99)\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best:\n            best_c, best_r, best = cand, r, s\n    return best_c, best_r, best\n\n\ndef _optimise_layout(seed: np.ndarray,\n                    restarts: int = 10,\n                    iters: int = 5000,\n                    step: float = 0.05) -> tuple[np.ndarray, np.ndarray, float]:\n    rng = np.random.default_rng(42)\n    best = (None, None, -1.0)\n    for _ in range(restarts):\n        jitter = (rng.random(seed.shape) - 0.5) * step\n        start = np.clip(seed + jitter, 0.01, 0.99)\n        c, r, s = _hill(start, iters, step, rng)\n        if s > best[2]:\n            best = (c, r, s)\n    return best\n\n\n# ----------------------------------------------------------------------\n# 4.  Public entry point\n# ----------------------------------------------------------------------\ndef construct_packing() -> tuple[np.ndarray, np.ndarray, float]:\n    seed = _seed(26)\n    centres, radii, total = _optimise_layout(seed)\n    return centres, radii, float(total)\n\n\ndef run_packing():\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 5.  Optional visualiser (not required for scoring)\n# ----------------------------------------------------------------------\ndef visualize(centres, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, tot = run_packing()\n    print(f'Sum of radii: {tot:.6f}')\n    # visualize(cs, rs)\n```\nUnique approach: Modification: Full rewrite, Excellent validity (1.000), Excellent sum_radii (2.472)\n\n# Current Program\n```python\n\"\"\"Hex\u2011lattice circle packing (n=26) with LP\u2011based radius optimisation.\n\nPublic API (unchanged):\n    centres, radii, total = run_packing()\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1.  Geometry \u2013 deterministic hexagonal seed\n# ----------------------------------------------------------------------\ndef _hex_positions(n: int) -> np.ndarray:\n    s = 0.18                     # spacing tuned for 26 circles\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    pts = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if pts.shape[0] < n:                     # pad centre if needed\n        pts = np.vstack([pts, np.full((n - pts.shape[0], 2), 0.5)])\n    return pts\n\n\n# ----------------------------------------------------------------------\n# 2.  Radius optimisation \u2013 LP when available, else cheap heuristic\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _CAN_LP = True\nexcept Exception:                           # pragma: no cover\n    _CAN_LP = False\n\n\ndef _max_radii_lp(centers: np.ndarray) -> np.ndarray:\n    n = len(centers)\n    # border limits\n    b = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                          1 - centers[:, 0], 1 - centers[:, 1]])\n    # pairwise constraints  r_i + r_j \u2264 d_ij\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b_ = np.array(rows), np.array(rhs)\n    res = linprog(-np.ones(n), A_ub=A, b_ub=b_, bounds=[(0, lim) for lim in b],\n                 method='highs')\n    return res.x if res.success else b\n\n\ndef _max_radii_heur(centers: np.ndarray) -> np.ndarray:\n    n = len(centers)\n    r = np.minimum.reduce([centers[:, 0], centers[:, 1],\n                           1 - centers[:, 0], 1 - centers[:, 1]])\n    for i, j in combinations(range(n), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(centers: np.ndarray) -> np.ndarray:\n    return _max_radii_lp(centers) if _CAN_LP else _max_radii_heur(centers)\n\n\n# ----------------------------------------------------------------------\n# 3.  Light\u2011weight layout optimisation (hill\u2011climb)\n# ----------------------------------------------------------------------\ndef _optimise_layout(start: np.ndarray, iters: int = 250,\n                    step: float = 0.03, seed: int = 0) -> np.ndarray:\n    rng = np.random.default_rng(seed)\n    best_c = start.copy()\n    best_r = _optimise_radii(best_c)\n    best_score = best_r.sum()\n    for _ in range(iters):\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(cand[i] + (rng.random(2) - 0.5) * step,\n                          0.01, 0.99)\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best_score:\n            best_c, best_r, best_score = cand, r, s\n    return best_c\n\n\n# ----------------------------------------------------------------------\n# 4.  Public entry point\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    seed_pos = _hex_positions(26)\n    centres = _optimise_layout(seed_pos, iters=300, step=0.04, seed=42)\n    radii = _optimise_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 5.  Optional visualiser (not required for scoring)\n# ----------------------------------------------------------------------\ndef visualize(centres, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha='center', va='center')\n    plt.title(f'Sum\u202f=\u202f{radii.sum():.4f}')\n    plt.show()\n\n\nif __name__ == '__main__':\n    cs, rs, tot = run_packing()\n    print(f'Sum of radii: {tot:.6f}')\n    # visualize(cs, rs)   # uncomment to see the layout\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"Improved hex\u2011lattice circle packing (n=26).\n\nPublic API\n    centres, radii, total = run_packing()\n\"\"\"\n\nimport numpy as np\nfrom itertools import combinations\n\n# ----------------------------------------------------------------------\n# 1.  Deterministic hexagonal seed\n# ----------------------------------------------------------------------\ndef _seed_hex(n: int) -> np.ndarray:\n    \"\"\"Compact hexagonal grid inside the unit square.\"\"\"\n    s = 0.18                      # spacing tuned for 26 circles\n    dy = s * np.sqrt(3) / 2\n    pts, y, row = [], s / 2, 0\n    while y < 1 and len(pts) < n:\n        off = 0 if row % 2 == 0 else s / 2\n        x = s / 2 + off\n        while x < 1 and len(pts) < n:\n            pts.append([x, y])\n            x += s\n        y += dy\n        row += 1\n    a = np.clip(np.array(pts[:n]), 0.01, 0.99)\n    if a.shape[0] < n:                     # pad centre if we run short\n        a = np.vstack([a, np.full((n - a.shape[0], 2), 0.5)])\n    return a\n\n\n# ----------------------------------------------------------------------\n# 2.  Radius optimisation \u2013 LP when available, otherwise cheap heuristic\n# ----------------------------------------------------------------------\ntry:\n    from scipy.optimize import linprog\n    _CAN_LP = True\nexcept Exception:                         # pragma: no cover\n    _CAN_LP = False\n\n\ndef _border(centers: np.ndarray) -> np.ndarray:\n    \"\"\"Maximum radius limited by the unit\u2011square border.\"\"\"\n    return np.minimum.reduce(\n        [centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]]\n    )\n\n\ndef _optimise_lp(centers: np.ndarray) -> np.ndarray:\n    n = len(centers)\n    b = _border(centers)\n    rows, rhs = [], []\n    for i, j in combinations(range(n), 2):\n        row = np.zeros(n)\n        row[i] = row[j] = 1.0\n        rows.append(row)\n        rhs.append(np.linalg.norm(centers[i] - centers[j]))\n    A, b_ = np.array(rows), np.array(rhs)\n    res = linprog(\n        -np.ones(n), A_ub=A, b_ub=b_, bounds=[(0, lim) for lim in b], method=\"highs\"\n    )\n    return res.x if res.success else b\n\n\ndef _optimise_heur(centers: np.ndarray) -> np.ndarray:\n    r = _border(centers).copy()\n    for i, j in combinations(range(len(centers)), 2):\n        d = np.linalg.norm(centers[i] - centers[j])\n        if r[i] + r[j] > d:\n            s = d / (r[i] + r[j])\n            r[i] *= s\n            r[j] *= s\n    return r\n\n\ndef _optimise_radii(centers: np.ndarray) -> np.ndarray:\n    return _optimise_lp(centers) if _CAN_LP else _optimise_heur(centers)\n\n\n# ----------------------------------------------------------------------\n# 3.  Aggressive multi\u2011restart hill\u2011climb with final polish\n# ----------------------------------------------------------------------\ndef _hill(start: np.ndarray, iters: int, step: float, rng: np.random.Generator):\n    \"\"\"Single hill\u2011climb run \u2013 keep a move only if total radius grows.\"\"\"\n    best_c = start.copy()\n    best_r = _optimise_radii(best_c)\n    best_score = best_r.sum()\n    for _ in range(iters):\n        i = rng.integers(len(best_c))\n        cand = best_c.copy()\n        cand[i] = np.clip(\n            cand[i] + (rng.random(2) - 0.5) * step, 0.01, 0.99\n        )\n        r = _optimise_radii(cand)\n        s = r.sum()\n        if s > best_score:\n            best_c, best_r, best_score = cand, r, s\n    return best_c, best_r, best_score\n\n\ndef _optimise_layout(seed: np.ndarray,\n                    restarts: int = 12,\n                    iters: int = 6000,\n                    step: float = 0.07,\n                    refine_iters: int = 2000,\n                    refine_step: float = 0.02) -> np.ndarray:\n    \"\"\"Multi\u2011restart search + a short refinement pass.\"\"\"\n    rng = np.random.default_rng(42)\n    best_c, best_r, best_score = None, None, -1.0\n\n    for _ in range(restarts):\n        jitter = (rng.random(seed.shape) - 0.5) * step\n        start = np.clip(seed + jitter, 0.01, 0.99)\n        c, r, s = _hill(start, iters, step, rng)\n        if s > best_score:\n            best_c, best_r, best_score = c, r, s\n\n    # final fine\u2011grained polish\n    c, r, s = _hill(best_c, refine_iters, refine_step, rng)\n    return c\n\n\n# ----------------------------------------------------------------------\n# 4.  Public entry point\n# ----------------------------------------------------------------------\ndef construct_packing():\n    \"\"\"Return (centres, radii, sum_of_radii) for 26 circles.\"\"\"\n    seed = _seed_hex(26)\n    centres = _optimise_layout(seed)\n    radii = _optimise_radii(centres)\n    return centres, radii, float(radii.sum())\n\n\ndef run_packing():\n    \"\"\"Wrapper used by the evaluation harness.\"\"\"\n    return construct_packing()\n\n\n# ----------------------------------------------------------------------\n# 5.  Optional visualiser (not required for scoring)\n# ----------------------------------------------------------------------\ndef visualize(centres, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(6, 6))\n    ax.set_aspect(\"equal\")\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.grid(True)\n    for i, (c, r) in enumerate(zip(centres, radii)):\n        ax.add_patch(Circle(c, r, alpha=0.4))\n        ax.text(*c, str(i), ha=\"center\", va=\"center\")\n    plt.title(f\"Sum\u202f=\u202f{radii.sum():.4f}\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    cs, rs, tot = run_packing()\n    print(f\"Sum of radii: {tot:.6f}\")\n    # visualize(cs, rs)\n```"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}