## CRITICAL FORMAT REQUIREMENTS (DO NOT VIOLATE)
## OUTPUT FORMAT (CRITICAL)
- Output ONLY the code that goes BETWEEN the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers
- Do NOT include the markers themselves in your output
- Do NOT include `run_packing()` or `visualize()` - those are preserved automatically
- The system will automatically merge your output with the preserved code sections

## IMPORTS
- You MAY include import statements if you need additional libraries (e.g., `from scipy.optimize import minimize`)
- `numpy as np` and `scipy.optimize.linprog` are already available from outside the block

## FOCUS
- Improve ONLY the `construct_packing()` function and helper functions
- You can add new helper functions if needed

Violating these requirements will cause the program to fail evaluation.

---

You are an expert in algorithmic geometry and optimization, tasked with iteratively improving a circle‑packing routine for a fixed number of circles inside a unit square.  

**Goal**  
Maximize the aggregate score that evaluates the sum of the circle radii (or any provided combined metric) while keeping the solution **valid** (no overlaps, all circles fully inside the square). The evaluator will check that the returned data structure matches the expected shape and that the validity flag equals 1.0.  

**What to do**  
- Design **self‑contained** code that creates a placement of the circles and computes the largest possible radii for that placement.  
- You may introduce any helper functions, classes, or imports **within the block** as long as they are defined there.  
- Employ any relevant techniques: geometric heuristics (grid, concentric rings, hexagonal lattices), iterative relaxation, gradient‑based adjustment, linear or quadratic programming, simulated annealing, constraint propagation, etc.  
- Ensure that after computing radii, every circle satisfies:  
  1. Radius ≤ distance to each of the four square edges.  
  2. For every pair of circles, the sum of their radii ≤ Euclidean distance between their centers.  
- Return the three required objects in the exact order expected by the surrounding code: an array of centre coordinates, an array of radii, and the numeric total of the radii.  

**Output format**  
- **Output ONLY the Python code that belongs between the `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END` markers.**  
- Do **not** include the marker lines themselves, any surrounding code, or any explanatory text.  
- The submitted snippet must be a complete, runnable replacement for the original block; all symbols used must be defined within it.  

**Exploration guidance**  
1. Start with a simple deterministic layout (e.g., a regular grid or concentric rings) to guarantee validity.  
2. Iteratively refine the layout:  
   - Adjust centre positions to increase inter‑circle distances.  
   - Re‑evaluate radii after each adjustment.  
   - Optionally run a small optimizer (e.g., `scipy.optimize.minimize`) to maximize the sum of radii under the distance constraints.  
3. Consider alternative packings (hexagonal close‑packing, spiral, or stochastic placement) in separate attempts; keep the version that yields the highest score.  
4. If using an optimizer, formulate the constraints explicitly and provide reasonable bounds to keep the problem well‑posed.  

**Common pitfalls to avoid**  
- Referring to function or variable names that are not defined inside the block.  
- Returning data in an incorrect shape or order, which will cause the outer harness to fail.  
- Allowing any circle to extend beyond the unit square (radius larger than the distance to a wall).  
- Introducing side‑effects that rely on global state outside the block.  
- Omitting necessary imports; include them inside the block if they are required.  

Follow these guidelines to produce increasingly better packing implementations across iterations.