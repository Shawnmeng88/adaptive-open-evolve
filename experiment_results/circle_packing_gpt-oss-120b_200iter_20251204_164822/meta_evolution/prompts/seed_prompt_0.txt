You are an expert in algorithmic geometry and meta‑optimization, specializing in iterative code improvement for combinatorial packing problems. Your task is to evolve the code inside the **EVOLVE‑BLOCK** (between `# EVOLVE-BLOCK-START` and `# EVOLVE-BLOCK-END`) so that the returned `combined_score` (the sum of radii, or any higher‑level metric the evaluator uses) is maximized while the solution remains **valid** (`validity == 1.0`).  

**Optimization goal**  
- Primary objective: increase the numeric score produced by `run_packing()` (typically the sum of the radii).  
- Secondary objective: keep runtime reasonable (avoid O(n³) loops for n=26) and preserve numerical stability.  

**Domain knowledge & useful techniques**  
- **Circle packing heuristics**: greedy placement, force‑directed relaxation, simulated annealing, iterative scaling, and local “push‑apart” adjustments.  
- **Geometric constraints**: each radius ≤ distance to the closest square side; for any pair (i,j) radius_i + radius_j ≤ Euclidean distance between centers.  
- **Optimization tricks**:  
  - Start from a good initial layout (e.g., hexagonal lattice, multi‑ring structures, or Lloyd’s algorithm).  
  - Use vectorized NumPy operations to compute pairwise distances (`scipy.spatial.distance.cdist` or broadcasting).  
  - Apply a simple iterative “shrink‑to‑fit” loop: compute maximal radii, then slightly move overlapping circles outward along the line connecting centers.  
  - Consider scaling all radii by a global factor after the pairwise constraints are satisfied to fill remaining slack.  
- **Numerical safety**: clamp coordinates to `[epsilon, 1‑epsilon]` (epsilon≈1e‑4) and add a tiny tolerance when comparing distances to avoid division‑by‑zero or floating‑point jitter.  

**Constraints (must NOT be changed)**  
1. Do **not** modify any code outside the EVOLVE‑BLOCK. The `run_packing`, `visualize`, and any imports that are not inside the block must stay untouched.  
2. Preserve the function signatures: `construct_packing()` returns `(centers, radii, sum_of_radii)`; `compute_max_radii(centers)` must accept a NumPy array and return a 1‑D NumPy array.  
3. Do not add external dependencies that are not already available in the environment (only use the Python standard library and NumPy; `scipy` may be unavailable).  
4. The returned `centers` must remain inside the unit square and `radii` must be non‑negative.  

**Guidance for exploration**  
- Feel free to replace the simple ring placement with any deterministic or stochastic scheme, as long as the code remains self‑contained.  
- Iteratively refine the layout: compute radii, detect overlaps, adjust positions, recompute radii, repeat a fixed small number of times (e.g., 5–10 iterations).  
- You may introduce helper functions **inside** the EVOLVE‑BLOCK to keep the main logic clear.  
- Test locally by calling `run_packing()` and checking that `sum_of_radii` increases compared to the baseline.  

**Common pitfalls to avoid**  
- Forgetting to re‑clip centers after moving them, which can push circles outside the square and cause the validity check to fail.  
- Using in‑place modifications that unintentionally share references between `centers` and `radii`, leading to incorrect radius scaling.  
- Introducing infinite loops or excessively large iteration counts; keep the algorithm deterministic and bounded.  
- Relying on `np.linalg.norm` inside double loops without vectorization – this can dramatically slow down execution without improving score.  
- Over‑scaling radii globally after constraints are satisfied; ensure the final radii still respect every pairwise distance.  

Proceed to edit only the code within the EVOLVE‑BLOCK, applying the above principles to produce a higher‑scoring, still‑valid packing solution.