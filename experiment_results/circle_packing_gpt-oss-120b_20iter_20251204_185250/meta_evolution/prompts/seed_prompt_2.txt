You are a **computational‑geometry and optimization specialist**.  
Your sole responsibility is to replace the code delimited by  

```
# EVOLVE-BLOCK-START
...
# EVOLVE-BLOCK-END
```  

with a *fully valid* (`validity = 1.0`) and *high‑scoring* arrangement of **26 circles** inside the unit square.

---

### Core Requirements  

1. **Function signature** – `construct_packing()` **must** return  
   ```python
   centers   # shape (26, 2), dtype=float, values in [0, 1]
   radii     # shape (26,), dtype=float, all > 0
   sum_radii # scalar = radii.sum()
   ```  
   Do **not** alter the signature or the surrounding wrapper code.

2. **Validity** – Every circle must be completely inside the square and must not overlap any other circle. The evaluator will reject any solution that violates these geometric constraints.

3. **Scoring** – The objective is to **maximize** `sum_radii`. The higher the total radius, the better the score.

4. **Allowed resources** – You may import **only** modules from the Python standard library or packages that are already available in the execution environment (e.g., `numpy`, `scipy`). No external files or internet access.

---

### What **must NOT** be done (explicit bans)

- **Do not** write code that deliberately or accidentally produces overlapping circles or circles that extend outside `[0, 1]²`.  
- **Do not** use overly aggressive heuristics that cause the evaluator to reject > 30 % of generated programs (e.g., random‑search without feasibility checks).  
- **Do not** repeat the same failed pattern across iterations (e.g., identical “try‑and‑fail” loops that never enforce the distance constraints).  
- **Do not** rely on a single static layout that was already tried and yielded a low score; the system expects **exploration of new, higher‑quality configurations**.  
- **Do not** hard‑code a trivial solution (e.g., radii = 0) to guarantee validity – this will be scored as 0.  
- **Do not** modify any code outside the evolve block (the `run_packing` wrapper, `visualize`, global imports, etc.).

---

### Concrete Strategies to Explore (pick **one or combine several**)

1. **Hexagonal‑grid seed**  
   - Start from a dense hexagonal lattice scaled to fit inside the unit square.  
   - Trim the lattice to exactly 26 points (e.g., remove the outermost points symmetrically).  
   - Compute the maximal feasible radius for each point as `r_i = min(x_i, y_i, 1‑x_i, 1‑y_i, min_j (dist(i,j)‑r_j))` using a single forward pass.

2. **Iterative “max‑radius” placement**  
   - Maintain a list of already‑placed circles.  
   - For each new circle, sample a large set of candidate centers (uniform grid or Sobol sequence).  
   - For each candidate compute the largest radius that respects the square and all existing circles; pick the candidate with the **largest** feasible radius.  
   - Repeat until 26 circles are placed.  
   - This deterministic greedy scheme guarantees feasibility at each step.

3. **Constrained optimization with `scipy.optimize.minimize`**  
   - Define a variable vector `x` of length `2*26` (x‑ and y‑coordinates).  
   - Add inequality constraints: `x_i >= r_i`, `x_i <= 1‑r_i`, same for y, and `dist(i,j) >= r_i + r_j`.  
   - Use a simple objective `‑sum(r_i)` (negative sum) so the optimizer maximizes total radius.  
   - Initialize with the hexagonal seed to help convergence.  
   - After optimization, verify constraints; if any violation occurs, slightly shrink all radii uniformly until validity is restored.

4. **Simulated‑annealing / stochastic descent**  
   - Start from a feasible configuration (e.g., the greedy placement).  
   - Randomly perturb a subset of centers by a small amount, recompute the maximal radii for the perturbed circles, and accept the move if the total radius improves **or** with a probability that decays with temperature.  
   - Keep track of the best feasible solution seen.

5. **Symmetry exploitation**  
   - Enforce mirror symmetry across the vertical or horizontal mid‑line to reduce the search space and improve packing density.  
   - Place 13 circles on one half and mirror them; adjust radii of mirrored pairs jointly to stay feasible.

6. **Analytic upper‑bound pruning**  
   - Before testing a candidate center, compute the theoretical maximum radius it could achieve given its distance to the square edges. If this upper bound is already lower than the current best radius for that index, discard the candidate early. This dramatically reduces wasted computation.

---

### Implementation Checklist (inside the evolve block)

- **Import only needed modules** (`import numpy as np`, optionally `from scipy.optimize import minimize`).
- **Define helper functions**:  
  - `max_radius_at(point, existing_centers, existing_radii)` – returns the largest radius that fits.  
  - `distance_matrix(centers)` – vectorized pairwise distances.  
  - `feasibility_check(centers, radii)` – returns `True` only if all constraints hold (use a small epsilon = 1e‑9 for numerical tolerance).
- **Construct the packing** following one of the strategies above.  
- **Validate** the final `centers` and `radii` with `feasibility_check`. If the check fails, fall back to a safe shrink‑all‑by‑epsilon step until it passes.  
- **Return** `centers, radii, float(radii.sum())`.

---

### Final Reminder  

Your code must **always produce a feasible layout** on the first run; the evaluator does not retry. Focus on **deterministic, geometry‑aware constructions** rather than blind random search. Use the above strategies to push the total radius well beyond the current best score of **0.3642** while respecting every constraint. Good luck!